# -*- mode:org; fill-column:79; -*-
n
#+title:HackerRank Coding Problems
#+subtitle:{{{date}}} {{{version}}}
#+date:2019-06-29 23:35
#+macro:version Version 0.5.5
* Introduction
- https://www.hackerrank.com/dashboard

** Tree of Installed Directories and Files
#+name:show-tree
#+begin_src sh :results output :exports results
tree -I '*.org|*.info|*.texi*|*.pdf|*.tex|figs'
#+end_src

#+name:tangle-all
#+begin_src emacs-lisp :results output :exports results
(org-babel-tangle-file "HackerRank.org")
#+end_src

* Node
Programs coded in JavaScript run in the Node.js environment.  The following
code entails the boilerplate for processing command-line arguments using Node's
built-in Streams and Process, in particular ~ReadStream~, ~WriteStream~,
~process.stdin~, and ~process.env~.
** Node Command-Line Processing
The first set of code processes command-line arguments.  The second code
fragment sets up a ~WriteStream~ for writing the result to a file.

#+begin_src js :noweb yes :exports none
<<node-process-command-line-arguments>>
#+end_src

*** Process
:PROPERTIES:
:header-args: :noweb-ref node-process-command-line-arguments
:END:

First are the Node dependencies:

- ~FileSystem~

- ~Process Stdin~ --- the default input encoding is to a buffer; setting the
  encoding to =utf-8= means that the input encoding will be a ~String~.

#+name:node-dependencies
#+begin_src js -n
const fs = require('fs');
process.stdin.setEncoding('utf-8');

#+end_src

- ~inputString~ will become an array holding each line of the input arguments
  as strings.

- ~currentLine~ is a simple counter will be used by the function ~readLine()~
  to produce one line of input after another upon request.

#+name:node-declarations
#+begin_src js +n
let inputString = '';
let currentLine = 0;

#+end_src

This code reads all of the command-line arguments into the variable
~inputString~; upon finishing reading all of the input, the command-line
arguments are broken into an array at newlines, but left in ~inputString~.
During the process, all trailing spaces are removed.

At the conclusion of breaking the arguments into an array, the program's
~main()~ function is called.

#+name:node-process-stdin
#+begin_src js +n
process.stdin.on('readable', () => {
    let chunk;

    while ((chunk = process.stdin.read()) != null)
        inputString += chunk;
});

process.stdin.on('end', () => {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(s => s.replace(/\s*$/, ''));

    main();
});

#+end_src

The function ~readLine()~ is called by the ~main()~ function when it wants
another line of input.

#+name:node-readLine
#+begin_src js +n
function readLine () {
    return inputString[currentLine++];
}

#+end_src

*** Write Stream
This little line of code sets up a ~WriteStream~ at a file established by the
~process.env.OUTPUT_PATH~ environment variable.  The ~main()~ function will
write the result into this file and then close the stream.  The environment
variable must be created prior to running the program or an exception will be
thrown when ~main()~ is entered.

#+name:node-main-write-stream-ws
#+begin_src js
const ws = fs.createWriteStream(process.env.OUTPUT_PATH);
#+end_src

* Data Structures
** Arrays
*** Arrays
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 94.01%
:score:    10
:END:
**** Arrays Problem Definition
An array is a type of data structure that stores elements of the same type in a
contiguous block of memory.  In an array, =A=, of size =N=, each memory
location has some unique index, {{{var(i)}}} (where 0 \le i \le N), that can be
referenced as =A[i]= (you may also see it written as A_i).

Given an array, =A= , of =N= integers, print each element in reverse order as a
single line of space-separated integers.

{{{heading(Input Format)}}}

- The first line contains an integer, =N= (the number of integers in =A=);
- The second line contains =N= space-separated integers describing =A=.


{{{subheading(Sample Input 1)}}}

#+begin_example
4
1 4 3 2
#+end_example


{{{heading(Constraints)}}}

- 1 \le N \le 10^3
- 1 \le A_i \le 10^4, where A_i is the {{{var(i)}}}^th integer in =A=.


{{{heading(Output Format)}}}

Print all =N= integers in =A= in reverse order as a single line of
space-separated integers.

{{{subheading(Sample Output 1)}}}

: 2 3 4 1

**** Arrays Node Process Code
#+name:arrays-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/arrays.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Arrays Main Function
#+name:arrays-main
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/arrays.js :mkdirp yes

function main () {
    <<node-main-write-stream-ws>>

    const arrCount = parseInt(readLine(), 10);
    console.log(`N = ${arrCount}`);

    const arr = readLine().split(' ')
          .map(e => parseInt(e, 10));
    console.log(`A = ${arr}`);

    const result = reverseArray(arr);

    ws.write(result.join(' ') + '\n');

    ws.end();
}
#+end_src

**** Arrays Solution Code
#+name:arrays-reverseArray
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/arrays.js
function reverseArray (a) {
    return a.reverse();
}
#+end_src

**** Arrays Test Code
#+name:arrays-test
#+header: :shebang "#! /usr/bin/env bash"
#+header: :dir data-structures/arrays/node :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/arrays.test.sh
export OUTPUT_PATH=results_arrays
echo Input:
echo \
'4
1 4 3 2' | node arrays.js

echo
echo Results:
cat results_arrays;
#+end_src

*** 2D Array
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 91.19%
:score:    15
:END:
**** Array 2D Problem Definition
Given a 6 \times 6 =2D Array=, ~arr~

#+begin_src sh
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
#+end_src

#+cindex:hourglass, dfn
We define an {{{dfn(hourglass)}}} in =A= to be /a subset of values with indices
falling in this pattern in ~arr~'s graphical representation/:

#+begin_src sh
a b c
  d
e f g
#+end_src

#+cindex:hourglass sum, dfn
There are 16 hourglasses in ~arr~, and an {{{dfn(hourglass sum)}}} is /the sum
of an hourglass' values/.  Calculate the hourglass sum for every hourglass in
~arr~, then print the maximum hourglass sum.

For example, given the =2D array=:
#+begin_src sh
-9 -9 -9  1 1 1
 0 -9  0  4 3 2
-9 -9 -9  1 2 3
 0  0  8  6 6 0
 0  0  0 -2 0 0
 0  0  1  2 4 0
#+end_src
we calculate the following hourglass values:

#+begin_src sh
-63, -34, -9, 12, 
-10, 0, 28, 23, 
-27, -11, -2, 10, 
9, 17, 25, 18
#+end_src

Our highest hourglass value is 16 from the hourglass:

#+begin_src sh
0 4 3
  1
8 6 6
#+end_src

{{{heading(Function Description)}}}

Complete the function ~hourglassSum~ in the editor below.  It should return an
integer, the maximum hourglass sum in the array.

~hourglassSum~ has the following parameter(s):

#+attr_texinfo: :options hourglassSum arr
#+begin_defun
{{{var(arr)}}} is an array of integers 6 \times 6 in size (i.e., a =2D Array=).
This function calculates the largest hourglass sum in the =2D Array=, returning
its value.
#+end_defun

{{{heading(Input Format)}}}

Each of the 6 lines of inputs ~arr[i]~ contains 6 space-separated integers
~arr[i][j]~.

{{{subheading(Sample Input)}}}

#+begin_example
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
#+end_example

{{{heading(Constraints)}}}

- \minus9 \le arr[i][j] \le 9

- 0 \le i, j \le 5

{{{heading(Output Format)}}}

Print the largest (maximum) hourglass sum found in ~arr~.

{{{subheading(Sample Output)}}}

: 19

{{{heading(Explanation)}}}

~arr~ contains the following hourglasses:

#+caption:Description of hourglasses
#+name:hourglasses
[[file:figs/hourglasssum.png]]

The hourglass with the maximum sum (19) is:

#+begin_example
2 4 4
  2
1 2 4
#+end_example

**** Array 2D Node CL Processing
#+name:array2d-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/array2d.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Array2D Hourglass Sum Main Function
#+name:array2d-main
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/array2d.js :mkdirp yes
const ROWS = 6,
COLUMNS = 6;

function main () {
    <<node-main-write-stream-ws>>

    let arr = Array(ROWS);
    for (let i = 0; i < ROWS; i++) {
        arr[i] = readLine()
            .split(' ')
            .map(s => parseInt(s, 10));
        console.log(`Row: ${arr[i]}`);
    }

    let result = hourglassSum(arr);

    ws.write(result + '\n');

    ws.end();
}
#+end_src

**** Array2D Hourglass Sum Solution Code
This is the solution to the problem.  All of the other code simply supports
it.  The ~hourglassSum()~ function receives a reference to a 2D array of equal
rows and columns.  The problem defines its size as a 6 \times 6 2D array, set
by the two constants =ROWS= and =COLUMNS=.

The solution iterates over the center of each hourglass and counts up the sum
of the elements of the hourglass, calculating whether a new maximum value has
been achieved, then returns the maximum value at the conclusion of checking all
hourglasses.

#+name:array2d-hourglassSum-function
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/array2d.js :mkdirp yes
function hourglassSum (arr) {
    let max, sum;
    for (let row = 1; row  < ROWS - 1; row++) {
        for (let col = 1; col < COLUMNS - 1; col++) {
            console.log(`row=${row} col=${col}`);
            sum = (
                arr[row-1][col-1] +
                arr[row-1][col]   +
                arr[row-1][col+1] +
                arr[row][col]     +
                arr[row+1][col-1] +
                arr[row+1][col]   +
                arr[row+1][col+1]
            );
            if (typeof max === 'undefined' || sum > max) {
                max = sum;
            }
            console.log(`sum=${sum} max=${max}`);
        }
    }
    return max;
}
#+end_src

**** Hourglass Sum Test
#+name:array2d-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/arrays/node :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/array2d.test.sh
export OUTPUT_PATH=result_array2d
echo Input:
echo \
'1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0' | node array2d.js

echo
echo Results:
cat result_array2d
#+end_src

*** Dynamic Array
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 83.20%
:score:    15
:END:
**** Dynamic Array Problem Definition
- Create a list, $seqList$, of $N$ empty sequences, where each sequence is
  indexed from $0$ to $N - 1$.  The elements within each of the $N$ sequences
  also use $0$ --indexing.

- Create an integer, $lastAnswer$, and initialize it to $0$.

- The $2$ types of queries that can be performed on your list of sequences
  ($seqList$) are described below:

  1. Query: $1 \times y$

     1. Find the sequence, $seq$, at index \( ( (x \oplus lastAnswer) % N ) \)
        in $seqList$.

     2. Append integer $y$ to sequence $seq$.

  2. Query: $2 \times y$

     1. Find the sequence, $seq$, at index $( (x \oplus lastAnswer) % N)$ in
        $seqList$.

     2. Find the value of element $y % size$ in $seq$ (where $size$ is the size
        of $seq$) and assign it to $lastAnswer$.

     3. Print the new value of $lastAnswer$ on a new line.


{{{heading(Task)}}}

Given $N$, $Q$, and $Q$ queries, execute each query.

*Note*: $\oplus$ is the bitwise XOR operation, which corresponds to the =^=
operator in most languages.  Learn more about it on [[https://en.wikipedia.org/wiki/Exclusive_or][Wikipedia]].

{{{heading(Input Format)}}}

The first line contains two space-separated integers, $N$ (the number of
sequences) and $Q$ (the number of queries), respectively.  Each of the $Q$
subsequent lines contains a query in the format defined above.

{{{heading(Constraints)}}}

- $1 \le N, Q \le 10^5$

- $0 \le x \le 10^9$

- $0 \le y \le 10^9$

- It is guaranteed that query type $2$ will never query an empty sequence or
  index.


{{{heading(Output Format)}}}

For each type $2$ query, print the updated value of $lastAnswer$ on a new line.

{{{heading(Sample Input)}}}

#+begin_example
1 0 5
1 1 7
1 0 3
2 1 0
2 1 1
#+end_example

{{{heading(Sample Output)}}}

#+begin_example
7
3
#+end_example

{{{heading(Example)}}}

{{{subheading(Initial Values:)}}}

$N = 2$

$lastAnswer = 0$

$S_0 = []$

$S_1 = []$

Query 0: =Append 5 to sequence= $( ( 0 \oplus 0) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5]$

$S_1 = []$

Query 1: =Append 7 to sequence=  $( ( 1 \oplus 0 ) \% 2 ) = 1$

$S_0 = [5]$

$S_1 = [7]$

Query 2: =Append 3 to sequence= $( ( 0 \oplus 0 ) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5, 3]$

$S_1 = [7]$

Query 3: =Assign the value at index 0 of sequence$ $( ( 1 \oplus 0 ) \% 2 ) =
0$ to $lastAnswer$, and print $lastAnswer$.

$lastAnswer = 3$

$S_0 = [5,3]$

$S_1 = [7]$

$3$

**** Dynamic Array Node Process
#+name:dynamic-array-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/dynamic.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Dynamic Array Main Function
#+name:dynamic-array-main-function
#+begin_src js +n :tangle data-structures/arrays/node/dynamic.js
function main() {
    // const ws = fs.createWriteStream(process.env.OUTPUT_PATH);
    const ws = process.stdout;

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);
    console.log(`N = ${n}`);

    const q = parseInt(firstMultipleInput[1], 10);
    console.log(`Q = ${q}`);

    let queries = Array(q);

    for (let i = 0; i < q; i++) {
        queries[i] = readLine().replace(/\s+$/g, '').split(' ').map(queriesTemp => parseInt(queriesTemp, 10));
        console.log(`Query: ${queries[i]}`);
    }

    console.log('\nResults:');
    const result = dynamicArray(n, queries);

    ws.write(result.join('\n') + '\n');

    ws.end();
}
#+end_src

**** Dynamic Array Solution Code
#+name:dynamic-array-solution
#+begin_src js +n :tangle data-structures/arrays/node/dynamic.js
/*
 ,* Complete the 'dynamicArray' function below.
 ,*
 ,* The function is expected to return an INTEGER_ARRAY.
 ,* The function accepts following parameters:
 ,*  1. INTEGER n
 ,*  2. 2D_INTEGER_ARRAY queries
 ,*/

function dynamicArray(n, queries) {

    let seqList = Array(n);
    let lastAnswer = 0;
    let result = []; // INTEGER_ARRAY TO RETURN

    queries.forEach(query => {
        const queryType = query[0];
        const x = query[1], y = query[2];
        const seq = ((x ^ lastAnswer) % n);

        switch (queryType) {
            case 1:
              if (typeof seqList[seq] == 'undefined') seqList[seq] = Array();
              seqList[seq].push(y);
            break;

            case 2:
              const seq2 = y % seqList[seq].length;
              lastAnswer = seqList[seq][seq2];
              result.push(lastAnswer);
            break;
        }
    });
    return result;
}
#+end_src

**** Dynamic Array Test
#+name:dynamic-array-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/arrays/node :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/dynamic.test.js
echo Input:
echo \
'2 5
1 0 5
1 1 7
1 0 3
2 1 0
2 1 1' | node dynamic.js
#+end_src

#+RESULTS: dynamic-array-test
#+begin_example
Input:
N = 2
Q = 5
Query: 1,0,5
Query: 1,1,7
Query: 1,0,3
Query: 2,1,0
Query: 2,1,1

Results:
7
3
#+end_example

*** Left Rotation
:PROPERTIES:
:level:    easy
:max-score: 20
:success-rate: 87.28%
:score:    20
:END:
Given an array and a number, ~d~, perform ~d~ left rotations on the array.

**** Left Rotation Problem Statement
A left rotation operation on an array of size ~n~ shifts each of the array's
elements ~1~ unit to the left.  For example, if ~2~ left rotations are
performed on array ~[1,2,3,4,5]~, then the array would become ~[3,4,5,1,2]~.

Given an array of ~n~ integers and a number, ~d~, perform ~d~ left rotations on
the array.  Then print the updated array as a single line of space-separated
integers.

{{{heading(Input Format)}}}

The first line contains two space-separated integers denoting the respective
values of ~n~ (the number of integers) and ~d~ (the number of left rotations
you must perform).

The second line contains ~n~ space-separated integers describing the respective
elements of the array's initial state.

{{{subheading(Sample Input)}}}

#+begin_example
5 4
1 2 3 4 5
#+end_example

{{{subheading(Constraints)}}}

- $1 \le n \le 10^5$
- $1 \le d \le n$
- $1 \le a_i \le 10^6$

{{{heading(Output Format)}}}

Print a single line of ~n~ space-separated integers denoting the final state of
the array after performing ~d~ left rotations.

{{{subheading(Sample Output)}}}

#+begin_example
5 1 2 3 4
#+end_example

{{{heading(Explanation)}}}

When we perform ~d = 4~ left rotations, the array undergoes the following
sequence of changes:

- ~[1, 2, 3, 4, 5]~
- ~[2, 3, 4, 5, 1]~
- ~[3, 4, 5, 1, 2]~
- ~[4, 5, 1, 2, 3]~
- ~[5, 1, 2, 3, 4]~

Thus, we print the array's final state as a single line of space-separated
values, which is ~5 1 2 3 4~.

**** Left Rotation Node CL Processing
#+name:left-rotation-command-line-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/left_rotation.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Left Rotation Main Function
#+name:left-rotation-main-function
#+begin_src js +n :tangle data-structures/arrays/node/left_rotation.js
function main() {
    const nd = readLine().split(' ');

    const n = parseInt(nd[0], 10);
    console.log(`N = ${n}`);

    const d = parseInt(nd[1], 10);
    console.log(`D = ${d}`);

    const a = readLine().split(' ').map(aTemp => parseInt(aTemp, 10));
    console.log(`A = ${a}`);

    const result = left_rotation(a, n, d);

    console.log('\nResults:');
    console.log(result.join(' '));
}
#+end_src

**** Left Rotation Solution
#+name:left-rotation-solution
#+begin_src js +n :tangle data-structures/arrays/node/left_rotation.js
function left_rotation (arr, n, d) {
    return arr.map( (e,i,a) => {
        return a[(i + d) % n];
    });
}
#+end_src

**** Left Rotation Test
#+name:left-rotation-test
#+header: :shebang "#!/usr/bin/env bash" :dir data-structures/arrays/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/left_rotation.test.sh
echo Input:
echo \
'5 4
1 2 3 4 5' | node left_rotation.js
#+end_src

*** Sparse Arrays
:PROPERTIES:
:max-score: 25
:level:    medium
:success-rate: 96.75%
:score:    25
:END:
Determine the number of times a string has previously appeared.
**** Sparse Arrays Problem Statement
There is a collection of input strings and a collection of query strings.  For
each query string, determine how many times it occurs in the list of input
strings.

For example, given input ~strings = ['ab', 'ab', 'abc']~ and ~queries = ['ab',
'abc', 'bc']~, we find 2 instances of ='ab'=, 1 of ='abc'= and 0 of ='bc'=.
For each query, we add an element to our return array, ~results = [2, 1, 0]~.

{{{heading(Functional Description)}}}

Complete the function ~matchingStrings~ in the editor below.  The function must
return an array of integers representing the frequency of occurrence of each
query string in strings.

#+attr_texinfo: :options matchingStrings strings queries
#+begin_defun
{{{var(strings)}}} is an array of strings to search.  {{{var(queries)}}} is an
array of query strings.
#+end_defun

{{{heading(Input Format)}}}

The first line contains an integer ~n~, the size of ~strings~.

Each of the next ~n~ lines contains a string ~strings[i]~.

The next line contains ~q~, the size of ~queries~.

Each of the next ~q~ lines contains a string ~queries[i]~.

{{{subheading(Sample Input)}}}

: strings = ['aba', 'baba', 'aba', 'xzxb']

: queries = ['aba', xzxb', 'ab']

#+begin_example
4
aba
baba
aba
xzxb
3
aba
xzxb
ab
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le q \le 1000

- 1 \le ~|strings[i]|~, ~|queries[i]|~ \le 20


{{{heading(Output Format)}}}

Return an integer array of the results of all queries in order.

{{{subheading(Sample Output)}}}

: results = [2, 1, 0]

#+begin_example
2
1
0
#+end_example

{{{heading(Explanation)}}}

Here, "aba" occurs twice, in the first and third string.  The string "xzxb"
occurs once in the fourth string, and "ab" does not occur at all.

{{{heading(Sample Input 2)}}}

: strings = ['def', 'de', 'fgh']

: queries = ['de', 'lmn', 'fgh']

#+begin_example
3
def
de
fgh
3
de
lmn
fgh
#+end_example

{{{heading(Sample Output)}}}

: results = [1, 0, 1]

#+begin_example
1
0
1
#+end_example

{{{heading(Sample Input 3)}}}

#+begin_example
13
abcde
sdaklfj
asdjf
na
basdn
sdaklfj
asdjf
na
asdjf
na
basdn
sdaklfj
asdjf
5
abcde
sdaklfj
asdjf
na
basdn
#+end_example

{{{heading(Sample Output)}}}

#+begin_example
1
3
4
3
2
#+end_example

**** Sparse Arrays Node CL Processing
#+name:sparse-arrays-node-cl-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/sparse_arrays.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Sparse Arrays ~main~ Function
#+name:sparse-arrays-main
#+begin_src js +n :tangle data-structures/arrays/node/sparse_arrays.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const stringsCount = parseInt(readLine(), 10);
    console.log(`n = ${stringsCount}`);

    let strings = [];

    for (let i = 0; i < stringsCount; i++) {
        const stringsItem = readLine();
        strings.push(stringsItem);
    }
    console.log(`strings: ${strings}`);

    const queriesCount = parseInt(readLine(), 10);
    console.log(`q = ${queriesCount}`);

    let queries = [];

    for (let i = 0; i < queriesCount; i++) {
        const queriesItem = readLine();
        queries.push(queriesItem);
    }
    console.log(`queries: ${queries}`);

    let res = matchingStrings(strings, queries);

    ws.write(res.join("\n") + "\n");

    ws.end();
}
#+end_src

**** Sparse Arrays ~matchingStrings~ Function
#+name:sparse-arrays-matchingStrings-function
#+begin_src js +n :tangle data-structures/arrays/node/sparse_arrays.js
function matchingStrings(strings, queries) {
    strings.sort();
    let results = [];
    queries.forEach((e,i) => {
        let count = 0;
        let j;
        if ((j = strings.findIndex(e1 => e1 === e)) >= 0) {
            count++;
            while (strings[++j] === e) count++;
        }
        results[i] = count;
    });
    return results;
}
#+end_src

**** Sparse Arrays Test Code
#+name:sparse-arrays-test-code
#+header: :shebang "#!/usr/bin/env bash"
#+header: :results output :exports both :dir data-structures/arrays/node
#+begin_src sh -n :tangle data-structures/arrays/node/sparse_arrays.test.sh
export OUTPUT_PATH=results_sparse_arrays
echo Input 1
echo \
'4
aba
baba
aba
xzxb
3
aba
xzxb
ab' | node sparse_arrays.js
echo Results 1
cat results_sparse_arrays
echo

echo Input 2
echo '3
def
de
fgh
3
de
lmn
fgh' | node sparse_arrays.js
echo Results 2
cat results_sparse_arrays
echo

echo Input 3
echo '13
abcde
sdaklfj
asdjf
na
basdn
sdaklfj
asdjf
na
asdjf
na
basdn
sdaklfj
asdjf
5
abcde
sdaklfj
asdjf
na
basdn' | node sparse_arrays.js
echo Results 3
cat results_sparse_arrays
echo
#+end_src

*** Array Manipulation
:PROPERTIES:
:max-score: 60
:level:    hard
:success-rate: 51.96%
:score:    60
:END:
Perform ~m~ operations on an array and print the maximum of the values.
**** Array Manipulation Problem Statement
Starting with a 1-indexed array of zeros and a list of operations, for each
operation add a value to each of the array elements between two given indices,
inclusive.  Once all operations have been performed, return the maximum value
in your array.

For example, the length of your array of zeros ~n = 10~.  Your list of queries
is as follows:

#+begin_example
a b k
1 5 3
4 8 7
6 9 1
#+end_example

Add the values of ~k~ between the indices ~a~  and ~b~ inclusive:

#+begin_example
index->	 1 2 3  4  5 6 7 8 9 10
	[0,0,0, 0, 0,0,0,0,0, 0]
	[3,3,3, 3, 3,0,0,0,0, 0]
	[3,3,3,10,10,7,7,7,0, 0]
	[3,3,3,10,10,8,8,8,1, 0]
#+end_example

The largest value is ~10~ after all operations are performed.

{{{heading(Function Description)}}}

The first line contains two space-separated integers ~n~ and ~m~, the size of
the array and the number of operations.

Each of the next ~m~ lines contains three space-separated integers ~a~, ~b~ and
~k~, the left index, right index and summand.

{{{subheading(Sample Input)}}}

#+begin_example
5 3
1 2 100
2 5 100
3 4 100
#+end_example

{{{heading(Constraints)}}}

- 3 \le ~n~ \le 10^7

- 1 \le ~m~ \le 2 * 10^5

- 1 \le ~a~ \le ~b~ \le ~n~

- 0 \le ~k~ \le 10^9


{{{heading(Output Format)}}}

Return the integer maximum value in the finished array.

{{{subheading(Sample Output)}}}

: 200

{{{heading(Explanation)}}}

- After the first update list will be ~100 100 0 0 0~.

- After the second update list will be ~100 200 100 100 100~.

- After the third update list will be ~100 200 200 200 100~.

- The required answer will be ~200~.

**** Array Manipulation Node CL Processing
#+name:array-manipulation-node-process-cl
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/array_manipulation.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Array Manipulation Main Function
#+name:array-manipulation-main
#+begin_src js +n :tangle data-structures/arrays/node/array_manipulation.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const nm = readLine().split(' ');

    const n = parseInt(nm[0], 10);
    console.log(`n = ${n}`);

    const m = parseInt(nm[1], 10);
    console.log(`m = ${m}`);

    let queries = Array(m);

    for (let i = 0; i < m; i++) {
        queries[i] = readLine().split(' ').map(queriesTemp => parseInt(queriesTemp, 10));
        console.log(`query: ${queries[i]}`);
    }

    let result = arrayManipulation(n, queries);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

**** Array Manipulation Solution Code
#+name:array-manipulation-solution
#+begin_src js +n :tangle data-structures/arrays/node/array_manipulation.js
// Complete the arrayManipulation function below.
function arrayManipulation(n, queries) {
    const arr = Array(n);
    arr.fill(0);

    for (let [a, b, k] of queries) {
        arr[a-1] += k;
        if (b < n) arr[b] -= k;
    }

    let max = 0, x = 0;
    for (let i = 0; i < n; i++) {
        x += arr[i];
        if (x > max) max = x;
    }

    return max;
}
#+end_src

**** Array Manipulation Test Code
#+name:array-manipulation-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/arrays/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/array_manipulation.sh
export OUTPUT_PATH=results_array_manipulation
echo Input:
echo '5 3
1 2 100
2 5 100
3 4 100' | node array_manipulation.js
echo
echo Results:
cat results_array_manipulation
#+end_src

** Linked Lists
*** Print the Elements of a Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:score:    5
:success-rate: 96.67%
:END:
#+cindex:linked list
#+cindex:head node
If you're new to linked lists, this is a great exercise for learning about
them.  Given a pointer to the head node of a linked list, print its elements in
order, one element per line.  If the head pointer is null (indicating the list
is empty), don’t print anything.

{{{heading(Input Format)}}}

The first line of input contains ~n~, the number of elements in the linked
list.  The next ~n~ lines contain one element each, which are the elements of
the linked list.

*Note*: Do not read any input from stdin/console.  Complete the
~printLinkedList~ function in the editor below.

{{{subheading(Sample Input)}}}

#+begin_example
1
16
13
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the linked
  list.


{{{heading(Output Format)}}}

Print the integer data for each element of the linked list to stdout/console
(e.g.: using ~printf~, ~cout~, etc.).  There should be one element per line.

{{{subheading(Sample Output)}}}

#+begin_example
16
13
#+end_example

{{{heading(Explanation)}}}

There are two elements in the linked list.  They are represented as ~16 -> 13
-> NULL~.  So, the ~printLinkedList~ function should print 16 and 13 each in a
new line.

**** Print Linked List Node CL Processing
#+name:print-linked-list-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/print_linked_list.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Print Linked List Main Function
#+name:print-linked-list-main
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
function main() {
    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data = ${llistItem}`);
        llist.insertNode(llistItem);
    }

    printLinkedList(llist.head);
}
#+end_src

**** Print Linked List Node Classes
***** Singly Linked List Node Class
#+name:singly-linked-list-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};
#+end_src

***** Singly Linked List Class
#+name: singly-linked-list-class
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};
#+end_src

**** Print Linked List Solution
#+name:print-linked-list-printLinkedList
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
// Complete the printLinkedList function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function printLinkedList(head) {
    if (!head) return;
    const data = head.data;
    const next = head.next;
    console.log(data);
    printLinkedList(next);
}
#+end_src

**** Print Linked List Test Data
#+name:print-linked-list-test
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/print_linked_list.test.sh
echo '2
16
13' | node print_linked_list.js
#+end_src

#+RESULTS: print-linked-list-test
: n = 2
: data = 16
: data = 13
: 16
: 13

*** Insert a Node at the Tail of Linked List
:PROPERTIES:
:max-score: 5
:level:    easy
:success-rate: 95.28%
:score:    5
:END:
#+cindex:linked list
#+cindex:head node
#+cindex:tail node
You are given the pointer to the head node of a linked list and an integer to
add to the list.  Create a new node with the given integer.  Insert this node
at the tail of the linked list and return the head node of the linked list
formed after inserting this new node.  The given head pointer may be null,
meaning that the initial list is empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode~
~insertAtTail(SinglyLinkedListNode head, int data)~ method.  It takes two
arguments: the head of the linked list and the integer to insert at tail.  You
should not read any input from the stdin/console.

The input is handled by code editor and is as follows:

- The first line contains an integer ~n~, denoting the elements of the linked
  list.

- The next ~n~ lines contain an integer each, denoting the elements that need
  to be inserted at tail.


{{{subheading(Sample Input)}}}

#+begin_example
5
141
302
164
530
474
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000


{{{heading(Output Format)}}}

Insert the new node at the tail and just return the head of the updated linked
list.  Do not print anything to stdout/console.  The output is handled by code
in the editor and is as follows:

- Print the elements of the linked list from head to tail, each in a new line.


{{{subheading(Sample Output)}}}

#+begin_example
141
302
164
530
474
#+end_example

{{{heading(Explanation)}}}

- First the linked list is NULL. After inserting 141, the list is 141 -> NULL.

- After inserting 302, the list is 141 -> 302 -> NULL.

- After inserting 164, the list is 141 -> 302 -> 164 -> NULL.

- After inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL.

- After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL,
  which is the final list.

**** Insert Node at Tail Node CL Processing
#+name:insert-node-at-tail-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_node_llist.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Insert Node at Tail Main
#+name:insert-node-at-tail-main
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data: ${llistItem}`);
    	const llist_head = insertNodeAtTail(llist.head, llistItem);
      	llist.head = llist_head;
    }

    printSinglyLinkedList(llist.head, '\n', ws);
    ws.write('\n');

    ws.end();
}
#+end_src

**** Insert Node at Tail Node Classes
***** Singly Linked List Node Class
#+name:insert-node-singly-linked-list-node
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Singly Linked List Class
#+name:insert-node-singly-linked-list
#+header: :noweb yes
#+begin_src +n :tangle data-structures/linked_lists/node/insert_node_llist.js
<<singly-linked-list-class>>
#+end_src

***** Print Singly Linked List
#+name:print-singly-linked-list
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
function printSinglyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}
#+end_src

**** Insert Node at Tail insertNodeAtTail
#+name:insert-node-at-tail-insertNodeAtTail
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
// Complete the insertNodeAtTail function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function insertNodeAtTail(head, data) {
    const newNode = new SinglyLinkedListNode(data);
    if (head === null) {
        head = newNode;
    } else {
        let oldHead = head;
        while (oldHead.next !== null) {
            oldHead = oldHead.next
        }
        oldHead.next = newNode;
    }
    return head;
}
#+end_src

**** Insert Node at Tail Test
#+name:insert-node-at-tail-test
#+header: :results output :exports results
#+header: :dir data-structures/linked_lists/node
#+begin_src sh -n :tangle data-structures/linked_lists/node/insert_node_llist.test.sh
export OUTPUT_PATH=results_insert_node_llist
echo '5
141
302
164
530
474' | node insert_node_llist.js
echo
echo Results
cat results_insert_node_llist
#+end_src

*** Insert a Node at the Head of Linked List
:PROPERTIES:
:max-score: 5
:level:    easy
:success-rate: 98.50%
:END:
You’re given the pointer to the head node of a linked list and an integer to
add to the list.  Create a new node with the given integer, insert this node at
the head of the linked list and return the new head node.  The head pointer
given may be null meaning that the initial list is empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode Insert(SinglyLinkedListNode
head, int data)~ method which takes two arguments --- the head of the linked
list and the integer to insert.  You should NOT read any input from
stdin/console.

The input is handled by code in the editor and is as follows:

- The first line contains an integer ~n~, denoting the number of elements to be
  inserted at the head of the list.

- The next ~n~ lines contain an integer each, denoting the elements to be
  inserted.


{{{subheading(Sample Input)}}}

#+begin_example
5
383
484
392
975
321
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000


{{{heading(Output Format)}}}

Insert the new node at the head and return the head of the updated linked list.
Do NOT print anything to stdout/console.  The output is handled by the code in
the editor and it is as follows:

- Print the elements of linked list from head to tail, each in a new line.


{{{subheading(Sample Output)}}}

#+begin_example
321
975
392
484
383
#+end_example

{{{heading(Explanation)}}}

- Intially the list in NULL. After inserting 383, the list is 383 -> NULL.
- After inserting 484, the list is 484 -> 383 -> NULL.
- After inserting 392, the list is 392 -> 484 -> 383 -> NULL.
- After inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.
- After inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.

**** Insert Node at Head of Linked List Node CL Processing
#+name:insert-node-head-linked-list-node-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<node-process-command-line-arguments>>
#+end_src

**** Insert Node at Head of Linked List Classes
***** Insert Node at Head of Singly Linked List Node Class
#+name:insert-node-head-llist-node-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Insert Node at Head of Singly Linked List Class
#+name:insert-node-head-llist-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<singly-linked-list-class>>
#+end_src

***** Insert Node at Head of Singly Linked List Print Function
#+name:insert-node-head-llist-print
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<print-singly-linked-list>>
#+end_src

**** Insert Node at Head of Linked List Main Function
#+name:insert-node-head-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data: ${llistItem}`);
    	const llist_head = insertNodeAtHead(llist.head, llistItem);
      	llist.head = llist_head;
    }

    printSinglyLinkedList(llist.head, '\n', ws);
    ws.write('\n');

    ws.end();
}
#+end_src

**** insertNodeAtHead Function
#+name:insert-node-head-llist-insertNodeAtHead
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
// Complete the insertNodeAtHead function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function insertNodeAtHead(head, data) {
    const newNode = new SinglyLinkedListNode(data);
    newNode.next = head;
    head = newNode;

    return head;
}
#+end_src

**** Insert Node at Head of Linked List Test
#+name:insert-node-head-llist-insert_head_llist.test.sj
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/insert_head_llist.test.sh
export OUTPUT_PATH=results_insert_head_llist
echo Input:
echo '5
383
484
392
975
321' | node insert_head_llist.js
echo
echo Results:
cat results_insert_head_llist
#+end_src
*** Delete a Node
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 97.22%
:END:
You’re given the pointer to the head node of a linked list and the position of
a node to delete.  Delete the node at the given position and return the head
node.  A position of 0 indicates head, a position of 1 indicates one node away
from the head and so on.  The list may become empty after you delete the node.

{{{heading(Input Format)}}}

You have to complete the ~deleteNode(SinglyLinkedListNode* llist, int
position)~ method which takes two arguments --- the head of the linked list and
the position of the node to delete.  You should NOT read any input from
stdin/console.  ~position~ will always be at least 0 and less than the number
of the elements in the list.

- The first line of input contains an integer ~n~, denoting the number of
  elements in the linked list.

- The next ~n~ lines contain an integer each in a new line, denoting the
  elements of the linked list in the order.

- The last line contains an integer ~position~ denoting the position of the
  node that has to be deleted form the linked list.


{{{subheading(Sample Input)}}}

#+begin_example
8
20
6
2
19
7
4
15
9
3
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 1000

- 1 \le ~list_i~ \le 1000, where ~list_i~ is the ~i^th~ element of the linked
  list


{{{heading(Output Format)}}}

Delete the node at the given position and return the head of the updated linked
list.  Do NOT print anything to stdout/console.  The code in the editor will
print the updated linked list in a single line separated by spaces.

{{{subheading(Sample Output)}}}

: 20 6 2 7 4 15 9

{{{heading(Explanation)}}}

The given linked list is =20->6->2->19->7->4->15->9=.  We have to delete the
node at ~position~ 3, which is 19.  After deleting that node, the updated
linked list is: =20->6->2->7->4->15->9=.

**** Delete a Node from a Linked List Node CL Processing
#+name:delete-node-llist-node-cl
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<node-process-command-line-arguments>>
#+end_src

**** Delete a Node from a Linked List Classes
***** Delete a Node Node Class
#+name:delete-node-llist-node-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Delete a Node Class
#+name:delete-node-llist-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<singly-linked-list-class>>
#+end_src

***** Delete a Node Print a Linked List Function
#+name:delete-node-llist-print
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<print-singly-linked-list>>
#+end_src

**** Delete a Node from a Linked List Main Function
#+name:delete-node-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        llist.insertNode(llistItem);
        console.log(`data: ${llistItem}`);
    }

    const position = parseInt(readLine(), 10);
    console.log(`position = ${position}`);

    let llist1 = deleteNode(llist.head, position);

    printSinglyLinkedList(llist1, " ", ws)
    ws.write("\n");

    ws.end();
}
#+end_src

**** Delete a Node from a Linked List deleteNode Function
#+name:delete-node-llist-deleteNode
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
// Complete the deleteNode function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function deleteNode(head, position) {
    let prior = null;
    let current = head;
    while (position--) {
        prior = current;
        current = current.next;
    }
    if (prior === null) head = current.next;
    else prior.next = current.next;
    return head;
}
#+end_src

**** Delete a Node from a Linked List Test
#+name:delete-node_llist_test
#+header: :shebang "#!/usr/bin/env bash" :results output :exports results
#+header: :dir data-structures/linked_lists/node
#+begin_src sh -n :tangle data-structures/linked_lists/node/delete_node_llist.test.sh
export OUTPUT_PATH=results_delete_llist
echo Input:
echo \
'8
20
6
2
19
7
4
15
9
3' | node delete_node_llist.js

echo
echo Results:
cat results_delete_llist
#+end_src

*** Print in Reverse
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 97.89%
:END:
You are given the pointer to the head node of a linked list and you need to
print all its elements in reverse order from tail to head, one element per
line.  The head pointer may be null meaning that the list is empty---in that
case, do not print anything!

{{{heading(Input Format)}}}

You have to complete the ~void reversePrint(SinglyLinkedListNode* head)~ method
which takes one argument---the head of the linked list.  You should NOT read any
input from stdin/console.

The first line of input contains ~t~, the number of test cases.

The input of each test case is as follows:

- The first line contains an integer ~n~, denoting the number of elements in
  the list.

- The next ~n~ lines contain one element each, denoting the elements of the
  linked list in the order.


{{{subheading(Sample Input)}}}

#+begin_example
3
5
16
12
4
2
5
3
7
3
9
5
5
1
18
3
13
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element in the list.


{{{heading(Output Format)}}}

Complete the ~reversePrint~ function in the editor below and print the elements
of the linked list in the reverse order, each in a new line.

{{{subheading(Sample Output)}}}

#+begin_example
5
2
4
12
16
9
3
7
13
3
18
1
5
#+end_example

{{{heading(Explanation)}}}

There are three test cases.

The first linked list has 5 elements: =16 -> 12 -> 4 -> 2 -> 5=.  Printing this
in reverse order will produce: =5 -> 2 -> 4 -> 12 -> 16=.

The second linked list has 3 elements: =7 -> 3 -> 9=.  Printing this in reverse
order will produce: =9 -> 3 -> 7=.

The third linked list has 5 elements: =5 -> 1 -> 18 -> 3 -> 13=.  Printing this
in reverse order will produce: =13 -> 3 -> 18 -> 1 -> 5=.

**** Print in Reverse Node CL Processing
#+name:print-in-reverse-node-cl-processing
#+begin_src js -n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Print in Reverse Node Classes
***** Print in Reverse Linked List Node Class
#+name:print-in-reverse-linked-list-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};
#+end_src

***** Print in Reverse Linked List Class
#+name:print-in-reverse-linked-list-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};
#+end_src

***** Print in Reverse Linked List Print
#+name:print-in-reverse-linked-list-print
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
function printSinglyLinkedList(node, sep) {
    while (node != null) {
        process.stdout.write(String(node.data));

        node = node.next;

        if (node != null) {
            process.stdout.write(sep);
        }
    }
}
#+end_src

**** Print in Reverse Linked List Main Function
#+name:print-in-reverse-linked-list-main
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
unction main() {
    const tests = parseInt(readLine(), 10);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        const llistCount = parseInt(readLine(), 10);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            llist.insertNode(llistItem);
        }

        reversePrint(llist.head);
    }
}
#+end_src

**** Print in Reverse Linked List reversePrint Function
#+name:print-in-reverse-linked-list-reversePrint
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
// Complete the reversePrint function below.

/*
 * For your reference:
 *
 * SinglyLinkedListNode {
 *     int data;
 *     SinglyLinkedListNode next;
 * }
 *
 */
function reversePrint(head) {

}
#+end_src

**** Print in Reverse Linked List Test
#+name:print-in-reverse-linked-list-test
#+header: dir data-structure/linked_lists/node :results output :exports results
#+begin_src js -n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.test.js
echo \
'3
5
16
12
4
2
5
3
7
3
9
5
5
1
18
3
13' | node reverseSinglyLinkedList.js
#+end_src

* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Export Settings                                                  :noexport:
** Options
#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:t tex:t
#+options: H:4

** Texinfo Export Settings
#+texinfo_filename:hackerrank.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Coding
#+texinfo_dir_title:HackerRank Coding Problems
#+texinfo_dir_desc:HackerRank coding problems
#+texinfo_printed_title:HackerRank Coding Problems

** HTML Export Settings
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.2.4)
#+latex_header:

* Macro Definitions                                                :noexport:
#+macro:heading @@texinfo:@heading @@@@html:<h4>@@$1@@html:</h4>@@
#+macro:subheading @@texinfo:@subheading @@@@html:<h5>@@$1@@html:</h5>@@
#+macro:dfn @@texinfo:@dfn{@@@@html:<b>@@$1@@texinfo:}@@@@html:</b>@@
#+macro:var @@texinfo:@var{@@$1@@texinfo:}@@
* Local Variables                                                  :noexport:
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
