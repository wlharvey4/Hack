# -*- mode:org; fill-column:79; -*-

#+title:HackerRank Coding Problems
#+subtitle:{{{date}}} {{{version}}}
#+date:2019-6-20 15:01
#+macro:version Version 0.1.2
* Data Structures
** Arrays
*** Arrays
**** Arrays Problem Definition
An array is a type of data structure that stores elements of the same type in a
contiguous block of memory.  In an array, =A=, of size =N=, each memory
location has some unique index, {{{var(i)}}} (where 0 \le i \le N), that can be
referenced as =A[i]= (you may also see it written as A_i).

Given an array, =A= , of =N= integers, print each element in reverse order as a
single line of space-separated integers.

{{{heading(Input Format)}}}

- The first line contains an integer, =N= (the number of integers in =A=);
- The second line contains =N= space-separated integers describing =A=.


{{{subheading(Sample Input 1)}}}

#+begin_example
4
1 4 3 2
#+end_example


{{{heading(Constraints)}}}

- 1 \le N \le 10^3
- 1 \le A_i \le 10^4, where A_i is the {{{var(i)}}}^th integer in =A=.


{{{heading(Output Format)}}}

Print all =N= integers in =A= in reverse order as a single line of
space-separated integers.

{{{subheading(Sample Output 1)}}}

: 2 3 4 1

**** Arrays Processing Code
#+name:arrays-prelim
#+begin_src js -n :tangle arrays/node/arrays.js :mkdirp yes
'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');
#+end_src

#+name:arrays-declarations
#+begin_src js +n :tangle arrays/node/arrays.js
let inputString = '';
let currentLine = 0;
#+end_src

#+name:arrays-process-command-line-args
#+begin_src js +n :tangle arrays/node/arrays.js
process.stdin.on('data', inputStdin => {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(str => str.replace(/\s*$/, ''));

    main();
});
#+end_src

#+name:arrays-readLine
#+begin_src js +n :tangle arrays/node/arrays.js
function readLine() {
    return inputString[currentLine++];
}
#+end_src

#+name:arrays-main
#+begin_src js +n :tangle arrays/node/arrays.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const arrCount = parseInt(readLine(), 10);

    const arr = readLine().split(' ').map(arrTemp => parseInt(arrTemp, 10));

    const res = reverseArray(arr);

    ws.write(res.join(' ') + '\n');

    ws.end();
}
#+end_src

**** Arrays Solution Code
#+name:arrays-reverseArray
#+begin_src js +n :tangle arrays/node/arrays.js
  function reverseArray (a) {
      return a.reverse();
  }
#+end_src

**** Arrays Test Code
#+name:arrays-test
#+header: :shebang "#! /usr/bin/env bash"
#+begin_src sh :tangle arrays/node/arrays_test.sh
export OUTPUT_PATH=./result
echo '4
1 4 3 2' | node arrays.js
echo Result:
cat result;
#+end_src

*** 2D Array
**** 2D Problem Definition
Given a 6 \times 6 =2D Array=, ~arr~

#+begin_src sh
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
#+end_src

#+cindex:hourglass, dfn
We define an {{{dfn(hourglass)}}} in =A= to be /a subset of values with indices
falling in this pattern in ~arr~'s graphical representation/:

#+begin_src sh
a b c
  d
e f g
#+end_src

#+cindex:hourglass sum, dfn
There are 16 hourglasses in ~arr~, and an {{{dfn(hourglass sum)}}} is /the sum
of an hourglass' values/.  Calculate the hourglass sum for every hourglass in
~arr~, then print the maximum hourglass sum.

For example, given the =2D array=:
#+begin_src sh
-9 -9 -9  1 1 1
 0 -9  0  4 3 2
-9 -9 -9  1 2 3
 0  0  8  6 6 0
 0  0  0 -2 0 0
 0  0  1  2 4 0
#+end_src
we calculate the following hourglass values:

#+begin_src sh
-63, -34, -9, 12, 
-10, 0, 28, 23, 
-27, -11, -2, 10, 
9, 17, 25, 18
#+end_src

Our highest hourglass value is 16 from the hourglass:

#+begin_src sh
0 4 3
  1
8 6 6
#+end_src

{{{heading(Function Description)}}}

Complete the function ~hourglassSum~ in the editor below.  It should return an
integer, the maximum hourglass sum in the array.

~hourglassSum~ has the following parameter(s):

#+attr_texinfo: :options hourglassSum arr
#+begin_defun
{{{var(arr)}}} is an array of integers 6 \times 6 in size (i.e., a =2D Array=).
This function calculates the largest hourglass sum in the =2D Array=, returning
its value.
#+end_defun

{{{heading(Input Format)}}}

Each of the 6 lines of inputs ~arr[i]~ contains 6 space-separated integers
~arr[i][j]~.

{{{subheading(Sample Input)}}}

#+begin_example
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
#+end_example

{{{heading(Constraints)}}}

- \minus9 \le arr[i][j] \le 9

- 0 \le i, j \le 5

{{{heading(Output Format)}}}

Print the largest (maximum) hourglass sum found in ~arr~.

{{{subheading(Sample Output)}}}

: 19

{{{heading(Explanation)}}}

~arr~ contains the following hourglasses:

#+caption:Description of hourglasses
#+name:hourglasses
[[file:figs/hourglasssum.png]]

The hourglass with the maximum sum (19) is:

#+begin_example
2 4 4
  2
1 2 4
#+end_example

**** 2D Code Framework

{{{heading(Dependencies)}}}

The preliminary code sets up the dependencies
- Node.js =File System=,
- the encoding of ~process.stdin~ as a =utf-8= string, and
- an output file, ~result~

#+name:2d-array-dependencies
#+begin_src js -n :tangle array2d/node/index.js :mkdirp yes
'use strict';

const fs = require('fs');

process.stdin.setEncoding('utf-8');
#+end_src

{{{heading(Declarations)}}}

The /declarations/ section declares some variables that will be needed in the
program:
- ~inputString~ :: the 2D array as a multi-line string of numbers
- ~currentLine~ :: a counter used in the ~readLine()~ function for each row of
                   the 2D array
- ~ROWS~ and ~COLUMNS~ :: maximum size of the 2D array

#+name:2d-array-declarations
#+begin_src js +n :tangle array2d/node/index.js
let inputString = '';
let currentLine = 0;
const ROWS = 6, COLUMNS = 6;
#+end_src

{{{heading(Input)}}}

The /Input/ section reads ~STDIN~ for a multi-line string of numbers.  It
breaks the string into a single dimension array containing space-separated
numbers using Node's ~process.stdin~ =StreamReader= built-in.

The =readable= event indicates that some data is ready to be read.  The data is
placed into an internal buffer.  The size of the internal buffer is unknown,
and the size of the data stream is unknown.  Therefore, after receiving a
=readable= event, the code calls the =ReadableStream='s ~read()~ method
repeatedly until the buffer is empty.  This repeats until there is no more data
to be read, at which point the program receives the =end= event.

When the =end= event is received, the program splits the input on newlines,
removing all trailing spaces, creating an array of rows in ~inputString~.  The
individual rows are still in string form as space-separated numbers.  These
will be turned into the second dimension array by the ~main()~ function, one by
one.

#+name:2d-array-process-input
#+begin_src js +n :tangle array2d/node/index.js
process.stdin.on('readable', () => {
    console.log('readable ...');

    let chunk;
    while ((chunk = process.stdin.read()) !== null) {
        console.log(`chunk:\n${chunk}`);
        inputString += chunk;
    }
});

process.stdin.on('end', () => {
    console.log(`'end'\ninputString:\n${inputString}`);
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(str => str.replace(/\s*$/, ''));

    main();
});
#+end_src

{{{heading(readLine() Function)}}}

The /Process/ section described above runs immediately upon execution of the
program to read the standard input and set up the ~inputString~ as a single
dimension array of rows.  The ~main()~ function calls the ~readLine()~ function
to obtain each row of the array.  It's function is simpy to return the next row
to ~main()~.

#+name:array2d-readline
#+begin_src js +n :tangle array2d/node/index.js
function readLine () {
    return inputString[currentLine++];
}
#+end_src

{{{heading(main() Function)}}}

The ~main()~ function establishes a =WritableStream= (~OUTPUT_PATH~), creates
a single-dimension array ~arr~ of size ~ROWS~, iterates over the array's rows,
processes each row into an array of numbers, and ultimately obtains a
two-dimensional array in ~arr[i][j]~.

Then, it calls the function ~hourglassSum()~, passing in a reference to this
two-dimensional array ~arr~, and receives back the result, which it then
stores in the output file ~OUTPUT_PATH~.  Finally, it closes the output file,
using the ~end()~ method of the =WritableStream=.

#+name:array2d-main
#+begin_src js +n :tangle array2d/node/index.js
function main () {
    console.log('main');

    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    let arr = Array(ROWS);

    for (let i = 0; i < ROWS; i++) {
        arr[i] = readLine()
            .split(' ')
            .map(arrTemp => parseInt(arrTemp, 10));

        console.log(`i: ${i}\n${arr[i]}`);
    }

    let result = hourglassSum(arr);
    console.log(`result: ${result}`);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

**** Hourglass Sum Function

This is the solution to the problem.  All of the other code simply supports
it.  The ~hourglassSum()~ function receives a reference to a 2D array of equal
rows and columns.  The problem defines its size as a 6 \times 6 2D array.

The solution iterates over the center of each hourglass and counts up the sum
of the elements of the hourglass, calculating whether a new maximum value has
been achieved, then returns the maximum value at the conclusion of checking all
hourglasses.

#+name:array2d-hourglassSum-function
#+begin_src js +n :tangle array2d/node/index.js
function hourglassSum (arr) {
    let max, sum;
    for (let row = 1; row  < ROWS - 1; row++) {
        for (let col = 1; col < COLUMNS - 1; col++) {
            console.log(`row=${row} col=${col}`);
            sum = (
                arr[row-1][col-1] +
                arr[row-1][col]   +
                arr[row-1][col+1] +
                arr[row][col]     +
                arr[row+1][col-1] +
                arr[row+1][col]   +
                arr[row+1][col+1]
            );
            if (typeof max === 'undefined' || sum > max) {
                max = sum;
            }
            console.log(`sum=${sum} max=${max}`);
        }
    }
    return max;
}
#+end_src

**** Hourglass Sum Test
#+name:array2d-test
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh -n :tangle array2d/node/index.test.sh
export OUTPUT_PATH='./result'
echo \
'1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0' | node index.js

echo Result:
cat ./result
#+end_src

* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Export Settings                                                  :noexport:
#+options: H:4
** Texinfo Export Settings
#+texinfo_filename:hackerrank.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Coding
#+texinfo_dir_title:HackerRank Coding Problems
#+texinfo_dir_desc:HackerRank coding problems
#+texinfo_printed_title:HackerRank Coding Problems

** HTML Export Settings
#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:t tex:t H:6
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.2.4)
#+latex_header:

* Macro Definitions                                                :noexport:
#+macro:heading @@texinfo:@heading @@@@html:<h4>@@$1@@html:</h4>@@
#+macro:subheading @@texinfo:@subheading @@@@html:<h5>@@$1@@html:</h5>@@
#+macro:dfn @@texinfo:@dfn{@@@@html:<b>@@$1@@texinfo:}@@@@html:</b>@@
#+macro:var @@texinfo:@var{@@$1@@texinfo:}@@
* Local Variables                                                  :noexport:
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%:m-%:d %02H:%02M$"
# End:
