# -*- mode:org; fill-column:79; -*-

#+title:HackerRank Coding Problems
#+subtitle:{{{date}}} {{{version}}}
#+date:2019-06-22 07:41
#+macro:version Version 0.1.7
* Introduction
- https://www.hackerrank.com/dashboard

** Tree of Installed Directories and Files
#+name:show-tree
#+begin_src sh :results output :exports results
tree -I '*.org|*.info|*.texi*|*.pdf|*.tex|figs'
#+end_src

#+name:tangle-all
#+begin_src emacs-lisp :results output :exports results
(org-babel-tangle-file "HackerRank.org")
#+end_src

* Node
Programs coded in JavaScript run in the Node.js environment.  The following
code entails the boilerplate for processing command-line arguments using Node's
built-in Streams and Process, in particular ~ReadStream~, ~WriteStream~,
~process.stdin~, and ~process.env~.
** Node Command-Line Processing
The first set of code processes command-line arguments.  The second code
fragment sets up a ~WriteStream~ for writing the result to a file.

#+begin_src js :noweb yes :exports none
<<node-process-command-line-arguments>>
#+end_src

*** Process
:PROPERTIES:
:header-args: :noweb-ref node-process-command-line-arguments
:END:

First are the Node dependencies:

- ~FileSystem~

- ~Process Stdin~ --- the default input encoding is to a buffer; setting the
  encoding to =utf-8= means that the input encoding will be a ~String~.

#+name:node-dependencies
#+begin_src js -n
const fs = require('fs');
process.stdin.setEncoding('utf-8');

#+end_src

- ~inputString~ will become an array holding each line of the input arguments
  as strings.

- ~currentLine~ is a simple counter will be used by the function ~readLine()~
  to produce one line of input after another upon request.

#+name:node-declarations
#+begin_src js +n
let inputString = '';
let currentLine = 0;

#+end_src

This code reads all of the command-line arguments into the variable
~inputString~; upon finishing reading all of the input, the command-line
arguments are broken into an array at newlines, but left in ~inputString~.
During the process, all trailing spaces are removed.

At the conclusion of breaking the arguments into an array, the program's
~main()~ function is called.

#+name:node-process-stdin
#+begin_src js +n
process.stdin.on('readable', () => {
    let chunk;

    while ((chunk = process.stdin.read()) != null)
        inputString += chunk;
});

process.stdin.on('end', () => {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(s => s.replace(/\s*$/, ''));

    main();
});

#+end_src

The function ~readLine()~ is called by the ~main()~ function when it wants
another line of input.

#+name:node-readLine
#+begin_src js +n
function readLine () {
    return inputString[currentLine++];
}

#+end_src

*** Write Stream
This little line of code sets up a ~WriteStream~ at a file established by the
~process.env.OUTPUT_PATH~ environment variable.  The ~main()~ function will
write the result into this file and then close the stream.  The environment
variable must be created prior to running the program or an exception will be
thrown when ~main()~ is entered.

#+name:node-main-write-stream-ws
#+begin_src js
const ws = fs.createWriteStream(process.env.OUTPUT_PATH);
#+end_src

* Data Structures
** Arrays
*** Arrays
**** Arrays Problem Definition
An array is a type of data structure that stores elements of the same type in a
contiguous block of memory.  In an array, =A=, of size =N=, each memory
location has some unique index, {{{var(i)}}} (where 0 \le i \le N), that can be
referenced as =A[i]= (you may also see it written as A_i).

Given an array, =A= , of =N= integers, print each element in reverse order as a
single line of space-separated integers.

{{{heading(Input Format)}}}

- The first line contains an integer, =N= (the number of integers in =A=);
- The second line contains =N= space-separated integers describing =A=.


{{{subheading(Sample Input 1)}}}

#+begin_example
4
1 4 3 2
#+end_example


{{{heading(Constraints)}}}

- 1 \le N \le 10^3
- 1 \le A_i \le 10^4, where A_i is the {{{var(i)}}}^th integer in =A=.


{{{heading(Output Format)}}}

Print all =N= integers in =A= in reverse order as a single line of
space-separated integers.

{{{subheading(Sample Output 1)}}}

: 2 3 4 1

**** Arrays Main Function
#+name:arrays-main
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/arrays.js :mkdirp yes
  <<node-process-command-line-arguments>>

  function main () {
      <<node-main-write-stream-ws>>

      const arrCount = parseInt(readLine(), 10);

      const arr = readLine().split(' ')
            .map(e => parseInt(e, 10));

      const result = reverseArray(arr);

      ws.write(result.join(' ') + '\n');

      ws.end();
  }
#+end_src

**** Arrays Solution Code
#+name:arrays-reverseArray
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/arrays.js
  function reverseArray (a) {
      return a.reverse();
  }
#+end_src

**** Arrays Test Code
#+name:arrays-test
#+header: :shebang "#! /usr/bin/env bash"
#+begin_src sh :tangle data-structures/arrays/node/arrays.test.sh
export OUTPUT_PATH=./result
echo '4
1 4 3 2' | node arrays.js
echo Result:
cat result;
#+end_src

*** 2D Array
**** Array 2D Problem Definition
Given a 6 \times 6 =2D Array=, ~arr~

#+begin_src sh
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
#+end_src

#+cindex:hourglass, dfn
We define an {{{dfn(hourglass)}}} in =A= to be /a subset of values with indices
falling in this pattern in ~arr~'s graphical representation/:

#+begin_src sh
a b c
  d
e f g
#+end_src

#+cindex:hourglass sum, dfn
There are 16 hourglasses in ~arr~, and an {{{dfn(hourglass sum)}}} is /the sum
of an hourglass' values/.  Calculate the hourglass sum for every hourglass in
~arr~, then print the maximum hourglass sum.

For example, given the =2D array=:
#+begin_src sh
-9 -9 -9  1 1 1
 0 -9  0  4 3 2
-9 -9 -9  1 2 3
 0  0  8  6 6 0
 0  0  0 -2 0 0
 0  0  1  2 4 0
#+end_src
we calculate the following hourglass values:

#+begin_src sh
-63, -34, -9, 12, 
-10, 0, 28, 23, 
-27, -11, -2, 10, 
9, 17, 25, 18
#+end_src

Our highest hourglass value is 16 from the hourglass:

#+begin_src sh
0 4 3
  1
8 6 6
#+end_src

{{{heading(Function Description)}}}

Complete the function ~hourglassSum~ in the editor below.  It should return an
integer, the maximum hourglass sum in the array.

~hourglassSum~ has the following parameter(s):

#+attr_texinfo: :options hourglassSum arr
#+begin_defun
{{{var(arr)}}} is an array of integers 6 \times 6 in size (i.e., a =2D Array=).
This function calculates the largest hourglass sum in the =2D Array=, returning
its value.
#+end_defun

{{{heading(Input Format)}}}

Each of the 6 lines of inputs ~arr[i]~ contains 6 space-separated integers
~arr[i][j]~.

{{{subheading(Sample Input)}}}

#+begin_example
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
#+end_example

{{{heading(Constraints)}}}

- \minus9 \le arr[i][j] \le 9

- 0 \le i, j \le 5

{{{heading(Output Format)}}}

Print the largest (maximum) hourglass sum found in ~arr~.

{{{subheading(Sample Output)}}}

: 19

{{{heading(Explanation)}}}

~arr~ contains the following hourglasses:

#+caption:Description of hourglasses
#+name:hourglasses
[[file:figs/hourglassum.png]]

The hourglass with the maximum sum (19) is:

#+begin_example
2 4 4
  2
1 2 4
#+end_example

**** Hourglass Sum Main Function
#+name:array2d-main
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/array2d/node/array2d.js :mkdirp yes
  <<node-process-command-line-arguments>>

  const ROWS = 6,
  COLUMNS = 6;

  function main () {
      <<node-main-write-stream-ws>>

      let arr = Array(ROWS);
      for (let i = 0; i < ROWS; i++) {
          arr[i] = readLine()
              .split(' ')
              .map(s => parseInt(s, 10));
      }

      let result = hourglassSum(arr);

      ws.write(result + '\n');

      ws.end();
  }
#+end_src

**** Hourglass Sum Solution Code

This is the solution to the problem.  All of the other code simply supports
it.  The ~hourglassSum()~ function receives a reference to a 2D array of equal
rows and columns.  The problem defines its size as a 6 \times 6 2D array, set
by the two constants =ROWS= and =COLUMNS=.

The solution iterates over the center of each hourglass and counts up the sum
of the elements of the hourglass, calculating whether a new maximum value has
been achieved, then returns the maximum value at the conclusion of checking all
hourglasses.

#+name:array2d-hourglassSum-function
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/array2d/node/array2d.js :mkdirp yes
  function hourglassSum (arr) {
      let max, sum;
      for (let row = 1; row  < ROWS - 1; row++) {
          for (let col = 1; col < COLUMNS - 1; col++) {
              console.log(`row=${row} col=${col}`);
              sum = (
                  arr[row-1][col-1] +
                  arr[row-1][col]   +
                  arr[row-1][col+1] +
                  arr[row][col]     +
                  arr[row+1][col-1] +
                  arr[row+1][col]   +
                  arr[row+1][col+1]
              );
              if (typeof max === 'undefined' || sum > max) {
                  max = sum;
              }
              console.log(`sum=${sum} max=${max}`);
          }
      }
      return max;
  }
#+end_src

**** Hourglass Sum Test
#+name:array2d-test
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh -n :tangle data-structures/array2d/node/array2d.test.sh
export OUTPUT_PATH='./result'
echo \
'1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0' | node array2d.js

echo Result:
cat ./result
#+end_src
*** Dynamic Array
**** Dynamic Array Problem Definition
- Create a list, $seqList$, of $N$ empty sequences, where each sequence is
  indexed from $0$ to $N - 1$.  The elements within each of the $N$ sequences
  also use $0$ --indexing.

- Create an integer, $lastAnswer$, and initialize it to $0$.

- The $2$ types of queries that can be performed on your list of sequences
  ($seqList$) are described below:

  1. Query: $1 \times y$

     1. Find the sequence, $seq$, at index \( ( (x \oplus lastAnswer) % N ) \)
        in $seqList$.

     2. Append integer $y$ to sequence $seq$.

  2. Query: $2 \times y$

     1. Find the sequence, $seq$, at index $( (x \oplus lastAnswer) % N)$ in
        $seqList$.

     2. Find the value of element $y % size$ in $seq$ (where $size$ is the size
        of $seq$) and assign it to $lastAnswer$.

     3. Print the new value of $lastAnswer$ on a new line.


{{{heading(Task)}}}

Given $N$, $Q$, and $Q$ queries, execute each query.

*Note*: $\oplus$ is the bitwise XOR operation, which corresponds to the =^=
operator in most languages.  Learn more about it on [[https://en.wikipedia.org/wiki/Exclusive_or][Wikipedia]].

{{{heading(Input Format)}}}

The first line contains two space-separated integers, $N$ (the number of
sequences) and $Q$ (the number of queries), respectively.  Each of the $Q$
subsequent lines contains a query in the format defined above.

{{{heading(Constraints)}}}

- $1 \le N, Q \le 10^5$

- $0 \le x \le 10^9$

- $0 \le y \le 10^9$

- It is guaranteed that query type $2$ will never query an empty sequence or
  index.


{{{heading(Output Format)}}}

For each type $2$ query, print the updated value of $lastAnswer$ on a new line.

{{{heading(Sample Input)}}}

#+begin_example
1 0 5
1 1 7
1 0 3
2 1 0
2 1 1
#+end_example

{{{heading(Sample Output)}}}

#+begin_example
7
3
#+end_example

{{{heading(Example)}}}

{{{subheading(Initial Values:)}}}

$N = 2$

$lastAnswer = 0$

$S_0 = []$

$S_1 = []$

Query 0: =Append 5 to sequence= $( ( 0 \oplus 0) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5]$

$S_1 = []$

Query 1: =Append 7 to sequence=  $( ( 1 \oplus 0 ) \% 2 ) = 1$

$S_0 = [5]$

$S_1 = [7]$

Query 2: =Append 3 to sequence= $( ( 0 \oplus 0 ) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5, 3]$

$S_1 = [7]$

Query 3: =Assign the value at index 0 of sequence$ $( ( 1 \oplus 0 ) \% 2 ) =
0$ to $lastAnswer$, and print $lastAnswer$.

$lastAnswer = 3$

$S_0 = [5,3]$

$S_1 = [7]$

$3$

* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Export Settings                                                  :noexport:
#+options: H:4
** Texinfo Export Settings
#+texinfo_filename:hackerrank.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Coding
#+texinfo_dir_title:HackerRank Coding Problems
#+texinfo_dir_desc:HackerRank coding problems
#+texinfo_printed_title:HackerRank Coding Problems

** HTML Export Settings
#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:t tex:t H:6
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.2.4)
#+latex_header:

* Macro Definitions                                                :noexport:
#+macro:heading @@texinfo:@heading @@@@html:<h4>@@$1@@html:</h4>@@
#+macro:subheading @@texinfo:@subheading @@@@html:<h5>@@$1@@html:</h5>@@
#+macro:dfn @@texinfo:@dfn{@@@@html:<b>@@$1@@texinfo:}@@@@html:</b>@@
#+macro:var @@texinfo:@var{@@$1@@texinfo:}@@
* Local Variables                                                  :noexport:
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
