# -*- mode:org; fill-column:79; -*-

#+title:HackerRank Coding Problems
#+subtitle:{{{date}}} {{{version}}}
#+date:2019-07-28 09:38
#+macro:version Version 0.11.24

* Introduction
- https://www.hackerrank.com/dashboard

** Tree of Installed Directories and Files
#+name:show-tree
#+begin_src sh :results output :exports results
tree -I '*.org|*.info|*.texi*|*.pdf|*.tex|figs'
#+end_src

#+name:tangle-all
#+begin_src emacs-lisp :results output :exports results
(org-babel-tangle-file "HackerRank.org")
#+end_src

* Node
Programs coded in JavaScript run in the Node.js environment.  The following
code entails the boilerplate for processing command-line arguments using Node's
built-in Streams and Process, in particular ~ReadStream~, ~WriteStream~,
~process.stdin~, and ~process.env~.
** Node Command-Line Processing
The first set of code processes command-line arguments.  The second code
fragment sets up a ~WriteStream~ for writing the result to a file.

#+begin_src js :noweb yes :exports none
<<node-process-command-line-arguments>>
#+end_src

*** Process
:PROPERTIES:
:header-args: :noweb-ref node-process-command-line-arguments
:END:

First are the Node dependencies:

- ~FileSystem~

- ~Process Stdin~ --- the default input encoding is to a buffer; setting the
  encoding to =utf-8= means that the input encoding will be a ~String~.

#+name:node-dependencies
#+begin_src js -n
const fs = require('fs');
process.stdin.setEncoding('utf-8');

#+end_src

- ~inputString~ will become an array holding each line of the input arguments
  as strings.

- ~currentLine~ is a simple counter will be used by the function ~readLine()~
  to produce one line of input after another upon request.

#+name:node-declarations
#+begin_src js +n
let inputString = '';
let currentLine = 0;

#+end_src

This code reads all of the command-line arguments into the variable
~inputString~; upon finishing reading all of the input, the command-line
arguments are broken into an array at newlines, but left in ~inputString~.
During the process, all trailing spaces are removed.

At the conclusion of breaking the arguments into an array, the program's
~main()~ function is called.

#+name:node-process-stdin
#+begin_src js +n
process.stdin.on('readable', () => {
    let chunk;

    while ((chunk = process.stdin.read()) != null)
        inputString += chunk;
});

process.stdin.on('end', () => {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(s => s.replace(/\s*$/, ''));

    main();
});

#+end_src

The function ~readLine()~ is called by the ~main()~ function when it wants
another line of input.

#+name:node-readLine
#+begin_src js +n
function readLine () {
    return inputString[currentLine++];
}

#+end_src

*** Write Stream
This little line of code sets up a ~WriteStream~ at a file established by the
~process.env.OUTPUT_PATH~ environment variable.  The ~main()~ function will
write the result into this file and then close the stream.  The environment
variable must be created prior to running the program or an exception will be
thrown when ~main()~ is entered.

#+name:node-main-write-stream-ws
#+begin_src js
const ws = fs.createWriteStream(process.env.OUTPUT_PATH);
#+end_src

* Data Structures
** Arrays
*** Arrays
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 94.01%
:score:    10
:END:
**** Arrays Problem Definition
An array is a type of data structure that stores elements of the same type in a
contiguous block of memory.  In an array, =A=, of size =N=, each memory
location has some unique index, {{{var(i)}}} (where 0 \le i \le N), that can be
referenced as =A[i]= (you may also see it written as A_i).

Given an array, =A= , of =N= integers, print each element in reverse order as a
single line of space-separated integers.

{{{heading(Input Format)}}}

- The first line contains an integer, =N= (the number of integers in =A=);
- The second line contains =N= space-separated integers describing =A=.


{{{subheading(Sample Input 1)}}}

#+begin_example
4
1 4 3 2
#+end_example


{{{heading(Constraints)}}}

- 1 \le N \le 10^3
- 1 \le A_i \le 10^4, where A_i is the {{{var(i)}}}^th integer in =A=.


{{{heading(Output Format)}}}

Print all =N= integers in =A= in reverse order as a single line of
space-separated integers.

{{{subheading(Sample Output 1)}}}

: 2 3 4 1

**** Arrays Node Process Code
#+name:arrays-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/arrays.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Arrays Main Function
#+name:arrays-main
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/arrays.js :mkdirp yes

function main () {
    <<node-main-write-stream-ws>>

    const arrCount = parseInt(readLine(), 10);
    console.log(`N = ${arrCount}`);

    const arr = readLine().split(' ')
          .map(e => parseInt(e, 10));
    console.log(`A = ${arr}`);

    const result = reverseArray(arr);

    ws.write(result.join(' ') + '\n');

    ws.end();
}
#+end_src

**** Arrays Solution Code
#+name:arrays-reverseArray
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/arrays.js
function reverseArray (a) {
    return a.reverse();
}
#+end_src

**** Arrays Test Code
#+name:arrays-test
#+header: :shebang "#! /usr/bin/env bash"
#+header: :dir data-structures/arrays/node :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/arrays.test.sh
export OUTPUT_PATH=results_arrays
echo Input:
echo \
'4
1 4 3 2' | node arrays.js

echo
echo Results:
cat results_arrays;
#+end_src

*** 2D Array
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 91.19%
:score:    15
:END:
**** Array 2D Problem Definition
Given a 6 \times 6 =2D Array=, ~arr~

#+begin_src sh
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
#+end_src

#+cindex:hourglass, dfn
We define an {{{dfn(hourglass)}}} in =A= to be /a subset of values with indices
falling in this pattern in ~arr~'s graphical representation/:

#+begin_src sh
a b c
  d
e f g
#+end_src

#+cindex:hourglass sum, dfn
There are 16 hourglasses in ~arr~, and an {{{dfn(hourglass sum)}}} is /the sum
of an hourglass' values/.  Calculate the hourglass sum for every hourglass in
~arr~, then print the maximum hourglass sum.

For example, given the =2D array=:
#+begin_src sh
-9 -9 -9  1 1 1
 0 -9  0  4 3 2
-9 -9 -9  1 2 3
 0  0  8  6 6 0
 0  0  0 -2 0 0
 0  0  1  2 4 0
#+end_src
we calculate the following hourglass values:

#+begin_src sh
-63, -34, -9, 12, 
-10, 0, 28, 23, 
-27, -11, -2, 10, 
9, 17, 25, 18
#+end_src

Our highest hourglass value is 16 from the hourglass:

#+begin_src sh
0 4 3
  1
8 6 6
#+end_src

{{{heading(Function Description)}}}

Complete the function ~hourglassSum~ in the editor below.  It should return an
integer, the maximum hourglass sum in the array.

~hourglassSum~ has the following parameter(s):

#+attr_texinfo: :options hourglassSum arr
#+begin_defun
{{{var(arr)}}} is an array of integers 6 \times 6 in size (i.e., a =2D Array=).
This function calculates the largest hourglass sum in the =2D Array=, returning
its value.
#+end_defun

{{{heading(Input Format)}}}

Each of the 6 lines of inputs ~arr[i]~ contains 6 space-separated integers
~arr[i][j]~.

{{{subheading(Sample Input)}}}

#+begin_example
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
#+end_example

{{{heading(Constraints)}}}

- \minus9 \le arr[i][j] \le 9

- 0 \le i, j \le 5

{{{heading(Output Format)}}}

Print the largest (maximum) hourglass sum found in ~arr~.

{{{subheading(Sample Output)}}}

: 19

{{{heading(Explanation)}}}

~arr~ contains the following hourglasses:

#+caption:Description of hourglasses
#+name:hourglasses
[[file:figs/hourglasssum.png]]

The hourglass with the maximum sum (19) is:

#+begin_example
2 4 4
  2
1 2 4
#+end_example

**** Array 2D Node CL Processing
#+name:array2d-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/array2d.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Array2D Hourglass Sum Main Function
#+name:array2d-main
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/array2d.js :mkdirp yes
const ROWS = 6,
COLUMNS = 6;

function main () {
    <<node-main-write-stream-ws>>

    let arr = Array(ROWS);
    for (let i = 0; i < ROWS; i++) {
        arr[i] = readLine()
            .split(' ')
            .map(s => parseInt(s, 10));
        console.log(`Row: ${arr[i]}`);
    }

    let result = hourglassSum(arr);

    ws.write(result + '\n');

    ws.end();
}
#+end_src

**** Array2D Hourglass Sum Solution Code
This is the solution to the problem.  All of the other code simply supports
it.  The ~hourglassSum()~ function receives a reference to a 2D array of equal
rows and columns.  The problem defines its size as a 6 \times 6 2D array, set
by the two constants =ROWS= and =COLUMNS=.

The solution iterates over the center of each hourglass and counts up the sum
of the elements of the hourglass, calculating whether a new maximum value has
been achieved, then returns the maximum value at the conclusion of checking all
hourglasses.

#+name:array2d-hourglassSum-function
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/array2d.js :mkdirp yes
function hourglassSum (arr) {
    let max, sum;
    for (let row = 1; row  < ROWS - 1; row++) {
        for (let col = 1; col < COLUMNS - 1; col++) {
            console.log(`row=${row} col=${col}`);
            sum = (
                arr[row-1][col-1] +
                arr[row-1][col]   +
                arr[row-1][col+1] +
                arr[row][col]     +
                arr[row+1][col-1] +
                arr[row+1][col]   +
                arr[row+1][col+1]
            );
            if (typeof max === 'undefined' || sum > max) {
                max = sum;
            }
            console.log(`sum=${sum} max=${max}`);
        }
    }
    return max;
}
#+end_src

**** Hourglass Sum Test
#+name:array2d-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/arrays/node :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/array2d.test.sh
export OUTPUT_PATH=result_array2d
echo Input:
echo \
'1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0' | node array2d.js

echo
echo Results:
cat result_array2d
#+end_src

*** Dynamic Array
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 83.20%
:score:    15
:END:
**** Dynamic Array Problem Definition
- Create a list, $seqList$, of $N$ empty sequences, where each sequence is
  indexed from $0$ to $N - 1$.  The elements within each of the $N$ sequences
  also use $0$ --indexing.

- Create an integer, $lastAnswer$, and initialize it to $0$.

- The $2$ types of queries that can be performed on your list of sequences
  ($seqList$) are described below:

  1. Query: $1 \times y$

     1. Find the sequence, $seq$, at index \( ( (x \oplus lastAnswer) % N ) \)
        in $seqList$.

     2. Append integer $y$ to sequence $seq$.

  2. Query: $2 \times y$

     1. Find the sequence, $seq$, at index $( (x \oplus lastAnswer) % N)$ in
        $seqList$.

     2. Find the value of element $y % size$ in $seq$ (where $size$ is the size
        of $seq$) and assign it to $lastAnswer$.

     3. Print the new value of $lastAnswer$ on a new line.


{{{heading(Task)}}}

Given $N$, $Q$, and $Q$ queries, execute each query.

*Note*: $\oplus$ is the bitwise XOR operation, which corresponds to the =^=
operator in most languages.  Learn more about it on [[https://en.wikipedia.org/wiki/Exclusive_or][Wikipedia]].

{{{heading(Input Format)}}}

The first line contains two space-separated integers, $N$ (the number of
sequences) and $Q$ (the number of queries), respectively.  Each of the $Q$
subsequent lines contains a query in the format defined above.

{{{heading(Constraints)}}}

- $1 \le N, Q \le 10^5$

- $0 \le x \le 10^9$

- $0 \le y \le 10^9$

- It is guaranteed that query type $2$ will never query an empty sequence or
  index.


{{{heading(Output Format)}}}

For each type $2$ query, print the updated value of $lastAnswer$ on a new line.

{{{heading(Sample Input)}}}

#+begin_example
1 0 5
1 1 7
1 0 3
2 1 0
2 1 1
#+end_example

{{{heading(Sample Output)}}}

#+begin_example
7
3
#+end_example

{{{heading(Example)}}}

{{{subheading(Initial Values:)}}}

$N = 2$

$lastAnswer = 0$

$S_0 = []$

$S_1 = []$

Query 0: =Append 5 to sequence= $( ( 0 \oplus 0) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5]$

$S_1 = []$

Query 1: =Append 7 to sequence=  $( ( 1 \oplus 0 ) \% 2 ) = 1$

$S_0 = [5]$

$S_1 = [7]$

Query 2: =Append 3 to sequence= $( ( 0 \oplus 0 ) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5, 3]$

$S_1 = [7]$

Query 3: =Assign the value at index 0 of sequence$ $( ( 1 \oplus 0 ) \% 2 ) =
0$ to $lastAnswer$, and print $lastAnswer$.

$lastAnswer = 3$

$S_0 = [5,3]$

$S_1 = [7]$

$3$

**** Dynamic Array Node Process
#+name:dynamic-array-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/dynamic.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Dynamic Array Main Function
#+name:dynamic-array-main-function
#+begin_src js +n :tangle data-structures/arrays/node/dynamic.js
function main() {
    // const ws = fs.createWriteStream(process.env.OUTPUT_PATH);
    const ws = process.stdout;

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);
    console.log(`N = ${n}`);

    const q = parseInt(firstMultipleInput[1], 10);
    console.log(`Q = ${q}`);

    let queries = Array(q);

    for (let i = 0; i < q; i++) {
        queries[i] = readLine().replace(/\s+$/g, '').split(' ').map(queriesTemp => parseInt(queriesTemp, 10));
        console.log(`Query: ${queries[i]}`);
    }

    console.log('\nResults:');
    const result = dynamicArray(n, queries);

    ws.write(result.join('\n') + '\n');

    ws.end();
}
#+end_src

**** Dynamic Array Solution Code
#+name:dynamic-array-solution
#+begin_src js +n :tangle data-structures/arrays/node/dynamic.js
/*
 ,* Complete the 'dynamicArray' function below.
 ,*
 ,* The function is expected to return an INTEGER_ARRAY.
 ,* The function accepts following parameters:
 ,*  1. INTEGER n
 ,*  2. 2D_INTEGER_ARRAY queries
 ,*/

function dynamicArray(n, queries) {

    let seqList = Array(n);
    let lastAnswer = 0;
    let result = []; // INTEGER_ARRAY TO RETURN

    queries.forEach(query => {
        const queryType = query[0];
        const x = query[1], y = query[2];
        const seq = ((x ^ lastAnswer) % n);

        switch (queryType) {
            case 1:
              if (typeof seqList[seq] == 'undefined') seqList[seq] = Array();
              seqList[seq].push(y);
            break;

            case 2:
              const seq2 = y % seqList[seq].length;
              lastAnswer = seqList[seq][seq2];
              result.push(lastAnswer);
            break;
        }
    });
    return result;
}
#+end_src

**** Dynamic Array Test
#+name:dynamic-array-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/arrays/node :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/dynamic.test.js
echo Input:
echo \
'2 5
1 0 5
1 1 7
1 0 3
2 1 0
2 1 1' | node dynamic.js
#+end_src

#+RESULTS: dynamic-array-test
#+begin_example
Input:
N = 2
Q = 5
Query: 1,0,5
Query: 1,1,7
Query: 1,0,3
Query: 2,1,0
Query: 2,1,1

Results:
7
3
#+end_example

*** Left Rotation
:PROPERTIES:
:level:    easy
:max-score: 20
:success-rate: 87.28%
:score:    20
:END:
Given an array and a number, ~d~, perform ~d~ left rotations on the array.

**** Left Rotation Problem Statement
A left rotation operation on an array of size ~n~ shifts each of the array's
elements ~1~ unit to the left.  For example, if ~2~ left rotations are
performed on array ~[1,2,3,4,5]~, then the array would become ~[3,4,5,1,2]~.

Given an array of ~n~ integers and a number, ~d~, perform ~d~ left rotations on
the array.  Then print the updated array as a single line of space-separated
integers.

{{{heading(Input Format)}}}

The first line contains two space-separated integers denoting the respective
values of ~n~ (the number of integers) and ~d~ (the number of left rotations
you must perform).

The second line contains ~n~ space-separated integers describing the respective
elements of the array's initial state.

{{{subheading(Sample Input)}}}

#+begin_example
5 4
1 2 3 4 5
#+end_example

{{{subheading(Constraints)}}}

- $1 \le n \le 10^5$
- $1 \le d \le n$
- $1 \le a_i \le 10^6$

{{{heading(Output Format)}}}

Print a single line of ~n~ space-separated integers denoting the final state of
the array after performing ~d~ left rotations.

{{{subheading(Sample Output)}}}

#+begin_example
5 1 2 3 4
#+end_example

{{{heading(Explanation)}}}

When we perform ~d = 4~ left rotations, the array undergoes the following
sequence of changes:

- ~[1, 2, 3, 4, 5]~
- ~[2, 3, 4, 5, 1]~
- ~[3, 4, 5, 1, 2]~
- ~[4, 5, 1, 2, 3]~
- ~[5, 1, 2, 3, 4]~

Thus, we print the array's final state as a single line of space-separated
values, which is ~5 1 2 3 4~.

**** Left Rotation Node CL Processing
#+name:left-rotation-command-line-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/left_rotation.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Left Rotation Main Function
#+name:left-rotation-main-function
#+begin_src js +n :tangle data-structures/arrays/node/left_rotation.js
function main() {
    const nd = readLine().split(' ');

    const n = parseInt(nd[0], 10);
    console.log(`N = ${n}`);

    const d = parseInt(nd[1], 10);
    console.log(`D = ${d}`);

    const a = readLine().split(' ').map(aTemp => parseInt(aTemp, 10));
    console.log(`A = ${a}`);

    const result = left_rotation(a, n, d);

    console.log('\nResults:');
    console.log(result.join(' '));
}
#+end_src

**** Left Rotation Solution
#+name:left-rotation-solution
#+begin_src js +n :tangle data-structures/arrays/node/left_rotation.js
function left_rotation (arr, n, d) {
    return arr.map( (e,i,a) => {
        return a[(i + d) % n];
    });
}
#+end_src

**** Left Rotation Test
#+name:left-rotation-test
#+header: :shebang "#!/usr/bin/env bash" :dir data-structures/arrays/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/left_rotation.test.sh
echo Input:
echo \
'5 4
1 2 3 4 5' | node left_rotation.js
#+end_src

*** Sparse Arrays
:PROPERTIES:
:max-score: 25
:level:    medium
:success-rate: 96.75%
:score:    25
:END:
Determine the number of times a string has previously appeared.
**** Sparse Arrays Problem Statement
There is a collection of input strings and a collection of query strings.  For
each query string, determine how many times it occurs in the list of input
strings.

For example, given input ~strings = ['ab', 'ab', 'abc']~ and ~queries = ['ab',
'abc', 'bc']~, we find 2 instances of ='ab'=, 1 of ='abc'= and 0 of ='bc'=.
For each query, we add an element to our return array, ~results = [2, 1, 0]~.

{{{heading(Functional Description)}}}

Complete the function ~matchingStrings~ in the editor below.  The function must
return an array of integers representing the frequency of occurrence of each
query string in strings.

#+attr_texinfo: :options matchingStrings strings queries
#+begin_defun
{{{var(strings)}}} is an array of strings to search.  {{{var(queries)}}} is an
array of query strings.
#+end_defun

{{{heading(Input Format)}}}

The first line contains an integer ~n~, the size of ~strings~.

Each of the next ~n~ lines contains a string ~strings[i]~.

The next line contains ~q~, the size of ~queries~.

Each of the next ~q~ lines contains a string ~queries[i]~.

{{{subheading(Sample Input)}}}

: strings = ['aba', 'baba', 'aba', 'xzxb']

: queries = ['aba', xzxb', 'ab']

#+begin_example
4
aba
baba
aba
xzxb
3
aba
xzxb
ab
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le q \le 1000

- 1 \le ~|strings[i]|~, ~|queries[i]|~ \le 20


{{{heading(Output Format)}}}

Return an integer array of the results of all queries in order.

{{{subheading(Sample Output)}}}

: results = [2, 1, 0]

#+begin_example
2
1
0
#+end_example

{{{heading(Explanation)}}}

Here, "aba" occurs twice, in the first and third string.  The string "xzxb"
occurs once in the fourth string, and "ab" does not occur at all.

{{{heading(Sample Input 2)}}}

: strings = ['def', 'de', 'fgh']

: queries = ['de', 'lmn', 'fgh']

#+begin_example
3
def
de
fgh
3
de
lmn
fgh
#+end_example

{{{heading(Sample Output)}}}

: results = [1, 0, 1]

#+begin_example
1
0
1
#+end_example

{{{heading(Sample Input 3)}}}

#+begin_example
13
abcde
sdaklfj
asdjf
na
basdn
sdaklfj
asdjf
na
asdjf
na
basdn
sdaklfj
asdjf
5
abcde
sdaklfj
asdjf
na
basdn
#+end_example

{{{heading(Sample Output)}}}

#+begin_example
1
3
4
3
2
#+end_example

**** Sparse Arrays Node CL Processing
#+name:sparse-arrays-node-cl-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/sparse_arrays.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Sparse Arrays ~main~ Function
#+name:sparse-arrays-main
#+begin_src js +n :tangle data-structures/arrays/node/sparse_arrays.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const stringsCount = parseInt(readLine(), 10);
    console.log(`n = ${stringsCount}`);

    let strings = [];

    for (let i = 0; i < stringsCount; i++) {
        const stringsItem = readLine();
        strings.push(stringsItem);
    }
    console.log(`strings: ${strings}`);

    const queriesCount = parseInt(readLine(), 10);
    console.log(`q = ${queriesCount}`);

    let queries = [];

    for (let i = 0; i < queriesCount; i++) {
        const queriesItem = readLine();
        queries.push(queriesItem);
    }
    console.log(`queries: ${queries}`);

    let res = matchingStrings(strings, queries);

    ws.write(res.join("\n") + "\n");

    ws.end();
}
#+end_src

**** Sparse Arrays ~matchingStrings~ Function
#+name:sparse-arrays-matchingStrings-function
#+begin_src js +n :tangle data-structures/arrays/node/sparse_arrays.js
function matchingStrings(strings, queries) {
    strings.sort();
    let results = [];
    queries.forEach((e,i) => {
        let count = 0;
        let j;
        if ((j = strings.findIndex(e1 => e1 === e)) >= 0) {
            count++;
            while (strings[++j] === e) count++;
        }
        results[i] = count;
    });
    return results;
}
#+end_src

**** Sparse Arrays Test Code
#+name:sparse-arrays-test-code
#+header: :shebang "#!/usr/bin/env bash"
#+header: :results output :exports both :dir data-structures/arrays/node
#+begin_src sh -n :tangle data-structures/arrays/node/sparse_arrays.test.sh
export OUTPUT_PATH=results_sparse_arrays
echo Input 1
echo \
'4
aba
baba
aba
xzxb
3
aba
xzxb
ab' | node sparse_arrays.js
echo Results 1
cat results_sparse_arrays
echo

echo Input 2
echo '3
def
de
fgh
3
de
lmn
fgh' | node sparse_arrays.js
echo Results 2
cat results_sparse_arrays
echo

echo Input 3
echo '13
abcde
sdaklfj
asdjf
na
basdn
sdaklfj
asdjf
na
asdjf
na
basdn
sdaklfj
asdjf
5
abcde
sdaklfj
asdjf
na
basdn' | node sparse_arrays.js
echo Results 3
cat results_sparse_arrays
echo
#+end_src

*** Array Manipulation
:PROPERTIES:
:max-score: 60
:level:    hard
:success-rate: 51.96%
:score:    60
:END:
Perform ~m~ operations on an array and print the maximum of the values.
**** Array Manipulation Problem Statement
Starting with a 1-indexed array of zeros and a list of operations, for each
operation add a value to each of the array elements between two given indices,
inclusive.  Once all operations have been performed, return the maximum value
in your array.

For example, the length of your array of zeros ~n = 10~.  Your list of queries
is as follows:

#+begin_example
a b k
1 5 3
4 8 7
6 9 1
#+end_example

Add the values of ~k~ between the indices ~a~  and ~b~ inclusive:

#+begin_example
index->	 1 2 3  4  5 6 7 8 9 10
	[0,0,0, 0, 0,0,0,0,0, 0]
	[3,3,3, 3, 3,0,0,0,0, 0]
	[3,3,3,10,10,7,7,7,0, 0]
	[3,3,3,10,10,8,8,8,1, 0]
#+end_example

The largest value is ~10~ after all operations are performed.

{{{heading(Function Description)}}}

The first line contains two space-separated integers ~n~ and ~m~, the size of
the array and the number of operations.

Each of the next ~m~ lines contains three space-separated integers ~a~, ~b~ and
~k~, the left index, right index and summand.

{{{subheading(Sample Input)}}}

#+begin_example
5 3
1 2 100
2 5 100
3 4 100
#+end_example

{{{heading(Constraints)}}}

- 3 \le ~n~ \le 10^7

- 1 \le ~m~ \le 2 * 10^5

- 1 \le ~a~ \le ~b~ \le ~n~

- 0 \le ~k~ \le 10^9


{{{heading(Output Format)}}}

Return the integer maximum value in the finished array.

{{{subheading(Sample Output)}}}

: 200

{{{heading(Explanation)}}}

- After the first update list will be ~100 100 0 0 0~.

- After the second update list will be ~100 200 100 100 100~.

- After the third update list will be ~100 200 200 200 100~.

- The required answer will be ~200~.

**** Array Manipulation Node CL Processing
#+name:array-manipulation-node-process-cl
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/array_manipulation.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Array Manipulation Main Function
#+name:array-manipulation-main
#+begin_src js +n :tangle data-structures/arrays/node/array_manipulation.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const nm = readLine().split(' ');

    const n = parseInt(nm[0], 10);
    console.log(`n = ${n}`);

    const m = parseInt(nm[1], 10);
    console.log(`m = ${m}`);

    let queries = Array(m);

    for (let i = 0; i < m; i++) {
        queries[i] = readLine().split(' ').map(queriesTemp => parseInt(queriesTemp, 10));
        console.log(`query: ${queries[i]}`);
    }

    let result = arrayManipulation(n, queries);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

**** Array Manipulation Solution Code
#+name:array-manipulation-solution
#+begin_src js +n :tangle data-structures/arrays/node/array_manipulation.js
// Complete the arrayManipulation function below.
function arrayManipulation(n, queries) {
    const arr = Array(n);
    arr.fill(0);

    for (let [a, b, k] of queries) {
        arr[a-1] += k;
        if (b < n) arr[b] -= k;
    }

    let max = 0, x = 0;
    for (let i = 0; i < n; i++) {
        x += arr[i];
        if (x > max) max = x;
    }

    return max;
}
#+end_src

**** Array Manipulation Test Code
#+name:array-manipulation-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/arrays/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/array_manipulation.sh
export OUTPUT_PATH=results_array_manipulation
echo Input:
echo '5 3
1 2 100
2 5 100
3 4 100' | node array_manipulation.js
echo
echo Results:
cat results_array_manipulation
#+end_src

** Linked Lists
*** Print the Elements of a Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:score:    5
:success-rate: 96.67%
:END:
#+cindex:linked list
#+cindex:head node
If you're new to linked lists, this is a great exercise for learning about
them.  Given a pointer to the head node of a linked list, print its elements in
order, one element per line.  If the head pointer is null (indicating the list
is empty), don’t print anything.

{{{heading(Input Format)}}}

The first line of input contains ~n~, the number of elements in the linked
list.  The next ~n~ lines contain one element each, which are the elements of
the linked list.

*Note*: Do not read any input from stdin/console.  Complete the
~printLinkedList~ function in the editor below.

{{{subheading(Sample Input)}}}

#+begin_example
1
16
13
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the linked
  list.


{{{heading(Output Format)}}}

Print the integer data for each element of the linked list to stdout/console
(e.g.: using ~printf~, ~cout~, etc.).  There should be one element per line.

{{{subheading(Sample Output)}}}

#+begin_example
16
13
#+end_example

{{{heading(Explanation)}}}

There are two elements in the linked list.  They are represented as ~16 -> 13
-> NULL~.  So, the ~printLinkedList~ function should print 16 and 13 each in a
new line.

**** Print Linked List Node CL Processing
#+name:print-linked-list-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/print_linked_list.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Print Linked List Main Function
#+name:print-linked-list-main
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
function main() {
    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data = ${llistItem}`);
        llist.insertNode(llistItem);
    }

    printLinkedList(llist.head);
}
#+end_src

**** Print Linked List Node Classes
***** Singly Linked List Node Class
#+name:singly-linked-list-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};
#+end_src

***** Singly Linked List Class
#+name: singly-linked-list-class
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};
#+end_src

**** Print Linked List Solution
#+name:print-linked-list-printLinkedList
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
// Complete the printLinkedList function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function printLinkedList(head) {
    if (!head) return;
    const data = head.data;
    const next = head.next;
    console.log(data);
    printLinkedList(next);
}
#+end_src

**** Print Linked List Test Data
#+name:print-linked-list-test
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/print_linked_list.test.sh
echo '2
16
13' | node print_linked_list.js
#+end_src

#+RESULTS: print-linked-list-test
: n = 2
: data = 16
: data = 13
: 16
: 13

*** Insert a Node at the Tail of Linked List
:PROPERTIES:
:max-score: 5
:level:    easy
:success-rate: 95.28%
:score:    5
:END:
#+cindex:linked list
#+cindex:head node
#+cindex:tail node
You are given the pointer to the head node of a linked list and an integer to
add to the list.  Create a new node with the given integer.  Insert this node
at the tail of the linked list and return the head node of the linked list
formed after inserting this new node.  The given head pointer may be null,
meaning that the initial list is empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode~
~insertAtTail(SinglyLinkedListNode head, int data)~ method.  It takes two
arguments: the head of the linked list and the integer to insert at tail.  You
should not read any input from the stdin/console.

The input is handled by code editor and is as follows:

- The first line contains an integer ~n~, denoting the elements of the linked
  list.

- The next ~n~ lines contain an integer each, denoting the elements that need
  to be inserted at tail.


{{{subheading(Sample Input)}}}

#+begin_example
5
141
302
164
530
474
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000


{{{heading(Output Format)}}}

Insert the new node at the tail and just return the head of the updated linked
list.  Do not print anything to stdout/console.  The output is handled by code
in the editor and is as follows:

- Print the elements of the linked list from head to tail, each in a new line.


{{{subheading(Sample Output)}}}

#+begin_example
141
302
164
530
474
#+end_example

{{{heading(Explanation)}}}

- First the linked list is NULL. After inserting 141, the list is 141 -> NULL.

- After inserting 302, the list is 141 -> 302 -> NULL.

- After inserting 164, the list is 141 -> 302 -> 164 -> NULL.

- After inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL.

- After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL,
  which is the final list.

**** Insert Node at Tail Node CL Processing
#+name:insert-node-at-tail-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_node_llist.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Insert Node at Tail Main
#+name:insert-node-at-tail-main
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data: ${llistItem}`);
    	const llist_head = insertNodeAtTail(llist.head, llistItem);
      	llist.head = llist_head;
    }

    printSinglyLinkedList(llist.head, '\n', ws);
    ws.write('\n');

    ws.end();
}
#+end_src

**** Insert Node at Tail Node Classes
***** Singly Linked List Node Class
#+name:insert-node-singly-linked-list-node
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Singly Linked List Class
#+name:insert-node-singly-linked-list
#+header: :noweb yes
#+begin_src +n :tangle data-structures/linked_lists/node/insert_node_llist.js
<<singly-linked-list-class>>
#+end_src

***** Print Singly Linked List
#+name:print-singly-linked-list
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
function printSinglyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}
#+end_src

**** Insert Node at Tail insertNodeAtTail
#+name:insert-node-at-tail-insertNodeAtTail
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
// Complete the insertNodeAtTail function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function insertNodeAtTail(head, data) {
    const newNode = new SinglyLinkedListNode(data);
    if (head === null) {
        head = newNode;
    } else {
        let oldHead = head;
        while (oldHead.next !== null) {
            oldHead = oldHead.next
        }
        oldHead.next = newNode;
    }
    return head;
}
#+end_src

**** Insert Node at Tail Test
#+name:insert-node-at-tail-test
#+header: :results output :exports results
#+header: :dir data-structures/linked_lists/node
#+begin_src sh -n :tangle data-structures/linked_lists/node/insert_node_llist.test.sh
export OUTPUT_PATH=results_insert_node_llist
echo '5
141
302
164
530
474' | node insert_node_llist.js
echo
echo Results
cat results_insert_node_llist
#+end_src

*** Insert a Node at the Head of Linked List
:PROPERTIES:
:max-score: 5
:level:    easy
:success-rate: 98.50%
:END:
You’re given the pointer to the head node of a linked list and an integer to
add to the list.  Create a new node with the given integer, insert this node at
the head of the linked list and return the new head node.  The head pointer
given may be null meaning that the initial list is empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode Insert(SinglyLinkedListNode
head, int data)~ method which takes two arguments --- the head of the linked
list and the integer to insert.  You should NOT read any input from
stdin/console.

The input is handled by code in the editor and is as follows:

- The first line contains an integer ~n~, denoting the number of elements to be
  inserted at the head of the list.

- The next ~n~ lines contain an integer each, denoting the elements to be
  inserted.


{{{subheading(Sample Input)}}}

#+begin_example
5
383
484
392
975
321
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000


{{{heading(Output Format)}}}

Insert the new node at the head and return the head of the updated linked list.
Do NOT print anything to stdout/console.  The output is handled by the code in
the editor and it is as follows:

- Print the elements of linked list from head to tail, each in a new line.


{{{subheading(Sample Output)}}}

#+begin_example
321
975
392
484
383
#+end_example

{{{heading(Explanation)}}}

- Intially the list in NULL. After inserting 383, the list is 383 -> NULL.
- After inserting 484, the list is 484 -> 383 -> NULL.
- After inserting 392, the list is 392 -> 484 -> 383 -> NULL.
- After inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.
- After inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.

**** Insert Node at Head of Linked List Node CL Processing
#+name:insert-node-head-linked-list-node-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<node-process-command-line-arguments>>
#+end_src

**** Insert Node at Head of Linked List Classes
***** Insert Node at Head of Singly Linked List Node Class
#+name:insert-node-head-llist-node-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Insert Node at Head of Singly Linked List Class
#+name:insert-node-head-llist-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<singly-linked-list-class>>
#+end_src

***** Insert Node at Head of Singly Linked List Print Function
#+name:insert-node-head-llist-print
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<print-singly-linked-list>>
#+end_src

**** Insert Node at Head of Linked List Main Function
#+name:insert-node-head-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data: ${llistItem}`);
    	const llist_head = insertNodeAtHead(llist.head, llistItem);
      	llist.head = llist_head;
    }

    printSinglyLinkedList(llist.head, '\n', ws);
    ws.write('\n');

    ws.end();
}
#+end_src

**** insertNodeAtHead Function
#+name:insert-node-head-llist-insertNodeAtHead
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
// Complete the insertNodeAtHead function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function insertNodeAtHead(head, data) {
    const newNode = new SinglyLinkedListNode(data);
    newNode.next = head;
    head = newNode;

    return head;
}
#+end_src

**** Insert Node at Head of Linked List Test
#+name:insert-node-head-llist-insert_head_llist.test.sj
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/insert_head_llist.test.sh
export OUTPUT_PATH=results_insert_head_llist
echo Input:
echo '5
383
484
392
975
321' | node insert_head_llist.js
echo
echo Results:
cat results_insert_head_llist
#+end_src
*** Delete a Node
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 97.22%
:END:
You’re given the pointer to the head node of a linked list and the position of
a node to delete.  Delete the node at the given position and return the head
node.  A position of 0 indicates head, a position of 1 indicates one node away
from the head and so on.  The list may become empty after you delete the node.

{{{heading(Input Format)}}}

You have to complete the ~deleteNode(SinglyLinkedListNode* llist, int
position)~ method which takes two arguments --- the head of the linked list and
the position of the node to delete.  You should NOT read any input from
stdin/console.  ~position~ will always be at least 0 and less than the number
of the elements in the list.

- The first line of input contains an integer ~n~, denoting the number of
  elements in the linked list.

- The next ~n~ lines contain an integer each in a new line, denoting the
  elements of the linked list in the order.

- The last line contains an integer ~position~ denoting the position of the
  node that has to be deleted form the linked list.


{{{subheading(Sample Input)}}}

#+begin_example
8
20
6
2
19
7
4
15
9
3
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 1000

- 1 \le ~list_i~ \le 1000, where ~list_i~ is the ~i^th~ element of the linked
  list


{{{heading(Output Format)}}}

Delete the node at the given position and return the head of the updated linked
list.  Do NOT print anything to stdout/console.  The code in the editor will
print the updated linked list in a single line separated by spaces.

{{{subheading(Sample Output)}}}

: 20 6 2 7 4 15 9

{{{heading(Explanation)}}}

The given linked list is =20->6->2->19->7->4->15->9=.  We have to delete the
node at ~position~ 3, which is 19.  After deleting that node, the updated
linked list is: =20->6->2->7->4->15->9=.

**** Delete a Node from a Linked List Node CL Processing
#+name:delete-node-llist-node-cl
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<node-process-command-line-arguments>>
#+end_src

**** Delete a Node from a Linked List Classes
***** Delete a Node Node Class
#+name:delete-node-llist-node-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Delete a Node Class
#+name:delete-node-llist-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<singly-linked-list-class>>
#+end_src

***** Delete a Node Print a Linked List Function
#+name:delete-node-llist-print
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<print-singly-linked-list>>
#+end_src

**** Delete a Node from a Linked List Main Function
#+name:delete-node-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        llist.insertNode(llistItem);
        console.log(`data: ${llistItem}`);
    }

    const position = parseInt(readLine(), 10);
    console.log(`position = ${position}`);

    let llist1 = deleteNode(llist.head, position);

    printSinglyLinkedList(llist1, " ", ws)
    ws.write("\n");

    ws.end();
}
#+end_src

**** Delete a Node from a Linked List deleteNode Function
#+name:delete-node-llist-deleteNode
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
// Complete the deleteNode function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function deleteNode(head, position) {
    let prior = null;
    let current = head;
    while (position--) {
        prior = current;
        current = current.next;
    }
    if (prior === null) head = current.next;
    else prior.next = current.next;
    return head;
}
#+end_src

**** Delete a Node from a Linked List Test
#+name:delete-node_llist_test
#+header: :shebang "#!/usr/bin/env bash" :results output :exports results
#+header: :dir data-structures/linked_lists/node
#+begin_src sh -n :tangle data-structures/linked_lists/node/delete_node_llist.test.sh
export OUTPUT_PATH=results_delete_llist
echo Input:
echo \
'8
20
6
2
19
7
4
15
9
3' | node delete_node_llist.js

echo
echo Results:
cat results_delete_llist
#+end_src

*** Print in Reverse
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 97.89%
  :score:    5
  :END:
You are given the pointer to the head node of a linked list and you need to
print all its elements in reverse order from tail to head, one element per
line.  The head pointer may be null meaning that the list is empty---in that
case, do not print anything!

{{{heading(Input Format)}}}

You have to complete the ~void reversePrint(SinglyLinkedListNode* head)~ method
which takes one argument---the head of the linked list.  You should NOT read any
input from stdin/console.

The first line of input contains ~t~, the number of test cases.

The input of each test case is as follows:

- The first line contains an integer ~n~, denoting the number of elements in
  the list.

- The next ~n~ lines contain one element each, denoting the elements of the
  linked list in the order.


{{{subheading(Sample Input)}}}

#+begin_example
3
5
16
12
4
2
5
3
7
3
9
5
5
1
18
3
13
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element in the list.


{{{heading(Output Format)}}}

Complete the ~reversePrint~ function in the editor below and print the elements
of the linked list in the reverse order, each in a new line.

{{{subheading(Sample Output)}}}

#+begin_example
5
2
4
12
16
9
3
7
13
3
18
1
5
#+end_example

{{{heading(Explanation)}}}

There are three test cases.

The first linked list has 5 elements: =16 -> 12 -> 4 -> 2 -> 5=.  Printing this
in reverse order will produce: =5 -> 2 -> 4 -> 12 -> 16=.

The second linked list has 3 elements: =7 -> 3 -> 9=.  Printing this in reverse
order will produce: =9 -> 3 -> 7=.

The third linked list has 5 elements: =5 -> 1 -> 18 -> 3 -> 13=.  Printing this
in reverse order will produce: =13 -> 3 -> 18 -> 1 -> 5=.

**** Print in Reverse Node CL Processing
#+name:print-in-reverse-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Print in Reverse Node Classes
***** Print in Reverse Linked List Node Class
#+name:print-in-reverse-linked-list-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};
#+end_src

***** Print in Reverse Linked List Class
#+name:print-in-reverse-linked-list-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};
#+end_src

***** Print in Reverse Linked List Print
#+name:print-in-reverse-linked-list-print
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
function printSinglyLinkedList(node, sep) {
    while (node != null) {
        process.stdout.write(String(node.data));

        node = node.next;

        if (node != null) {
            process.stdout.write(sep);
        }
    }
}
#+end_src

**** Print in Reverse Linked List Main Function
#+name:print-in-reverse-linked-list-main
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
function main() {
    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}\n`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`test: ${testsItr}`);
        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();
        console.log(`new list:`);

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data: ${llistItem}`);
            llist.insertNode(llistItem);
        }

        reversePrint(llist.head);
        console.log('');
    }
}
#+end_src

**** Print in Reverse Linked List reversePrint Function
#+name:print-in-reverse-linked-list-reversePrint
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
// Complete the reversePrint function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function reversePrint(head) {
    if (head === null) return;
    reversePrint(head.next);
    console.log(head.data);
}
#+end_src

**** Print in Reverse Linked List Test
#+name:print-in-reverse-linked-list-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.test.sh
echo \
'3
5
16
12
4
2
5
3
7
3
9
5
5
1
18
3
13' | node reverseSinglyLinkedList.js
#+end_src

*** Reverse a Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 98.04%
:END:
You’re given the pointer to the head node of a linked list.  Change the next
pointers of the nodes so that their order is reversed.  The head pointer given
may be null meaning that the initial list is empty.

**** Reverse a Linked List Problem Statement
{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode reverse(SinglyLinkedListNode
head)~ method which takes one argument---the head of the linked list.  You
should NOT read any input from stdin/console.

The input is handled by the code in the editor and the format is as follows:

- The first line contains an integer ~t~, denoting the number of test cases.

- Each test case is of the following format:

  - The first line contains an integer ~n~, denoting the number of elements in
    the linked list.

  - The next ~n~ lines contain an integer each, denoting the elements of the
    linked list.


{{{subheading(Sample Input)}}}

#+begin_example
1
5
1
2
3
4
5
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~t~ \le 10

- 1 \le ~n~ \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element in the list


{{{heading(Output Format)}}}

Change the next pointers of the nodes so that their order is reversed; return
the head of the reversed linked list.  Do NOT print anything to stdout/console.

The output is handled by the code in the editor.  The output format is as
follows:

- For each test case, print in a new line the elements of the linked list after
  reversing it, separated by spaces.


{{{subheading(Sample Output)}}}

: 5 4 3 2 1 

{{{heading(Explanation)}}}

The initial linked list is: =1 -> 2 -> 3 -> 4 -> 5 -> NULL=

The reversed linked list is: =5 -> 4 -> 3 -> 2 -> 1 -> NULL=

**** Reverse a Linked List Node CL Processing
#+name:reverse-llist-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/reverse_llist.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Reverse a Linked List Classes
***** Reverse a Linked List Node Class
#+name:reverse-llist-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};
#+end_src

***** Reverse a Linked List Class
#+name:reverse-llist-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};
#+end_src

***** Reverse a Linked List Print
#+name:reverse-llist-print
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
function printSinglyLinkedList(node, sep, ws) {
    while (node != null) {
        console.log(`write node: ${node.data}`);
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}
#+end_src

**** Reverse a Linked List Main Function
#+name:reverse-lliist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}\n`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`test: ${testsItr}`);
        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data: ${llistItem}`);
            llist.insertNode(llistItem);
        }

        let llist1 = reverse(llist.head);

        printSinglyLinkedList(llist1, " ", ws)
        ws.write("\n");
    }

    ws.end();
}
#+end_src

#+RESULTS: reverse-lliist-main

**** Reverse a Linked List reverse Function
#+name:reverse-llisi-reverse
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
// Complete the reverse function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function reverse(head) {

    function rev(node) {
        if (node === null)
            return;
        rev(node.next);

        if (node.next === null)
            head = node;
        else {
            node.next.next = node;
            node.next = null;
        }
    }

    rev(head);
    return head;
}
#+end_src

**** Reverse a Linked List Test Function
#+name:reverse-llist-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/reverse_llist.test.sh
export OUTPUT_PATH=reverse_llist_results
echo \
'1
5
1
2
3
4
5' | node reverse_llist.js
echo
echo 'Results:'
cat reverse_llist_results
#+end_src

#+RESULTS: reverse-llist-test
#+begin_example
tests: 1

test: 0
n: 5
data: 1
data: 2
data: 3
data: 4
data: 5
write node: 5
write node: 4
write node: 3
write node: 2
write node: 1

Results:
5 4 3 2 1
#+end_example

*** Compare Two Linked Lists
:PROPERTIES:
:level:    easy
:max-score: 5
:rate:     98.86%
:score:    5
:END:
**** Problem Statement
You’re given the pointer to the head nodes of two linked lists.  Compare the
data in the nodes of the linked lists to check if they are equal.  The lists
are equal only if they have the same number of nodes and corresponding nodes
contain the same data.  Either head pointer given may be null meaning that the
corresponding list is empty.

{{{heading(Input Format)}}}

You have to complete the ~int CompareLists(Node* headA, Node* headB)~ method
which takes two arguments---the heads of the two linked lists to compare.  You
should NOT read any input from stdin/console.

The input is handled by the code in the editor and the format is as follows:

- The first line contains ~t~, the number of test cases.  The format for each
  test case is as follows:

- The first line contains an integer ~n~, denoting the number of elements in
  the first linked list.

- The next ~n~ lines contain an integer each, denoting the elements of the
  first linked list.

- The next line contains an integer ~m~, denoting the number of elements in the
  second linked list.

- The next ~m~ lines contain an integer each, denoting the elements of the
  second linked list.


{{{subheading(Sample Input)}}}

#+begin_example
2
2
1
2
1
1
2
1
2
2
1
2
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element in the list


{{{heading(Output Format)}}}

Compare the two linked lists and return 1 if the lists are equal.  Otherwise,
return 0.  Do NOT print anything to stdout/console.  The output is handled by
the code in the editor and it is as follows:

- For each test case, in a new line, print 1 if the two lists are equal, else
  print 0.


{{{heading(Sample Output)}}}

#+begin_example
0
1
#+end_example

{{{heading(Explanation)}}}

In the first case, linked lists are: =1 -> 2 -> NULL= and =1 -> NULL=

In the second case, linked lists are: =1 -> 2 -> NULL= and =1 -> 2 -> NULL=

**** Compare Linked Lists Node CL Processing
#+name:compare-llists-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/compareLLists.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Compare Linked Lists Classes
***** Compare Linked Lists Node Class
#+name:compare-llist-node-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
<<singly-linked-list-node-class>>
#+end_src

***** Compare Linked Lists Class
#+name:compare-llist-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
<<singly-linked-list-class>>
#+end_src

***** Compare Linked Lists Print Function
#+name:compare-llist-print-function
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
<<print-singly-linked-list>>
#+end_src

**** Compare Linked Lists Main Function
#+name:compare-llist-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
  function main() {
      const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

      const tests = parseInt(readLine(), 10);
      console.log(`number of tests t = ${tests}`);

      for (let testsItr = 0; testsItr < tests; testsItr++) {
          console.log(`\ntest: ${testsItr}`);

          const llist1Count = parseInt(readLine(), 10);
          console.log(`n: ${llist1Count}`);

          let llist1 = new SinglyLinkedList();

          for (let i = 0; i < llist1Count; i++) {
              const llist1Item = parseInt(readLine(), 10);
              console.log(`data: ${llist1Item}`);
              llist1.insertNode(llist1Item);
          }

          const llist2Count = parseInt(readLine(), 10);
          console.log(`m: ${llist2Count}`);

          let llist2 = new SinglyLinkedList();

          for (let i = 0; i < llist2Count; i++) {
              const llist2Item = parseInt(readLine(), 10);
              console.log(`data: ${llist2Item}`);
              llist2.insertNode(llist2Item);
          }

          let result = CompareLists(llist1.head, llist2.head);
          console.log(`result: ${result}`);

          ws.write((result ? 1 : 0) + "\n");
      }

      ws.end();
  }
#+end_src

**** Compare Linked Lists compareLists Function
#+name:compare-llists-compareLists-function
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
  // Complete the CompareLists function below.

  /*
   ,* For your reference:
   ,*
   ,* SinglyLinkedListNode {
   ,*     int data;
   ,*     SinglyLinkedListNode next;
   ,* }
   ,*
   ,*/
  function CompareLists(llist1, llist2) {
      if (llist1 === null && llist2 === null)
          return 1;
      if (llist1 == null || llist2 == null)
          return 0;
      if (llist1.data !== llist2.data)
          return 0;
      return CompareLists(llist1.next, llist2.next);
  }
#+end_src

**** Compare Linked Lists Tests
#+name:compare-llists-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/compareLLists.tests.sh
export OUTPUT_PATH=compare-llists-results
echo Inputs
echo \
'2
2
1
2
1
1
2
1
2
2
1
2' | node compareLLists.js
echo
echo Results
cat compare-llists-results
#+end_src

#+RESULTS: compare-llists-tests
#+begin_example
Inputs
number of tests t = 2

test: 0
n: 2
data: 1
data: 2
m: 1
data: 1
result: 0

test: 1
n: 2
data: 1
data: 2
m: 2
data: 1
data: 2
result: 1

Results
0
1
#+end_example
*** Insert a Node at a Specific Position in a Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 96.38%
:score:    5
:cummulative-points: 185
:current-rank: 412511
:END:
**** Insert Node at a Set Position in a LList Problem Statement
You’re given the pointer to the head node of a linked list, an integer to add
to the list and the position at which the integer must be inserted.  Create a
new node with the given integer, insert this node at the desired position and
return the head node.

A position of 0 indicates head; a position of 1 indicates one node away from
the head, and so on.  The head pointer given may be null, meaning that the
initial list is empty.

As an example, if your list starts as =1->2->3= and you want to insert a node
at position 2 with data = 4, your new list should be =1->2-4->3=.

{{{heading(Function Description)}}}

Complete the function ~insertNodeAtPosition~ in the editor below.  It must
return a reference to the head node of your finished list.

~insertNodeAtPosition~ has the following parameters:

- =head=: a ~SinglyLinkedListNode~ pointer to the head of the list

- =data=: an integer value to insert as data in your new node

- =position=: an integer position to insert the new node, zero based indexing


{{{heading(Input Format)}}}

The first line contains an integer ~n~, the number of elements in the linked
list.

Each of the next ~n~ lines contains an integer ~SinglyLinkedListNode[i].data~.

The last line contains an integer ~posittion~.

{{{subheading(Sample Input)}}}

#+begin_example
3
16
13
7
1
2
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the linked list

- 0 \le position \le n


{{{heading(Output Format)}}}

Return a reference to the list head.  Locked code prints the list for you.

{{{subheading(Sample Output)}}}

: 16 13 1 7

{{{heading(Explanation)}}}

The initial linked list is =16 13 7=.  We have to insert 1 at the position 2
which currently has 7 in it.  The updated linked list will be =16 13 1 7=.

**** Insert Node at a Set Position in a LList Node CL Processing and Classes
#+name:insert-node-set-pos-llist-node-cl-classes
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_node_pos_llist.js :mkdirp yes
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Insert Node at a Set Position in a LList Main Function
#+name:insert-node-set-pos-llist-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_pos_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n: ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data: ${llistItem}`);
        llist.insertNode(llistItem);
    }

    const data = parseInt(readLine(), 10);
    console.log(`data to insert: ${data}`);

    const position = parseInt(readLine(), 10);
    console.log(`at position: ${position}`);

    let llist_head = insertNodeAtPosition(llist.head, data, position);

    printSinglyLinkedList(llist_head, " ", ws)
    ws.write("\n");

    ws.end();
}
#+end_src

**** Insert Node at a Set Position in a LList insertNodeAtPosition Function
#+name:insert-node-set-pos-llist-insertNodeAtPosition-function
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_pos_llist.js
// Complete the insertNodeAtPosition function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function insertNodeAtPosition(head, data, position) {
    const node = new SinglyLinkedListNode(data);
    if (head === null) {
        head = node;
        return head;
    }

    let prior = null;
    let current = head;
    let pos = 0;
    while (current !== null && pos++ < position) {
        prior = current
        current = current.next;
    }
    node.next = current;
    prior.next = node;
    return head;
}
#+end_src

**** Insert Node at a Set Position in a LList Test
#+name:insert-node-set-pos-llist-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/insert_node_pos_llist.test.sh
export OUTPUT_PATH=insert-node-pos-results
echo Inputs:
echo \
'3
16
13
7
1
2' | node insert_node_pos_llist.js
echo
echo Results
cat insert-node-pos-results
#+end_src

#+RESULTS: insert-node-set-pos-llist-test
#+begin_example
Inputs:
n: 3
data: 16
data: 13
data: 7
data to insert: 1
at position: 2

Results
16 13 1 7
#+end_example

*** Merge Two Sorted Linked Lists
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 95.40%
:score:    5
:current-rank: 404494
:END:
Given the heads of two sorted linked lists, change their links to get a single
sorted linked list.

**** Merge Two Sorted Linked Lists Problem Statement
You’re given the pointer to the head nodes of two sorted linked lists.  The
data in both lists will be sorted in ascending order.  Change the next pointers
to obtain a single, merged linked list which also has data in ascending order.
Either head pointer given may be null meaning that the corresponding list is
empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode MergeLists(SinglyLinkedListNode
headA, SinglyLinkedListNode headB)~ method which takes two arguments---the
heads of the two sorted linked lists to merge.  You should NOT read any input
from stdin/console.

The input is handled by the code in the editor and the format is as follows:

- The first line contains an integer ~t~, denoting the number of test cases.


The format for each test case is as follows:

- The first line contains an integer ~n~, denoting the length of the first
  linked list.

- The next ~n~ lines contain an integer each, denoting the elements of the
  linked list.

- The next line contains an integer ~m~, denoting the length of the second
  linked list.

- The next ~m~ lines contain an integer each, denoting the elements of the
  second linked list.


{{{subheading(Sample Input)}}}

#+begin_example
1
3
1
2
3
2
3
4
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the list.


{{{heading(Output Format)}}}

Change the next pointer of individual nodes so that nodes from both lists are
merged into a single list.  Then return the head of this merged list.  Do NOT
print anything to stdout/console.

The output is handled by the editor and the format is as follows:

- For each test case, print in a new line, the linked list after merging them
  separated by spaces.


{{{subheading(Sample Output)}}}

: 1 2 3 3 4

{{{heading(Explanation)}}}

The first linked list is: =1 -> 2 -> 3 -> NULL=

The second linked list is: =3 -> 4 -> NULL=

Hence, the merged linked list is: =1 -> 2 -> 3 -> 3 -> 4 -> NULL=

**** Merge Two Sorted Linked Lists Node CL Processing and Classes
#+name:merge-two-sorted-llists-node-cl-processing-and-classes
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/merge_2_sorted_llists.js :mkdirp yes
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Merge Two Sorted Linked Lists Main Function
#+name:merge-two-sorted-llists-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/merge_2_sorted_llists.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`t: ${tests}`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        const llist1Count = parseInt(readLine(), 10);
        console.log(`n: ${llist1Count}`);

        let llist1 = new SinglyLinkedList();

        for (let i = 0; i < llist1Count; i++) {
            const llist1Item = parseInt(readLine(), 10);
            console.log(`data: ${llist1Item}`);
            llist1.insertNode(llist1Item);
        }

      	const llist2Count = parseInt(readLine(), 10);
        console.log(`m: ${llist2Count}`);

        let llist2 = new SinglyLinkedList();

        for (let i = 0; i < llist2Count; i++) {
            const llist2Item = parseInt(readLine(), 10);
            console.log(`data: ${llist2Item}`);
            llist2.insertNode(llist2Item);
        }

        let llist3 = mergeLists(llist1.head, llist2.head);

        printSinglyLinkedList(llist3, " ", ws)
        ws.write("\n");
    }

    ws.end();
}
#+end_src

**** Merge Two Sorted Linked Lists mergeLists Function
#+name:merge-two-sorted-llists-mergeLists-function
#+begin_src js +n :tangle data-structures/linked_lists/node/merge_2_sorted_llists.js
// Complete the mergeLists function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function mergeLists(head1, head2) {
    if (head1 === null || head2 === null) {
        return (head1 === null) ? head2 : head1;
    }

    let current1 = head1,
        current2 = head2,
        head,
        prior;

    if (head1.data <= head2.data)
        head = head1,
        current1 = current1.next;
    else
        head = head2,
        current2 = current2.next;
    prior = head;

    while (current1 !== null && current2 !== null) {
        if (current1.data <= current2.data)
            prior.next = current1,
            current1 = current1.next;
        else
            prior.next = current2,
            current2 = current2.next;

        prior = prior.next;
    }

    prior.next = (current1 === null) ? current2 : current1;

    return head;
}
#+end_src

**** Merge Two Sorted Linked Lists Test
#+name:merge-two-sorted-llists-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/merge_2_sorted_llists.test.sh
export OUTPUT_PATH=merge-2-sorted-llists-results
echo Inputs:
echo \
'1
3
1
2
3
2
3
4' | node merge_2_sorted_llists.js
echo
echo Results
cat merge-2-sorted-llists-results
#+end_src

#+RESULTS: merge-two-sorted-llists-test
#+begin_example
Inputs:
t: 1
n: 3
data: 1
data: 2
data: 3
m: 2
data: 3
data: 4

Results
1 2 3 3 4
#+end_example

*** Get Node Value
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 98.81%
:score:    5
:current-rank: 397294
:current-score: 195
:END:
Given the head of a linked list, get the value of the node at a given position
when counting backwards from the tail.

**** Get Node Value Problem Statement
You’re given the pointer to the head node of a linked list and a specific
position.  Counting backwards from the tail node of the linked list, get the
value of the node at the given position.  A position of 0 corresponds to the
tail, 1 corresponds to the node before the tail and so on.

{{{heading(Input Format)}}}

You have to complete the ~int getNode(SinglyLinkedListNode* head, int
positionFromTail)~ method which takes two arguments---the head of the linked
list and the position of the node from the tail.  ~positionFromTail~ will be at
least 0 and less than the number of nodes in the list.  You should NOT read any
input from stdin/console.

The first line will contain an integer ~t~, the number of test cases.

Each test case has the following format:

- The first line contains an integer ~n~, the number of elements in the linked
  list.

- The next ~n~ lines contains, an element each denoting the element of the
  linked list.

- The last line contains an integer ~positionFromTail~ denoting the position
  from the tail, whose value needs to be found out and returned.


{{{subheading(Sample Input)}}}

#+begin_example
2
1
1
0
3
3
2
1
2
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the linked list

- 0 \le positionFromTail \lt n


{{{heading(Output Format)}}}

Find the node at the given position counting backwards from the tail.  Then
return the data contained in this node.  Do NOT print anything to
stdout/console.  The code in the editor handles output.

For each test case, print the value of the node, each in a new line.

{{{subheading(Sample Output)}}}

#+begin_example
1
3
#+end_example

{{{heading(Explanation)}}}

In first case, there is one element in linked list with value 1.  Hence, last
element is 1.

In second case, there are 3 elements with values 3, 2 and 1 (=3 -> 2 -> 1=).
Hence, element with position of 2 from tail is 3.

**** Get Node Value Node CL Processing and Classes
#+name:get-node-value-node-cl-processing-and-classes
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/get_node_value.js :mkdirp yes
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Get Node Value Main Function
#+name:get-node-value-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/get_node_value.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`\ntest: ${testsItr}`);
        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data: ${llistItem}`);
            llist.insertNode(llistItem);
        }

        const position = parseInt(readLine(), 10);
        console.log(`find data at position: ${position}`);

        let result = getNode(llist.head, position);

        ws.write(result + "\n");
    }

    ws.end();
}
#+end_src

**** Get Node Value getNode Function
#+name:get-node-value-getNode-function
#+begin_src js +n :tangle data-structures/linked_lists/node/get_node_value.js
  // Complete the getNode function below.

  /*
   ,* For your reference:
   ,*
   ,* SinglyLinkedListNode {
   ,*     int data;
   ,*     SinglyLinkedListNode next;
   ,* }
   ,*
   ,*/
  function getNode(head, positionFromTail) {
      let n = 0,
          pos = 0,
          current = head,
          node = head;

      while (current.next !== null) {
          if (n - pos === positionFromTail)
              node = node.next, pos++;
          current = current.next, n++;
      }
      return node.data;
  }
#+end_src

**** Get node Value Tests
#+name:get-node-value-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/get_node_value.test.sh
export OUTPUT_PATH=get-node-value-results
echo Inputs:
echo \
'2
1
1
0
3
3
2
1
2' | node get_node_value.js
echo
echo Results:
cat get-node-value-results
#+end_src

#+RESULTS: get-node-value-tests
: Inputs:
: tests: 2
: 
: test: 0
: n: 1
: data: 1
: find data at position: 0
: 
: Results:

*** Delete Duplicate Value Nodes from a Sorted Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 98.36%
:score:    5
:current-rank: 390303
:END:
Given a linked list whose nodes have data in ascending order, delete some nodes
so that no value occurs more than once.

**** Delete Duplicate Value Nodes Problem Statement
You're given the pointer to the head node of a sorted linked list, where the
data in the nodes is in ascending order.  Delete as few nodes as possible so
that the list does not contain any value more than once.  The given head
pointer may be null indicating that the list is empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode*
removeDuplicates(SinglyLinkedListNode* head)~ method which takes one
argument---the head of the sorted linked list.  You should NOT read any input
from stdin/console.

The input is handled by the code in the editor and the format is as follows:

- The first line contains an integer ~t~, denoting the number of test
  cases.  The format for each test case is as follows:

- The first line contains an integer ~n~, denoting the number of elements in
  the linked list.

- The next ~n~ lines contain an integer each, denoting the elements of the
  linked list.


{{{subheading(Sample Input)}}}

#+begin_example
1
5
1
2
2
3
4
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le list_i \le 1000


{{{heading(Output Format)}}}

Delete as few nodes as possible to ensure that no two nodes have the same data.
Adjust the next pointers to ensure that the remaining nodes form a single
sorted linked list.  Then return the head of the sorted updated linked list.
Do NOT print anything to stdout/console.  The output is handled by the code in
the editor and the format is as follows:

- For each test case, print in a new line, the data of the linked list after
  removing the duplicates separated by space.


{{{subheading(Sample Output)}}}

: 1 2 3 4

{{{heading(Explanation)}}}

The initial linked list is: =1 -> 2 -> 2 -> 3 -> 4 -> NULL=

The final linked list is: =1 -> 2 -> 3 -> 4 -> NULL=

**** Delete Duplicate Value Nodes Node CL Processing and Classes
#+name:delete-duplicate-value-nodes-node-cl-processing-and-classes
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/delete_duplicate_value_nodes.js
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Delete Duplicate Value Nodes Main Funtion
#+name:delete-duplicate-value-nodes-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_duplicate_value_nodes.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine(), 10);
    console.log(`tests: ${t}`);

    for (let tItr = 0; tItr < t; tItr++) {
        console.log(`\ntest: ${tItr}`);
        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data: ${llistItem}`);
            llist.insertNode(llistItem);
        }

        let llist1 = removeDuplicates(llist.head);

        printSinglyLinkedList(llist1, " ", ws)
        ws.write("\n");
    }

    ws.end();
}
#+end_src

**** Delete Duplicate Value Nodes removeDuplicates Function
#+name:delete-duplicate-value-nodes-removeDuplicates-function
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_duplicate_value_nodes.js
// Complete the removeDuplicates function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function removeDuplicates(head) {
    if (head === null)
        return null;

    let current = head.next,
        prior = head,
        data = head.data;

    while (current !== null) {
        if (current.data === data)
            prior.next = current.next;
        else
            data = current.data,
            prior = current;

        current = current.next;
    }
    return head;
}

#+end_src

**** Delete Duplicate Value Nodes Tests
#+name:delete-duplicate-value-nodes-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/delete_duplicate_value_nodes.test.sh
export OUTPUT_PATH=delete-duplicate-results
echo Inputs:
echo \
'2
5
1
2
2
3
4
3
1
1
1' | node delete_duplicate_value_nodes.js
echo
echo Results:
cat delete-duplicate-results
#+end_src

*** Cycle Detection
:PROPERTIES:
:level:    medium
:max-score: 5
:success-rate: 98.80%
:END:
Given a pointer to the head of a linked list, determine whether the linked list
loops back on itself.
**** Cycle Detection Problem Statement
A linked list is said to contain a cycle if any node is visited more than once
while traversing the list.

Complete the function provided for you in your editor.  It has one parameter: a
pointer to a Node object named =head= that points to the head of a linked list.
Your function must return a boolean denoting whether or not there is a cycle in
the list.  If there is a cycle, return =true=; otherwise, return =false=.

*Note*: If the list is empty, =head= will be =null=.

{{{heading(Input Format)}}}

Our hidden code checker passes the appropriate argument to your function. You
are not responsible for reading any input from stdin.

{{{subheading(Sample Input)}}}

: 1 -> Null

: 1 => 2 -> 3 |
:      ^<-----v

{{{heading(Constraints)}}}

- 0 \le list size \le 1000

{{{heading(Output Format)}}}

If the list contains a cycle, your function must return =true=.  If the list
does not contain a cycle, it must return =false=.  The binary integer
corresponding to the boolean value returned by your function is printed to
stdout by our hidden code checker.

{{{subheading(Sample Output)}}}

: 0
: 1

{{{heading(Explanation)}}}

1. The first list has no cycle, so we return =false= and the hidden code
   checker prints 0 to stdout.

2. The second list has a cycle, so we return =true= and the hidden code checker
   prints 1 to stdout.

**** Cycle Detection Node CL Process and Classes
#+name:cycle-detection-node-cl-processing-and-classes
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/cycleDetection.js
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Cycle Detection Main Function
#+name:cycle-detection-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/cycleDetection.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`\ntest: ${testsItr}`);

        const index = parseInt(readLine(), 10);
        console.log(`index: ${index}`);

        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data ${i}: ${llistItem}`);
            llist.insertNode(llistItem);
        }

      	let extra = new SinglyLinkedListNode(-1);
        let temp = llist.head;

        console.log(`starting indexing loop; index is ${index}; temp is ${temp.data}`);
        for (let i = 0; i < llistCount; i++) {
            console.log(`i: ${i}`);
            if (i == index) {
            	extra = temp;
                console.log(`extra is now temp: ${extra.data}`);
            }

            if (i != llistCount-1) {
            	temp = temp.next;
                console.log(`temp is now ${temp.data}`);
            }
        }

        temp.next = extra;
        console.log(`temp.next.data is ${temp.next.data}`);

        let result = hasCycle(llist.head);

        ws.write((result ? 1 : 0) + "\n");
    }

    ws.end();
}
#+end_src

**** Cycle Detection hasCycle Function
#+name:cycle-detection-hasCycle-Function
#+begin_src js +n :tangle data-structures/linked_lists/node/cycleDetection.js
// Complete the hasCycle function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function hasCycle(head) {
    if (head === null)
        return false;

    let fast = head,
        slow = head;

    while (fast.next !== null && fast.next.next !== null) {
        fast = fast.next.next,
        slow = slow.next;

        if (slow == fast)
            return true;
    }
    return false;
}
#+end_src

**** Cycle Detection Test
#+name:cycle-detection-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/cycleDetection.test.sh
export OUTPUT_PATH=cycle-detection-results
echo Inputs
echo \
'2
3
3
0
1
2
1
3
3
4
5' | node cycleDetection.js
echo
echo Results
cat cycle-detection-results
#+end_src
*** Find Merge Point of Two Lists
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 94.82%
:score:    5
:current-rank: 381747
:current-score: 205
:END:
**** Find Merge Point Problem Statement
Given pointers to the head nodes of linked lists that merge together at some
point, find the Node where the two lists merge.  It is guaranteed that the two
head Nodes will be different, and neither will be =NULL=.

In the diagram below, the two lists converge at Node ~x~:

#+begin_example
[List #1] a--->b--->c
                     \
                      x--->y--->z--->NULL
                     /
     [List #2] p--->q
#+end_example

Complete the ~int findMergeNode(SinglyLinkedListNode* head1,
SinglyLinkedListNode* head2)~ method so that it finds and returns the data
value of the Node where the two lists merge.

{{{heading(Input Format)}}}

Do not read any input from stdin/console.

The ~findMergeNode(SinglyLinkedListNode,SinglyLinkedListNode)~ method has two
parameters, ~head1~ and ~head2~, which are the non-null head Nodes of two
separate linked lists that are guaranteed to converge.

{{{subheading(Sample Input)}}}

The diagrams below are graphical representations of the lists that input Nodes
~headA~ and ~headB~ are connected to.  Recall that this is a method-only
challenge; the method only has initial visibility to those Nodes and must
explore the rest of the Nodes using some algorithm of your own design.

Test Case 0:

#+begin_example
 1
  \
   2--->3--->NULL
  /
 1
#+end_example

Test Case 1:

#+begin_example
1--->2
      \
       3--->Null
      /
     1
#+end_example

{{{heading(Constraints)}}}

- The lists will merge.

- ~head1~, ~head2! \ne =null=

- ~head1~ \ne ~head2~


{{{heading(Output Format)}}}

Do not write any output to stdout/console.

Each Node has a data field containing an integer.  Return the integer data for
the Node where the two lists merge.

{{{subheading(Sample Output)}}}

#+begin_example
2
3
#+end_example

{{{heading(Explanation)}}}

- Test Case 0: As demonstrated in the diagram above, the merge Node's data
  field contains the integer 2.

- Test Case 1: As demonstrated in the diagram above, the merge Node's data
  field contains the integer 3.

**** Find Merge Point Node CL Processing and Classes
#+name:find-merge-point-node-cl-processing-and-classes
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/find_merge_point.js
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Find Merge Point Main Function
#+name:find-merge-point-node-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/find_merge_point.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`\ntest # ${testsItr}`);
        const index = parseInt(readLine(), 10);
        console.log(`index: ${index}`);

        const llist1Count = parseInt(readLine(), 10);
        console.log(`n: ${llist1Count}`);

        let llist1 = new SinglyLinkedList();

        for (let i = 0; i < llist1Count; i++) {
            const llist1Item = parseInt(readLine(), 10);
            console.log(`data[${i}]: ${llist1Item}`);
            llist1.insertNode(llist1Item);
        }

      	const llist2Count = parseInt(readLine(), 10);
        console.log(`m: ${llist2Count}`);

        let llist2 = new SinglyLinkedList();

        for (let i = 0; i < llist2Count; i++) {
            const llist2Item = parseInt(readLine(), 10);
            console.log(`data[${i}]: ${llist2Item}`);
            llist2.insertNode(llist2Item);
        }

      	let ptr1 = llist1.head;
        let ptr2 = llist2.head;

        for (let i = 0; i < llist1Count; i++) {
          if (i < index) {
            ptr1 = ptr1.next;
          }
        }

        for (let i = 0; i < llist2Count; i++) {
          if (i != llist2Count-1) {
            ptr2 = ptr2.next;
          }
        }

        ptr2.next = ptr1;

        let result = findMergeNode(llist1.head, llist2.head);

        ws.write(result + "\n");
    }

    ws.end();
}
#+end_src

**** Find Merge Point findMergeNode Function
Treat this similarly to detecting a cycle: repeatedly cycle through the two
nodes until their =next= pointers point to the same node.

#+name:find-merge-point-findMergeNode-function
#+begin_src js +n :tangle data-structures/linked_lists/node/find_merge_point.js
/*
    Find merge point of two linked lists
    Note that the head may be 'null' for the empty list.
    Node is defined as
    var Node = function(data) {
        this.data = data;
        this.next = null;
    }
*/

// This is a "method-only" submission.
// You only need to complete this method.

function findMergeNode(headA, headB) {

    let nodeA = headA,
        nodeB = headB,
        nextA, nextB;

    while (true) {
        nextA = nodeA.next === null ? headA : nodeA.next;
        nextB = nodeB.next === null ? headB : nodeB.next;

        if (nextA == nextB)
            return nextA.data;

        nodeA = nextA,
        nodeB = nextB;
    }

}
#+end_src

**** Find Merge Point Tests
#+name:find-merge-point-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/find_merge_point.test.sh
export OUTPUT_PATH=find-merge-point-results
echo Inputs:
echo \
'3
1
3
1
2
3
1
1
2
3
1
2
3
1
1
6
9
1
2
3
4
5
6
7
8
9
6
11
12
13
14
15
16' | node find_merge_point.js
echo
echo Results:
cat find-merge-point-results
#+end_src
*** Inserting a Node Into a Sorted Doubly Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 93.17%
:score:    5
:current-rank: 374277
:current-score: 210
:END:
**** Insert Node Sorted Doubly LList Problem Statement
Given a reference to the head of a doubly-linked list and an integer, ~data~,
create a new ~DoublyLinkedListNode~ object having data value ~data~ and insert
it into a sorted linked list while maintaining the sort.

{{{heading(Function Description)}}}

Complete the ~sortedInsert~ function in the editor below.  It must return a
reference to the head of your modified ~DoublyLinkedList~.

~sortedInsert~ has two parameters:

1. ~head~: A reference to the head of a doubly-linked list of
   ~DoublyLinkedListNode~ objects.

2. ~data~: An integer denoting the value of the ~data~ field for the
   ~DoublyLinkedListNode~ you must insert into the list.


*Note*: Recall that an empty list (i.e., where ~head~ \eq =null=) and a list
with one element are sorted lists.

{{{heading(Input Format)}}}

The first line contains an integer ~t~, the number of test cases.

Each of the test case is in the following format:

- The first line contains an integer ~n~, the number of elements in the linked
  list.

- Each of the next ~n~ lines contains an integer, the data for each node of the
  linked list.

- The last line contains an integer ~data~ which needs to be inserted into the
  sorted doubly-linked list.


{{{subheading(Sample Input)}}}

#+begin_example
1
4
1
3
4
10
5
#+end_example


{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le data \le 1000


{{{heading(Output Format)}}}

*Do not print anything to stdout*.  Your method must return a reference to the
~head~ of the same list that was passed to it as a parameter.  The ouput is
handled by the code in the editor and is as follows:

For each test case, print the elements of the sorted doubly-linked list
separated by spaces on a new line.

{{{subheading(Sample Output)}}}

: 1 3 4 5 10

{{{heading(Explanation)}}}

The initial doubly linked list is: 1 \leftrightarrow 3 \leftrightarrow 4 \leftrightarrow 10 \rightarrow null.

The doubly linked list after insertion is: 1 \leftrightarrow 3 \leftrightarrow 4 \leftrightarrow 5 \leftrightarrow 10 \rightarrow null.

**** Insert Node Sorted Doubly LList Node CL Processing
#+name:insert-node-sorted-doubly-llist-node-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
<<node-process-command-line-arguments>>
#+end_src

**** Insert Node Sorted Doubly LList Classes
***** Sorted Doubly Linked List Node Class
#+name:doubly-llist-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
const DoublyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
        this.prev = null;
    }
};
#+end_src

***** Sorted Doubly Linked List Class
#+name:doubly-llist-class
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
const DoublyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        let node = new DoublyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
            node.prev = this.tail;
        }

        this.tail = node;
    }
};
#+end_src

***** Sorted Doubly Linked List Print Function
#+name:doubly-llist-print-function
#+begin_src +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
function printDoublyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}
#+end_src

**** Insert Node Sorted Doubly LList Main Function
#+name:insert-node-sorted-doubly-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
  function main() {
      const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

      const t = parseInt(readLine(), 10);
      console.log(`tests: ${t}`);

      for (let tItr = 0; tItr < t; tItr++) {
          const llistCount = parseInt(readLine(), 10);
          console.log(`n: ${llistCount}`);

          let llist = new DoublyLinkedList();

          for (let i = 0; i < llistCount; i++) {
              const llistItem = parseInt(readLine(), 10);
              console.log(`data[${i}]: ${llistItem}`);
              llist.insertNode(llistItem);
          }

          const data = parseInt(readLine(), 10);
          console.log(`data to insert: ${data}`);

          let llist1 = sortedInsert(llist.head, data);

          printDoublyLinkedList(llist1, " ", ws);
          ws.write("\n");
      }

      ws.end();
  }
#+end_src

**** Insert Node Sorted Doubly LList sortedInsert Function
#+name:insert-node-sorted-doubly-llist-sortedInsert
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
  // Complete the sortedInsert function below.

  /*
   ,* For your reference:
   ,*
   ,* DoublyLinkedListNode {
   ,*     int data;
   ,*     DoublyLinkedListNode next;
   ,*     DoublyLinkedListNode prev;
   ,* }
   ,*
   ,*/
  function sortedInsert(head, data) {
      const node = new DoublyLinkedListNode(data);

      if (head === null)
          return node;

      let current = head;

      while (current.data < data && current.next !== null) {
          current = current.next;
      }

      if (current.data < data) {
          current.next = node;
          node.prev = current;
          return head;
      }

      if (current.prev === null) {
          head = node;
          node.next = current;
          return head;
      }

      node.prev = current.prev;
      node.next = current;
      current.prev.next = node,
      current.prev = node;

      return head;;
  }
#+end_src

**** Insert Node Sorted Doubly LList Tests
#+name:insert-node-sorted-doubly-llist-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.tests.sh
  export OUTPUT_PATH=insert-sorted-doubly-llist-results
  echo Inputs:
  echo \
  '3
  4
  1
  3
  4
  10
  5
  4
  1
  3
  4
  10
  0
  4
  1
  3
  4
  10
  11' | node insert_sorted_doubly_llist.js
  echo
  echo Results:
  cat insert-sorted-doubly-llist-results
#+end_src
*** Reverse a Doubly Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 97.52%
:score:    5
:current-score: 215
:current-rank: 366882
:END:
**** Reverse a Double Linked List Problem Statement
You’re given the pointer to the head node of a doubly linked list.  Reverse the
order of the nodes in the list.  The head node might be NULL to indicate that
the list is empty.  Change the next and prev pointers of all the nodes so that
the direction of the list is reversed.  Return a reference to the head node of
the reversed list.

{{{heading(Function Description)}}}

Complete the reverse function in the editor below. It should return a reference
to the head of your reversed list.  ~reverse~ has the following parameter(s):

- ~head~: a reference to the head of a ~DoublyLinkedList~


{{{heading(Input Format)}}}

The first line contains an integer ~t~, the number of test cases.

Each test case is of the following format:

- The first line contains an integer ~n~, the number of elements in the linked
  list.

- The next ~n~ lines contain an integer each denoting an element of the linked
  list.


{{{subheading(Sample Input)}}}

#+begin_example
1
4
1
2
3
4
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le  10

- 0 \le n \le  1000

- 0 \le data \le 1000


{{{heading(Output Format)}}}

Return a reference to the head of your reversed list.  The provided code will
print the reverse array as a one line of space-separated integers for each test
case.

{{{subheading(Sample Output)}}}

: 4 3 2 1 

{{{heading(Explanation)}}}

The initial doubly linked list is: 1 \leftrightarrow 2 \leftrightarrow 3 \leftrightarrow 4 \rightarrow null

The reversed doubly linked list is: 4 \leftrightarrow 3 \leftrightarrow 2 \leftrightarrow 1 \rightarrow null

**** Reverse a Double Linked List Node CL Processing and Classes
#+name:reverse-double-llist-node-cl-processing_and_classes
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/reverse_double_llist.js
<<node-process-command-line-arguments>>
<<doubly-llist-node-class>>
<<doubly-llist-class>>
<<doubly-llist-print-function>>
#+end_src

**** Reverse a Double Linked List Main Function
#+name:reverse-double-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_double_llist.js
  function main() {
      const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

      const t = parseInt(readLine(), 10);
      console.log(`tests: ${t}`);

      for (let tItr = 0; tItr < t; tItr++) {
          console.log(`\ntest: ${tItr + 1}`);
          const llistCount = parseInt(readLine(), 10);
          console.log(`n: ${llistCount}`);

          let llist = new DoublyLinkedList();

          for (let i = 0; i < llistCount; i++) {
              const llistItem = parseInt(readLine(), 10);
              console.log(`data[${i}]: ${llistItem}`);
              llist.insertNode(llistItem);
          }

          let llist1 = reverse(llist.head);

          printDoublyLinkedList(llist1, " ", ws);
          ws.write("\n");
      }

      ws.end();
  }
#+end_src

**** Reverse a Double Linked List reverse Function
#+name:reverse-double-llist-reverse
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_double_llist.js
  // Complete the reverse function below.

  /*
   ,* For your reference:
   ,*
   ,* DoublyLinkedListNode {
   ,*     int data;
   ,*     DoublyLinkedListNode next;
   ,*     DoublyLinkedListNode prev;
   ,* }
   ,*
   ,*/
  function reverse(head) {
      let current = head,
          next = null,
          prev = null;

      while (current !== null) {
          next = current.next;
          prev = current;

          current.next = current.prev;
          current.prev = next;
          current = next;
      }
      return prev;
  }
#+end_src

**** Reverse a Double Linked List Tests
#+name:reverse-double-llist-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/reverse_double_llist.test.sh
  export OUTPUT_PATH=reverse-double-llist-results
  echo Inputs:
  echo \
  '4
  4
  1
  2
  3
  4
  1
  1
  2
  1
  2
  0' | node reverse_double_llist.js
  echo
  echo Results:
  cat reverse-double-llist-results
#+end_src
** Trees
*** Data Structures---Trees

#+cindex:node
#+cindex:child node
#+cindex:key, node data
#+cindex:satelite data
- Node :: An object containing a data property (or a /key/ and satelite data)
          and two or more node properties, which are links to other nodes,
          called child nodes, often labeled =left= and =right=.  Sometimes
          there will also be a link to a parent node.

#+cindex:tree
#+cindex:binary tree
#+cindex:parent node
- Tree :: A linked data structure consisting of a collection of linked /nodes/
          (objects), in which each node (a /parent/ node) has a /data/ property
          and two or more node properties, which are /references/ to other
          nodes (/child/ nodes).  In a tree, all nodes have one parent node and
          two or more chiild nodes, except for the first or top node, usually
          called the =root=, which has no parent node.  If a child is missing,
          the corresponding reference is =NIL=.  The root node has a =NIL=
          parent node link.

- Binary Search Tree :: A tree containing one data property and two node
     properties, which maintains the condition that all linked nodes to the
     left contain data that is less than or equal to the data in all parent
     nodes, and all linked nodes to the right contain data that is greater than
     or equal to all parent nodes.


{{{heading(Binary Search Tree Property)}}}

#+cindex:binary-search-tree property
#+begin_quote
Let {{{math(n)}}} be a node in a binary search tree.  If {{{math(y)}}} is a
node in the left subtree of {{{math(x)}}}, then {{{math(y.key \le x.key)}}}.  If
{{{math(y)}}} is a node in the right subtree of {{{math(x)}}}, then
{{{math(y.key \ge x.key)}}}.
#+end_quote

{{{heading(Tree Dynamic Set Operations)}}}

The search tree data structure supports many dynamic-set operations, such as:

- search
- minimum
- maximum
- predecessor
- successor
- insert
- delete


These basic operations take time proportional to the height the tree (rather
than the number of nodes in the tree).  For a complete binary tree with ~n~
nodes, such operations run in \Theta(\ln n) worst-case time.  However, if the tree
is a linear chain of ~n~ nodes, then the same operations take \Theta(n) worst-case
time.

The expected height of a randomly built binary search tree is \Omicron(\ln n), which
means that basic dynamic-set operations take \Theta(\lg n) time on average.

*** Data Structures---Trees---Python Node and Tree Classes

#+caption[Binary Tree Node]:A Binary Tree Node Class Implementation in Python
#+name:binary-tree-node-class-python
#+begin_src python -n
class Node:
    def __init__(self, info):
        self.info  = info
        self.left  = None
        self.right = None
        self.level = None

    def __str__(self):
        return str(self.info)
#+end_src

{{{heading(A Binary Search Tree)}}}

#+caption[Binary Tree Class]:A Binary Tree Class Implementation in Python
#+name:binary-tree-class-python
#+begin_src python +n
class BinarySearchTree:
    def __init__(self):
        self.root = None

    def create(self, val):
        if self.root == None:
            self.root = Node(val)
        else:
            current = self.root

            while True:
                if val < current.info:
                    if current.left:
                        current = current.left
                    else:
                        current.left = Node(val)
                        break
                elif val > current.info:
                    if current.right:
                        current = current.right
                    else:
                        current.right = Node(val)
                        break
                else:
                    break

#+end_src

*** Data Structures---Trees---Traversals
#+cindex:inorder tree walk, traversal
#+cindex:traversal, inorder
#+cindex:tree traversal, walk
#+cindex:walk, inorder tree
In a binary search tree traversal, or tree walk, one visits each node of a tree
in a certain order.

{{{heading(Tree Traversals)}}}

{{{subheading(Inorder Tree Traversal)}}}

The binary-search-tree property allows one to print out all the keys in a
binary search tree in sorted order by a simple recursive algorith called an
/inorder tree walk/, or /traversal/.  This algorithm is so named because it
prints the key of the root of a subtree between printing the values in its left
subtee and printing those in its right subtree.

{{{subheading(Preorder and Postorder Tree Traversals)}}}

#+cindex:preorder tree traversal, walk
#+cindex:postorder tree traversal, walk
A /preorder tree walk/ prints the root /before/ the values in either subtree,
and a /postorder tree walk/ prints the root after the values in its subtrees.

#+caption:Tree Traversals
#+name:figure-tree-traversals
[[file:figures/Tree-Traversals-75.png]]

- Preorder traversal ::
  - visit the root
  - visit the left subtree
  - visit the right subtree
  : 1 2 4 5 3 6 7

- Inorder traversal ::
  - visit the left subtree
  - visit the root
  - visit the right subtree
  : 4 2 5 1 6 3 7

- Postorder traversal ::
  - visit the right subtree
  - visit the left subtree
  - visit the root
  : 7 6 3 5 4 2 1

**** Trees---Traversals---Inorder
Use the following procedure to print all the elements in a binary search tree
=T=, by calling ~inorder-tree-walk(T)~.

#+attr_texinfo: :options BST-PY inorder_tree_walk (node)
#+begin_defmethod
Will walk a binary search tree rooted in {{{var(node)}}} by =inorder= means.
#+end_defmethod

#+caption:Inorder Traversal, in Python
#+name:inorder-tree-traversal-python
#+begin_src python -n
  def inorder_tree_walk(node):
      if node != None:
          inorder-tree-walk(node.left)
          print(f"{node}")
          inorder-tree-walk(node.right)
#+end_src

It takes \Theta(n) time to walk an ~n~-node binary search tree, since after the
initial call, the procedure calls itself recursivly exactly twice for each node
in the tree---once for its left child and once for its right child.

- Side Note ::

               Since sorting ~n~ elements takes \Omega(n \lg n) time in the worst
               case in the comparison model, any comparison-based algorithm for
               constructing a binary search tree from an arbitrary list of ~n~
               elements takes \Omega(n \lg n) time in the worst case.

**** Trees---Traversals---Preorder
#+attr_texinfo: :options BST-PY preorder-tree-walk (node)
#+begin_defmethod
Will walk a binary search tree rooted in {{{var(node)}}} by =preorder= means.
#+end_defmethod

#+caption:Preorder Traversal, in Python
#+name:preorder-tree-traversal-python
#+begin_src python -n
  def preorder_tree_walk(node):
      if node != None:
          print(f"{node}")
          preorder_tree_walk(node.left)
          preorder_tree_walk(node.right)
#+end_src

**** Trees---Traversals---Postorder
#+attr_texinfo: :options BST-PY postorder-tree-walk (node)
#+begin_defmethod
Will walk a binary search tree rooted in {{{var(node)}}} by =postorder= means.
#+end_defmethod

#+caption:Postorder Traversal, in Python
#+name:postorder-tree-traversal-python
#+begin_src python -n
  def postorder_tree_walk(node):
      if node != None:
          postorder_tree_walk(node.right)
          postorder_tree_walk(node.left)
          print(f"{node}")
#+end_src

**** Trees---Traversals---Level Order
**** Trees---Traversals---Depth First Search
*** Data Structures---Trees---Preorder Traversal
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 98.38%
:score:    10
:current-rank: 260187
:END:
**** Preorder Traversal Problem Statement
Complete the ~preOrder~ function in your editor below, which has 1 parameter: a
pointer to the root of a binary tree. It must print the values in the tree's
preorder traversal as a single line of space-separated values.

{{{heading{Input Format)}}}

Our hidden tester code passes the root node of a binary tree to your ~preOrder~
function.

{{{subheading(Sample Input)}}}

#+begin_example
     1
      \
       2
        \
         5
        /  \
       3    6
        \
         4
#+end_example

{{{heading(Constraints)}}}

1 \le Nodes in the tree \le 500

{{{heading(Output Format)}}}

Print the tree's preorder traversal as a single line of space-separated values.

{{{subheading(Sample Output)}}}

: 1 2 5 3 4 6

**** Preorder Traversal Python Classes
#+name:python-trees-preorder-traversal-node-binarysearchtree
#+header: :mkdirp yes :noweb yes
#+begin_src python -n :tangle data-structures/trees/python/preorder_traversal.py
<<binary-tree-node-class-python>>
<<binary-tree-class-python>>
#+end_src

**** Preorder Traversal Python Preorder
#+name:python-trees-preorder-traversal-preOrder-function
#+begin_src python +n :tangle data-structures/trees/python/preorder_traversal.py
  """
  Node is defined as
  self.left (the left child of the node)
  self.right (the right child of the node)
  self.info (the value of the node)
  """
  def preOrder(node):
      #Write your code here
      if node != None:
          print(f"{node} ", end="")
          preOrder(node.left)
          preOrder(node.right)
#+end_src

**** Preorder Traversal Python Main
#+name:python-trees-preorder-traversal-main
#+begin_src python +n :tangle data-structures/trees/python/preorder_traversal.py
tree = BinarySearchTree()
t = int(input())
print("Inputs:")
print(f"t: {t}")

arr = list(map(int, input().split()))
print(f"arr: {repr(arr)}")
print("Results:")

for i in range(t):
    tree.create(arr[i])

preOrder(tree.root)
#+end_src

**** Preorder Traversal Python Test
#+name:python-trees-preorder-traversal-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/trees/python
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/trees/python/preorder_traversal.test.sh
echo \
'6
1 2 5 3 6 4' | python3 preorder_traversal.py
#+end_src

#+RESULTS: python-trees-preorder-traversal-test
: Inputs:
: t: 6
: arr: [1, 2, 5, 3, 6, 4]
: Results:
: 1 2 5 3 4 6 

*** Data Structures---Trees---Inorder Traversal
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 99.60%
:score:    10
:current-rank: 253590
:current-score: 331
:END:
**** Data Structures---Trees---Inorder Traversal Problem Statement
Complete the ~inOrder~ function in your editor below, which has 1 parameter: a
pointer to the root of a binary tree. It must print the values in the tree's
inorder traversal as a single line of space-separated values.

{{{heading(Input Format)}}}

Our hidden tester code passes the root node of a binary tree to your ~inOrder~
function.

{{{subheading(Sample Input)}}}

#+begin_example
     1
      \
       2
        \
         5
        /  \
       3    6
        \
         4
#+end_example

{{{heading(Constraints)}}}

1 \le Nodes in the tree \le 500

{{{heading(Output Format)}}}

Print the tree's inorder traversal as a single line of space-separated values.

{{{subheading(Sample Output)}}}

: 1 2 3 4 5 6

**** Data Structures---Trees---Inorder Traversal Node and Tree Classes
#+name:python-trees-inorder-traversal-node-binarysearchtree
#+header: :mkdirp yes :noweb  yes
#+begin_src python -n :tangle data-structures/trees/python/inorder_traversal.py
<<binary-tree-node-class-python>>
<<binary-tree-class-python>>
#+end_src

**** Data Structures---Trees---Inorder Traversal inOrder Function
#+name:data-structures-trees-inorder-traversal-inOrder-function
#+begin_src python +n :tangle data-structures/trees/python/inorder_traversal.py
  """
  Node is defined as
  self.left (the left child of the node)
  self.right (the right child of the node)
  self.info (the value of the node)
  """
  def inOrder(root):
      #Write your code here
      if root != None:
          inOrder(root.left)
          print(f"{root} ", end="")
          inOrder(root.right)
#+end_src

**** Data Structures---Trees---Inorder Traversal Main
#+name:data-structures-trees-inorder-traversal-main
#+begin_src python +n :tangle data-structures/trees/python/inorder_traversal.py
tree = BinarySearchTree()
t = int(input())
print(f"t: {t}")

arr = list(map(int, input().split()))
print(f"arr: {arr}")

for i in range(t):
    tree.create(arr[i])

print("Results:")

inOrder(tree.root)
#+end_src

**** Data Structures---Trees---Inorder Traversal Test
#+name:data-structures-trees-inorder-traversal-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/trees/python
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/trees/python/inorder_traversal.test.sh
echo Inputs:
echo \
'6
1 2 5 3 6 4' | python3 inorder_traversal.py
#+end_src

#+RESULTS: data-structures-trees-inorder-traversal-test
: Inputs:
: t: 6
: arr: [1, 2, 5, 3, 6, 4]
: Results:
: 1 2 3 4 5 6 

*** Data Structures---Trees---Postorder Traversal
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 99.50%
:score:    10
:current-rank: 246619
:current-score]: 341
:END:
**** Data Structures---Trees---Postorder Traversal Problem Statement
Complete the ~postOrder~ function in your editor below, which has 1 parameter:
a pointer to the root of a binary tree.  It must print the values in the tree's
postorder traversal as a single line of space-separated values.

{{{heading(Input Format)}}}

Our hidden tester code passes the root node of a binary tree to your
~postOrder~ function.

{{{subheading(Sample Input)}}}

#+begin_example
     1
      \
       2
        \
         5
        /  \
       3    6
        \
         4
#+end_example

{{{heading(Constraints)}}}

1 \le Nodes in the tree \le 500

{{{heading(Output Format)}}}

Print the tree's postorder traversal as a single line of space-separated
values.

{{{subheading(Sample Output)}}}

: 4 3 6 5 2 1

**** Data Structures---Tress---Postorder Traversal Python Node and Binarysearchtree Classes
#+name:data-structures-trees-postorder-traveral-python-node-binarysearchtree-classes
#+header: :mkdirp yes :noweb yes
#+begin_src python -n :tangle data-structures/trees/python/postorder_traversal.py
<<binary-tree-node-class-python>>
<<binary-tree-class-python>>
#+end_src

**** Data Structures---Trees---Postorder Traversal Python postOrder Function
#+name:data-structures-trees-postorder-traversal-python-postOrder-function
#+begin_src python +n :tangle data-structures/trees/python/postorder_traversal.py
  """
  Node is defined as
  self.left (the left child of the node)
  self.right (the right child of the node)
  self.info (the value of the node)
  """
  def postOrder(root):
      #Write your code here
      if root != None:
          postOrder(root.left)
          postOrder(root.right)
          print(f"{root} ", end="")
#+end_src

**** Data Structures---Trees---Postorder Traversal Python Main Function
#+name:data-structures-trees-postorder-traversal-python-main-function
#+begin_src python +n :tangle data-structures/trees/python/postorder_traversal.py
tree = BinarySearchTree()
t = int(input())
print(f"t: {t}")

arr = list(map(int, input().split()))
print(f"arr: {arr}")

print("Results:")

for i in range(t):
    tree.create(arr[i])

postOrder(tree.root)
#+end_src

**** Data Structures---Trees---Postorder Traversal Test
#+name:data-structures-trees-postorder-traversal-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/trees/python
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/trees/python/postorder_traversal.test.sh
echo Inputs:
echo \
'6
1 2 5 3 6 4' | python3 postorder_traversal.py
#+end_src

#+RESULTS: data-structures-trees-postorder-traversal-test
: Inputs:
: t: 6
: arr: [1, 2, 5, 3, 6, 4]
: Results:
: 4 3 6 5 2 1 

*** Data Structures---Trees---Height of a Binary Tree
:PROPERTIES:
:max-score: 10
:level:    easy
:success-rate: 96.47%
:score:    10
:current-rank: 240226
:END:
Given a binary tree, print its height.
**** DS---Trees---Height of a Binary Tree Problem Statement
The height of a binary tree is the number of edges between the tree's root and
its furthest leaf. For example, the following binary tree is of height 2:

[[file:figures/height-of-binary-tree.png]]

{{{heading(Function Description)}}}

Complete the ~getHeight~ or ~height~ function in the editor.  It must return
the height of a binary tree as an integer.  ~getHeight~ or ~height~ has the
following parameter(s):

- Note :: The Height of binary tree with single node is taken as zero.


{{{heading(Input Format)}}}

The first line contains an integer ~n~, the number of nodes in the tree.

Next line contains ~n~ space-separated integers where ~i~ th integer denotes
~node[i].data~.

- Note :: Node values are inserted into a binary search tree before a reference
          to the tree's root node is passed to your function.  In a binary
          search tree, all nodes on the left branch of a node are less than the
          node value.  All values on the right branch are greater than the node
          value.


{{{subheading(Sample Input)}}}

[[file:figures/treeDepthSample0.png]]

{{{heading(Constraints)}}}

- 1 \le ~node.data[i]~ \le 20

- 1 \le ~n~ \le 20


{{{heading(Output Format)}}}

Your function should return a single integer denoting the height of the binary
tree.

{{{subheading(Sample Output)}}}

: 3

{{{heading(Explanation)}}}

The longest root-to-leaf path is shown below:

[[file:figures/treeDepthSample1.png]]

There are 4 nodes in this path that are connected by 3 edges, meaning our
binary tree's ~height = 3~.

**** DS---Trees---Height of a Binary Tree Python Node Classes
#+name:data-structures-trees-height-of-a-binary-tree-python-node-classes
#+header: :mkdirp yes :noweb yes
#+begin_src python -n :tangle data-structures/trees/python/height_of_binary_tree.py
<<binary-tree-node-class-python>>
<<binary-tree-class-python>>
#+end_src

**** DS---Trees---Height of a Binary Tree Python height Function
#+name:data-structures-trees-height-of-a-binary-tree-height-function
#+begin_src python +n :tangle data-structures/trees/python/height_of_binary_tree.py
# Enter your code here. Read input from STDIN. Print output to STDOUT
'''
class Node:
      def __init__(self,info):
          self.info = info
          self.left = None
          self.right = None


       // this is a node of the tree , which contains info as data, left , right
'''

def height(root):
    m = 0
    # print(f"info: {root.info}")

    def rec(h, r):
        nonlocal m
        if r == None:
            return

        # print(f"info: {r.info}")

        h += 1
        if h > m:
            m = h
        # print(f"h: {h} m: {m}")
        rec(h, r.left)
        rec(h, r.right)
        return

    rec(0, root.left)
    rec(0, root.right)
    return m
#+end_src

**** DS---Trees---Height of a Binary Tree Python Main Script
#+name:data-structures-trees-height-of-a-binary-tree-main-script
#+begin_src python +n :tangle data-structures/trees/python/height_of_binary_tree.py
tree = BinarySearchTree()
t = int(input())
print(f"t: {t}")

arr = list(map(int, input().split()))
print(f"arr: {arr}")
print("Results:")

for i in range(t):
    tree.create(arr[i])

print(height(tree.root))
#+end_src

**** DS---Trees---Height of a Binary Tree Python Test
#+name:data-structures-trees-height-of-a-binary-tree-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/trees/python
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/trees/python/height_of_binary_tree.test.sh
echo Inputs:
echo \
'7
3 5 2 1 4 6 7' | python3 height_of_binary_tree.py
#+end_src
*** Data Structures---Trees---Top View
:PROPERTIES:
:level:    easy
:max-score: 20
:success-rate: 72.11%
:score:    20
:current-rank: 228404
:current-score: 371
:END:
Given a binary tree, print its top view.
**** Data Structures---Trees---Top View Problem Statement
You are given a pointer to the root of a binary tree.  Print the top view of the
binary tree.

#+cindex:top view
Top view means when you look at the tree from the top the nodes, what you will
see will be called the /top view/ of the tree ([[figure-top-view-bst]]).

You only have to complete the function.

For example:

#+caption: Top View : 1 -> 2 -> 5 -> 6
#+name:top-view-example
#+begin_example
   1
    \
     2
      \
       5
      /  \
     3    6
      \
       4
#+end_example

{{{heading(Input Format)}}}

You are given a function,

#+begin_src python
def topView(root):

#+end_src

{{{heading(Constraints)}}}

1 \le nodes in tree \le 500

{{{heading(Output Format)}}}

Print the values on a single line separated by space.

{{{heading(Sample Output)}}}

: 1 2 5 6

{{{heading(Explanation)}}}

From the top only nodes 1,2,5,6 will be visible.

**** Data Structures---Trees---Top View Python Classes
#+name:data-structures-trees-top-view-python-classes
#+header: :mkdirp yes :noweb yes
#+begin_src python -n :tangle data-structures/trees/python/top_view.py
<<binary-tree-node-class-python>>
<<binary-tree-class-python>>
#+end_src

**** Data Structures---Trees---Top View---Python topView function
#+cindex:binary search tree, top view
#+cindex:top view, binary search tree, explanation
#+cindex:width, binary search tree
#+cindex:level, binary search tree
The /top view/ means that the top-most node found at each width point (also
called its /level/) is printed in left-to-right order.  The width is a measure
of how many edges a node is to the left or the right of the root node; this is
not to be confused with the measure of a node's depth (or height) from the root
node, though.

Each time a new node is added to the right (i.e., a higher number is added),
add one to the width count.  Each time a node is added back to the left (i.e.,
a lower number is added), subtract one from the width count.  But to find the
top view, the node's height from the root node must also be taken into account.
Only the lowest node (i.e., lowest height) at a given width is seen in a top
view.  However, when traversing a tree, it is possible to come upon a lower
node at a given width first, so the entire tree must be taken into account
before returning an answer.  See Figure

#+caption:Top View of a Binary Search Tree
#+name:figure-top-view-bst
[[file:figures/top_view_bst-75.png]]

The source of this figure is [[https://algorithms.tutorialhorizon.com/print-the-top-view-of-a-binary-tree/][{{{cite(Print The Top View of a Binary Tree)}}}]].
In the figure, each vertical line marks a different level, with the center
vertical line marking the zero level of the root node.  The first vertical line
to the left marks the -1 level, while the first vertical line to the right
marks the +1 level.

#+cindex:level order traversal
#+cindex:breadth-first search
The algorithm to print a top view is to do level order traversal and print only
the first node at each level.  Level order traversal is accomplished using a
queue for breadth-first searching.  In the figure, both 2 and 9 are at level
-1, but 2 is the first node at this level (i.e., smallest height), so only it
would be printed.

{{{heading(About the Python Code)}}}

In the code below, I have used a Python dictionary to store a node's data
information and height indexed by level.  However, I did depth-first searching
instead of breadth-first searching, and so the wrong width will often be found
first.  The code checks for a width at a lower height and swaps out the node's
information if one is found.  Finally, the dictionary, which contains node
information for each level, is turned into a sorted array (sorted by width in
ascending order) of node information and printed.

#+name:data-structures-trees-top-view-python-topView-function
#+begin_src python +n :tangle data-structures/trees/python/top_view.py
def topView(root):

    d = {} # d: dict of form {width: (height, node.info)}

    def rec(n, w, h): # n: node   w: tree width   h: tree height
        nonlocal d

        if n == None:
            return

        if w not in d:           # each unique width gets added to dict
            d[w] = h, n.info
        else:
            if h < d[w][0]:      # make sure the width with the lowest height is used
                d[w] = h, n.info # this will be the top view

        rec(n.left, w - 1, h + 1)
        rec(n.right, w + 1, h + 1)

    d[0] = 0, root.info
    rec(root.left, -1, 1)
    rec(root.right, 1, 1)

    # transform the dict into a list sorted by width from left to right for printing
    minimum = min(list(d)) # left-most width, e.g., -2
    q = [None] * len(d).   # preallocate a list

    for w in d:
        i = w - minimum.   # translate the width into an index starting at 0
        q[i] = d[w][1]     # d[w][1] is the node.info value at width w

    for info in q:
        print(f"{info} ", end='')
#+end_src

**** Data Structures---Trees---Top View---Python Main Script
#+name:data-structures-trees-top-view-python-main-script
#+begin_src python +n :tangle data-structures/trees/python/top_view.py
tree = BinarySearchTree()
t = int(input())
print(f"t: {t}")

arr = list(map(int, input().split()))
print(f"arr: {arr}")

print("Results:")

for i in range(t):
    tree.create(arr[i])

topView(tree.root)
#+end_src

**** Data Structures---Trees---Top View---Python Test
#+name:data-structures-trees-top-view-python-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/trees/python
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/trees/python/top_view.test.sh
echo Inputs:
echo \
'15
1 14 3 7 4 5 15 6 13 10 11 2 12 8 9' | python3 top_view.py
#+end_src

* Algorithms
** Solve First
:PROPERTIES:
:level:    easy
:max-score: 1
:success-rate: 98.27%
:END:
Complete the function ~solveMeFirst~ to compute the sum of two integers.

{{{heading(Function prototype:)}}}

~int solveMeFirst(int a, int b);~

where

- ~a~ is the first integer input.
- ~b~ is the second integer input


{{{heading(Return values)}}}

- sum of the above two integers

{{{heading(Sample input)}}}

#+begin_example
a = 2
b = 3
#+end_example

{{{heading(Sample output)}}}

: 5

{{{heading(Explanation)}}}

The sum of the two integers ~a~ and ~b~ is computed as: =2 + 3 = 5=.

#+name:solveMeFirst
#+begin_src js -n :tangle algorithms/node/solveMeFirst.js :mkdirp yes
<<node-process-command-line-arguments>>
function main() {
    var a = parseInt(readLine());
    var b = parseInt(readLine());;

    var res = solveMeFirst(a, b);
    console.log(res);
}

function solveMeFirst(a, b) {
  // Hint: Type return a+b below
  return a+b;
}
#+end_src
** Simple Array Sum
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 94.32%
:score:    10
:current-rank: 351026
:current-score: 226
:END:
Calculate the sum of integers in an array.

*** Problem Statement
Given an array of integers, find the sum of its elements.

For example, if the array ~ar~ = ~[1,2,3]~, 1 \plus 2 \plus 3 = 6,
so return 6.

{{{heading(Functional Description)}}}

Complete the ~simpleArraySum~ function in the editor below.  It must return the
sum of the array elements as an integer.

~simpleArraySum~ has the following parameter(s):

- ~ar~ :: an array of integers


{{{heading(Input Format)}}}

The first line contains an integer, ~n~, denoting the size of the array.

The second line contains ~n~ space-separated integers representing the array's
elements.

{{{subheading(Sample Input)}}}

#+begin_example
6
1 2 3 4 10 11
#+end_example

{{{heading(Constraints)}}}

- 0 \le n, ar[i] \le 1000


{{{heading(Output Format)}}}

Print the sum of the array's elements as a single integer.

{{{subheading(Sample Output)}}}

: 31

{{{heading(Explanation)}}}

We print the sum of the array's elements: 1 \plus 2 \plus 3 \plus 4 \plus 10
\plus 11 = 31.

*** Simple Array Sum Node CL Processing
#+name:simple-array-sum-node-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle algorithms/node/simple_array_sum.js
<<node-process-command-line-arguments>>
#+end_src

*** Simple Array Sum Main Function
#+name:simple-array-sum-main
#+begin_src js +n :tangle algorithms/node/simple_array_sum.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const arCount = parseInt(readLine(), 10);
    console.log(`n: ${arCount}`);

    const ar = readLine().split(' ').map(arTemp => parseInt(arTemp, 10));
    console.log(`ar: ${ar}`);

    let result = simpleArraySum(ar);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

*** Simple Array Sum simpleArraySum Function
#+name:simple-array-sum-simpleArraySum
#+begin_src js +n :tangle algorithms/node/simple_array_sum.js
/*
 ,* Complete the simpleArraySum function below.
 ,*/
function simpleArraySum(ar) {
    /*
     ,* Write your code here.
     ,*/
     return ar.reduce((a,e) => a + e,0);
}
#+end_src

*** Simple Array Sum Tests
#+name:simple-array-sum-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :exports results
#+begin_src sh :tangle algorithms/node/simple_array_sum.tests.sh
export OUTPUT_PATH=simple-array-sum-results
echo Inputs:
echo \
'6
1 2 3 4 10 11' | node simple_array_sum.js
echo
echo Result:
cat simple-array-sum-results
#+end_src
** Compare the Triplets
:PROPERTIES:
:level:    easy
:max-score: 10n
:success-rate: 94.18%
:score:    10
:current-rank: 339505
:current-score: 236
:END:
Compre the elements in two triplets.
*** Compare the Triplets Problem Statement
Alice and Bob each created one problem for HackerRank.  A reviewer rates the
two challenges, awarding points on a scale from 1 to 100 for three categories:
problem clarity, originality, and difficulty.

We define the rating for Alice's challenge to be the triplet ~a = ( a[0], a[1],
a[2] )~, and the rating for Bob's challenge to be the triplet ~b = ( b[0],
b[1], b[2] )~.

Your task is to find their comparison points by comparing ~a[0]~ with ~b[0]~,
~a[1]~ with ~b[1]~, and ~a[2]~ with ~b[2]~.

- if ~a[i]~ \gt ~b[i]~, then Alice is awarded 1 point

- if ~a[i]~ \lt ~b[i]~, then Bob is awarded 1 point

- if ~a[i]~ = ~b[i]~, then neither person is awarded any points


Comparison points is the total points a person earned.

Given ~a~ and ~b~, determine their respective comparison points.

For example, ~a = [1, 2, 3]~ and ~b = [3, 2, 1]~.  For elements 0, Bob is
awarded a point because ~a[0] \lt b[0]~.  For the equal elements ~a[1]~ and
~b[1]~, no points are earned.  Finally, for elements 2, ~a[2] \gt b[2]~ so
Alice receives a point.  Your return array would be ~[1, 1]~ with Alice's score
first and Bob's second.


{{{heading(Function Description)}}}

Complete the function ~compareTriplets~ in the editor below.  It must return an
array of two integers, the first being Alice's score and the second being
Bob's.

~compareTriplets~ has the following parameter(s):

- ~a~ :: an array of integers representing Alice's challenge rating

- ~b~ :: an array of integers representing Bob's challenge rating


{{{heading(Input Format)}}}

The first line contains 3 space-separated integers, ~a[0]~, ~a[1]~, and ~a[2]~,
describing the respective values in triplet ~a~.  The second line contains 3
space-separated integers, ~b[0]~, ~b[1]~, and ~b[2]~, describing the respective
values in triplet ~b~.

{{{subheading(Sample Input 0)}}}

#+begin_example
5 6 7
3 6 10
#+end_example

{{{subheading(Sample Input 1)}}}

#+begin_example
17 28 30
99 16 8
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~a[i]~ \le 100

- 1 \le ~b[i]~ \le 100


{{{heading(Output Format)}}}

Return an array of two integers denoting the respective comparison points
earned by Alice and Bob.

{{{subheading(Sample Output 0)}}}

: 1 1

{{{subheading(Sample Output 1)}}}

: 2 1

*** Compare the Triplets Node CL Processing
#+name:compare-the-triplets-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/compare_the_triplets.js
<<node-process-command-line-arguments>>
#+end_src

*** Compare the Triplets Main Function
#+name:compare-the-triplets-main
#+begin_src js +n :tangle algorithms/node/compare_the_triplets.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH, {flags: 'a+'});

    const a = readLine().replace(/\s+$/g, '').split(' ').map(aTemp => parseInt(aTemp, 10));
    console.log(`a: ${a}`);

    const b = readLine().replace(/\s+$/g, '').split(' ').map(bTemp => parseInt(bTemp, 10));
    console.log(`b: ${b}`);

    const result = compareTriplets(a, b);

    ws.write(result.join(' ') + '\n');

    ws.end();
}
#+end_src

*** Compare the Triplets compareTriplets Function
#+name:compare-the-triplets-compareTriplets
#+begin_src js +n :tangle algorithms/node/compare_the_triplets.js
// Complete the compareTriplets function below.
function compareTriplets(a, b) {
    return a.reduce((acc,e,i) => {
        if (e > b[i]) { acc[0]++; return acc; }
        if (e < b[i]) { acc[1]++; return acc; }
        return acc;
    },[0,0]);
}
#+end_src

*** Compare the Triplets Tests
#+name:compare-the-triplets-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :export results
#+begin_src sh :tangle algorithms/node/compare_the_triplets.tests.sh
export OUTPUT_PATH=compare_the_triplets_results
echo
echo Inputs:
echo \
'5 6 7
3 6 10' | node compare_the_triplets.js
echo
echo Inputs
echo \
'17 28 30
99 16 8' | node compare_the_triplets.js
echo
echo Results:
cat compare_the_triplets_results
echo
#+end_src
** A Very Big Sum
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 98.61%
:score:    10
:current-score: 246
:current-rank: 327624
:END:
Calculate the sum of the values in an array that might exceed the range of int
values.
*** A Very Big Sum Problem Statement
Calculate and print the sum of the elements in an array, keeping in mind that
some of those integers may be quite large.

{{{heading(Function Description)}}}

Complete the ~aVeryBigSum~ function in the editor below. It must return the sum
of all array elements.

~aVeryBigSum~ has the following parameter(s):

- ~ar~ :: an array of integers.


{{{heading(Input Format)}}}

The first line of the input consists of an integer ~n~.

The next line contains ~n~ space-separated integers contained in the array.

{{{subheading(Sample Input)}}}

#+begin_example
5
1000000001 1000000002 1000000003 1000000004 1000000005
#+end_example

{{{heading(Output Format)}}}

Print the integer sum of the elements in the array.

{{{subheading(Sample Output)}}}

: 5000000015

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 10

- 0 \le ~ar[i]~ \le 10^10

{{{heading(Note)}}}

The range of the 32-bit integer is ~(\minus 2^31)~ to ~(2^31 \minus 1)~, or
[\minus 2147483648, 2147483647].

When we add several integer values, the resulting sum might exceed the above
range. You might need to use =long long int= in C/C++ or =long= data type in
Java to store such sums.

*** A Very Big Sum Node CL Processing
#+name:a-very-big-sum-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/very_big_sum.js
<<node-process-command-line-arguments>>
#+end_src

*** A Very Big Sum Main Function
#+name:a-very-big-sum-main
#+begin_src js +n :tangle algorithms/node/very_big_sum.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const arCount = parseInt(readLine(), 10);
    console.log(`n: ${arCount}`);

    const ar = readLine().split(' ').map(arTemp => parseInt(arTemp, 10));
    console.log(`ar: ${ar}`);

    let result = aVeryBigSum(ar);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

*** A Very Big Sum aVeryBigSum Function
#+cindex:@code{BigInt}
The built-in type =BigInt= is JavaScript's large integer Number type.
=BigInt=s are created by explicit conversion of a =Number=: ~BigInt(n)~, or by
adding the letter =n= to the end of a literal integer.  Both conversions are
demonstrated in this code.

#+name:a-very-big-sum-aVeryBigSum-function
#+begin_src js +n :tangle algorithms/node/very_big_sum.js
function readLine() {
    return inputString[currentLine++];
}

// Complete the aVeryBigSum function below.
function aVeryBigSum(ar) {
    return ar.reduce((a,e) => { return a + BigInt(e) },0n);
}
#+end_src

*** A Very Big Sum Tests
:PROPERTIES:
:current-rank: 316515
:current-score: 256
:END:
#+name:a-very-big-sum-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :exports results
#+begin_src sh :tangle algorithms/node/very_big_sum_tests.sh
export OUTPUT_PATH=very_big_sum_results
echo Inputs:
echo \
'5
1000000001 1000000002 1000000003 1000000004 1000000005' | node very_big_sum.js
echo
echo Results:
cat very_big_sum_results
#+end_src
** Diagonal Difference
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 95.82%
:score:    10
:current-rank: 316515
:END:
Calculate the absolute difference of sums across the two diagonals of a square
matrix.
*** Diagonal Difference Problem Statement
Given a square matrix, calculate the absolute difference between the sums of
its diagonals.  For example, the square matrix ~arr~ is shown below:

#+begin_example
1 2 3
4 5 6
9 8 9
#+end_example

The left-to-right diagonal = ~1 + 5 + 9 = 15~.  The right to left diagonal =
~3 + 5 + 9 = 17~.  Their absolute difference is ~|15 - 17| = 2~.

{{{heading(Function Description)}}}

Complete the ~diagonalDifference~ function in the editor below.  It must return
an integer representing the absolute diagonal difference.

~diagonalDifference~ takes the following parameter:

- ~arr~ :: an array of integers.


{{{heading(Input Format)}}}

The first line contains a single integer, ~n~, the number of rows and columns
in the matrix ~arr~.

Each of the next ~n~ lines describes a row, ~arr[i]~, and consists of ~n~
space-separated integers ~arr[i][j]~.


{{{subheading(Sample Input)}}}

#+begin_example
3
11 2 4
4 5 6
10 8 -12
#+end_example

{{{heading(Constraints)}}}

- ~\neg100~ \le ~arr[i][j]~ \le 100


{{{heading(Output Format)}}}

Print the absolute difference between the sums of the matrix's two diagonals as
a single integer.

{{{subheading(Sample Output)}}}

: 15

{{{heading(Explanation)}}}

The primary diagonal is:

#+begin_example
11
   5
     -12
#+end_example

Sum across the primary diagonal: ~11 + 5 - 12 = 4~

The secondary diagonal is:

#+begin_example
     4
   5
10
#+end_example

Sum across the secondary diagonal: ~4 + 5 + 10 = 19~

Difference: ~|4 - 19| = 15~

*** Diagonal Difference Node CL Processing
#+name:diagonal-difference-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/diagonal_difference.js
<<node-process-command-line-arguments>>
#+end_src

*** Diagonal Difference Main Function
#+name:diagonal-difference-main-function
#+begin_src js +n :tangle algorithms/node/diagonal_difference.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);
    console.log(`n: ${n}`);

    let arr = Array(n);

    for (let i = 0; i < n; i++) {
        arr[i] = readLine().replace(/\s+$/g, '').split(' ').map(arrTemp => parseInt(arrTemp, 10));
        console.log(`row[${i}]: ${arr[i]}`);
    }

    const result = diagonalDifference(arr);

    ws.write(result + '\n');

    ws.end();
}
#+end_src

*** Diagonal Difference diagonalDifference Function
#+name:diagonal-difference-function
#+begin_src js +n :tangle algorithms/node/diagonal_difference.js
/*
 ,* Complete the 'diagonalDifference' function below.
 ,*
 ,* The function is expected to return an INTEGER.
 ,* The function accepts 2D_INTEGER_ARRAY arr as parameter.
 ,*/

function diagonalDifference(arr) {
    const len = arr[0].length;
    const diagonals = arr.reduce((acc,row,i) => {
        acc[0] += row[i];
        acc[1] += row[len - 1 - i];
        return acc;
    },[0,0]);

    return Math.abs(diagonals[0] - diagonals[1]);
}
#+end_src

*** Diagonal Difference Tests
#+name:diagonal-dfference-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :exports results
#+begin_src sh +n :tangle algorithms/node/diagonal_difference.test.sh
export OUTPUT_PATH=diagonal_difference_results
echo Inputs:
echo \
'3
11 2 4
4 5 6
10 8 -12' | node diagonal_difference.js
echo
echo Result:
cat diagonal_difference_results
#+end_src
** Plus Minus
:PROPERTIES:
:max-score: 10
:level:    easy
:success-rate: 98.14%
:score:    10
:current-rank: 306492
:current-score: 266
:END:
Calculate the fraction of positive, negative, and zero values in an array.
*** Plus Minus Problem Statement
Given an array of integers, calculate the fractions of its elements that are
positive, negative, and are zeros.  Print the decimal value of each fraction on
a new line.

#+cindex:precision problem
#+cindex:absolute error
*Note*: This challenge introduces precision problems. The test cases are scaled
 to six decimal places, though answers with absolute error of up to 10^-4 are
 acceptable.

For example, given the array ~arr = [1,1,0,-1,-1]~, there are elements, two
positive, two negative and one zero.  Their ratios would be ~2/5 = 0.400000~,
~2/5 = 0.400000~, and ~1/5 = 0.200000~.  It should be printed as:

#+begin_example
0.400000
0.400000
0.200000
#+end_example

{{{heading(Function Description)}}}

Complete the ~plusMinus~ function in the editor below.  It should print out the
ratio of positive, negative and zero items in the array, each on a separate
line rounded to six decimals.

~plusMinus~ has the following parameter(s):

- ~arr~ :: an array of integers

{{{heading(Input Format)}}}

The first line contains an integer, ~n~, denoting the size of the array.

The second line contains ~n~ space-separated integers describing an array of
numbers ~arr[0]...arr[n-1]~.

{{{heading(Constraints)}}}

- 0 \lt n \le 100

- \minus100 \le arr[i] \le 100


{{{subheading(Sample Input)}}}

#+begin_example
6
-4 3 -9 0 4 1
#+end_example

{{{heading(Output Format)}}}

You must print the following 3 lines:

1. A decimal representing of the fraction of positive numbers in the array
   compared to its size.

2. A decimal representing of the fraction of negative numbers in the array
   compared to its size.

3. A decimal representing of the fraction of zeros in the array compared to its
   size.


{{{subheading(Sample Output)}}}

#+begin_example
0.500000
0.333333
0.166667
#+end_example

{{{heading(Explanation)}}}

There are 3 positive numbers, 2 negative numbers, and 1 zero in the array.

The proportions of occurrence are:

1. positive: 3/6 = 0.500000

2. negative: 2/6 = 0.333333

3. zeroes: 1/6 = 1.66667

*** Plus Minus Node CL Processing
#+name:plus-minus-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/plus-minus.js
<<node-process-command-line-arguments>>
#+end_src

*** Plus Minus Node Main Function
#+name:plus-minus-node-main-function
#+begin_src js +n :tangle algorithms/node/plus-minus.js
function main() {
    const n = parseInt(readLine(), 10);
    console.log(`n: ${n}`);

    const arr = readLine().split(' ').map(arrTemp => parseInt(arrTemp, 10));
    console.log(`arr: ${arr}`);

    plusMinus(arr);
}
#+end_src

*** Plus Minus Node plusMinus Function
#+name:plus-minus-node-function
#+begin_src js +n :tangle algorithms/node/plus-minus.js
// Complete the plusMinus function below.
function plusMinus(arr) {
    const totals = arr.reduce((a,e) => {
        const d = e > 0 ? a[0]++ : e < 0 ? a[1]++ : a[2]++;
        return a;
    },[0,0,0]);

    const n = arr.length;
    console.log((totals[0] / n).toFixed(6));
    console.log((totals[1] / n).toFixed(6));
    console.log((totals[2] / n).toFixed(6));
}
#+end_src

*** Plus Minus Node Test
#+name:plus-minus-node-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :exports results
#+begin_src js sh :tangle algorithms/node/plus-minus-test.sh
echo Inputs:
echo \
'6
-4 3 -9 0 4 1' | node plus-minus.js
#+end_src
** Staircase
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 98.26%
:score:    10
:current-rank: 297068
:current-score: 276
:END:
Print a right-aligned staircase with ~n~ steps.
*** Staircase Problem Statement
Consider a staircase of size ~n~ = 4:

#+begin_example
   #
  ##
 ###
####
#+end_example

Observe that its base and height are both equal to ~n~, and the image is drawn
using =#= symbols and spaces.  The last line is not preceded by any spaces.

Write a program that prints a staircase of size ~n~.

{{{heading(Function Description)}}}

Complete the staircase function in the editor below.  It should print a
staircase as described above.

~staircase~ has the following parameter(s):

- ~n~ :: an integer


{{{heading(Input Format)}}}

A single integer, ~n~, denoting the size of the staircase.

{{{subheading(Sample Input)}}}

: 6

{{{heading(Constraints)}}}

- 0 \le ~n~ \le 100


{{{heading(Output Format)}}}

Print a staircase of size ~n~ using =#= symbols and spaces.

*Note*: The last line must have 0 spaces in it.

{{{subheading(Sanple Output)}}}

#+begin_example
     #
    ##
   ###
  ####
 #####
######
#+end_example

{{{heading(Explanation)}}}

The staircase is right-aligned, composed of =#= symbols and spaces, and has a
height and width of ~n = 6~.

*** Staircase Node CL Argument Processing
#+name:staircase-node-cl-argument-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/staircase.js
<<node-process-command-line-arguments>>
#+end_src

*** Staircase Main Function
#name:staircase-main-function
#+begin_src js +n :tangle algorithms/node/staircase.js
function main() {
    const n = parseInt(readLine(), 10);
    console.log(`n: ${n}`);

    staircase(n);
}
#+end_src

*** Staircase staircase Function
#+name:staircase-function
#+begin_src js +n :tangle algorithms/node/staircase.js
// Complete the staircase function below.
function staircase(n) {
    let staircase = '';
    for (let i = 1; i <= n; i++) {
        staircase += ' '.repeat(n - i).concat('#'.repeat(i));
        if (i < n) staircase = staircase + '\n';
    }
    console.log(staircase);
}
#+end_src

#+RESULTS: staircase-function

*** Staircase Test
#+name:staircase-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :exports output
#+begin_src sh :tangle algorithms/node/staircase.test.sh
echo Inputs:
echo \
'6' | node staircase.js
#+end_src
** Mini-Max Sum
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 92.93%
:score:    10
:current-rank: 287727
:current-score: 286
:END:
Find the maximum and minimum values obtained by summing four of five integers.
*** Mini-Max Sum Problem Statement
Given five positive integers, find the minimum and maximum values that can be
calculated by summing exactly four of the five integers.  Then print the
respective minimum and maximum values as a single line of two space-separated
long integers.

For example, ~arr = [1, 3, 5, 7, 9]~.  Our minimum sum is ~1 + 3 + 5 + 7 = 16~
and our maximum sum is ~3 + 5 + 7 + 9 = 24~.

We would print:

: 16 24

{{{heading(Functional Description)}}}

Complete the miniMaxSum function in the editor below. It should print two
space-separated integers on one line: the minimum sum and the maximum sum of 4
of 5 elements.

~miniMaxSum~ has the following parameter(s):

- ~arr~ :: an array of 5 integers


{{{heading(Input Format)}}}

A single line of five space-separated integers.

{{{subheading(Sample Input)}}}

: 1 2 3 4 5

{{{heading(Constraints)}}}

- 1 \le ~arr[i]~ \le 10^9


{{{heading(Output Format)}}}

Print two space-separated long integers denoting the respective minimum and
maximum values that can be calculated by summing exactly four of the five
integers.  (The output can be greater than a 32 bit integer.)

{{{subheading(Sample Output)}}}

: 10 14

{{{heading(Explanation)}}}

Our initial numbers are 1, 2, 3, 4, and 5.  We can calculate the following sums
using four of the five integers:

1. If we sum everything except 1, our sum is 14.

2. If we sum everything except 2, our sum is 13.

3. If we sum everything except 3, our sum is 12.

4. If we sum everything except 4, our sum is 11.

5. If we sum everything except 5, our sum is 10.


*Hint*: Beware of integer overflow!  Use 64-bit Integer.

*** Mini-Max Sum Node CL Processing
#+name:mini-max-sum-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/mini-max-sum.js
<<node-process-command-line-arguments>>
#+end_src

*** Mini-Max Sum Main Function
#+name:mini-max-sum-main
#+begin_src js +n :tangle algorithms/node/mini-max-sum.js
function main() {
    const arr = readLine().split(' ').map(arrTemp => parseInt(arrTemp, 10));
    console.log(`arr: ${arr}`);
    console.log('Results:');

    miniMaxSum(arr);
}
#+end_src

*** Mini-Max Sum miniMaxSum Function
#+name:mini-max-sum-miniMaxSum
#+begin_src js +n :tangle algorithms/node/mini-max-sum.js
// Complete the miniMaxSum function below.
function miniMaxSum(arr) {
    const mini_max = arr.sort().reduce((a,e,i) => {
        if (i < arr.length - 1)
            a[0] += e;
        if (i > 0)
            a[1] += e;
        return a;
    },[0,0]);
    console.log(`${mini_max[0]} ${mini_max[1]}`);
}
#+end_src
*** Mini-Max Sum Test
#+name:mini-max-sum-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :exports results
#+begin_src sh :tangle algorithms/node/mini-max-sum.test.sh
echo Inputs:
echo '1 2 3 4 5' | node mini-max-sum.js
#+end_src
** Birthday Cake Candles
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 96.17%
:score:    10
:current-rank: 279323
:current-points: 296
:END:
Determine the number of candles that are blown out.
*** Birthday Cake Candles Problem Statement
You are in charge of the cake for your niece's birthday and have decided the
cake will have one candle for each year of her total age.  When she blows out
the candles, she’ll only be able to blow out the tallest ones.  Your task is to
find out how many candles she can successfully blow out.

For example, if your niece is turning 4 years old, and the cake will have 4
candles of height 4, 4, 1, 3, she will be able to blow out 2 candles
successfully, since the tallest candles are of height 4 and there are such 2
candles.

{{{heading(Function Description)}}}

Complete the function ~birthdayCakeCandles~ in the editor below.  It must return
an integer representing the number of candles she can blow out.

~birthdayCakeCandles~ has the following parameter(s):

- ~ar~ :: an array of integers representing candle heights


{{{heading(Input Format)}}}

The first line contains a single integer, ~n~, denoting the number of candles
on the cake.

The second line contains ~n~ space-separated integers, where each integer ~i~
describes the height of candle ~i~.

{{{subheading(Sample Input)}}}

#+begin_example
4
3 2 1 3
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 10^5

- 1 \le ~ar[i]~ \le 10^7


{{{heading(Output Format)}}}

Print the number of candles that can be blown out on a new line.

{{{subheading(Sample Output)}}}

: 2

{{{heading(Explanation)}}}

We have one candle of height 1, one candle of height 2, and two candles of
height 3.  Your niece only blows out the tallest candles, meaning the candles
where ~height = 3~.  Because there are 2 such candles, we print 2 on a new
line.

*** Birthday Cake Candles Node CL Processing
#+name:birthday-cake-candles-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/birthday_cake_candles.js
<<node-process-command-line-arguments>>
#+end_src

*** Birthday Cake Candles Main Function
#+name:birthday-cake-candles-main-function
#+begin_src js +n :tangle algorithms/node/birthday_cake_candles.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const arCount = parseInt(readLine(), 10);
    console.log(`n: ${arCount}`);

    const ar = readLine().split(' ').map(arTemp => parseInt(arTemp, 10));
    console.log(`ar: ${ar}`);

    let result = birthdayCakeCandles(ar);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

*** Birthday Cake Candles Function
#+name:birthday-cake-candles-function
#+begin_src js +n :tangle algorithms/node/birthday_cake_candles.js
// Complete the birthdayCakeCandles function below.
function birthdayCakeCandles(ar) {
    let mx = ar.shift(), num = 1;
    ar.forEach(e => {
        if (e > mx)
            mx = e, num = 1;
        else if (e === mx)
            num++;
    });
    return num;
}
#+end_src

*** Birthday Cake Candles Test
#+name:birthday-cake-candles-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node :results output :exports results
#+begin_src sh :tangle algorithms/node/birthday_cake_candles.test.sh
export OUTPUT_PATH=birthday_cake_candles_results
echo Inputs:
echo \
'4
3 2 1 3' | node birthday_cake_candles.js
echo
echo Results:
cat birthday_cake_candles_results
#+end_src
** Time Conversion
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 90.07%
:score:    15
:current-rank: 267004
:current-score: 311
:END:
Convert time from an AM/PM format to a 24 hour format.

*** Time Conversion Problem Statement
Given a time in 12-hour AM/PM format, convert it to military (24-hour) time.

Note: Midnight is 12:00:00AM on a 12-hour clock, and 00:00:00 on a 24-hour
clock. Noon is 12:00:00PM on a 12-hour clock, and 12:00:00 on a 24-hour clock.

{{{heading(Function Description)}}}

Complete the ~timeConversion~ function in the editor below.  It should return a
new string representing the input time in 24 hour format.

~timeConversion~ has the following parameter(s):

- ~s~ :: a string representing time in 24 hour format


{{{heading(Input Format)}}}

A single string ~s~ containing a time in 12-hour clock format (i.e.:
=hh:mm:ssAM= or =hh:mm:ssPM=), where 01 \le ~hh~ \le 12 and 00 \le ~mm~ \le 59.

{{{subheading(Sample Input)}}}

: 07:05:45PM

{{{heading(Constraints)}}}

- All input times are valid


{{{heading(Output Format)}}}

Convert and print the given time in 24-hour format, where 00 \le ~hh~ \le 23.

{{{subheading(Sample Output)}}}

: 19:05:45

*** Time Conversion Node CL Processing
#+name:time-conversion-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/time_conversion.js
<<node-process-command-line-arguments>>
#+end_src

*** Time Conversion Main Function
#+name:time-conversion-main-function
#+begin_src js +n :tangle algorithms/node/time_conversion.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const s = readLine();
    console.log(`s: ${s}`);

    let result = timeConversion(s);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

*** Time Conversion Function
#+name:time-conversion-function
#+begin_src js +n :tangle algorithms/node/time_conversion.js
/*
 ,* Complete the timeConversion function below.
 ,*/
function timeConversion(s) {
    /* input format: hh:mm:ssAM|PM */
    const meridian = s.substring(8);
    const time = s.substring(0,8);
    let   hour = time.substring(0,2);
    const minsec = time.substring(2);

    if (hour === '12')
        hour = '00';

    let hr = Number.parseInt(hour);
    if (meridian === 'PM')
        hr += 12;

    let milHour = hr.toString();
    if (milHour.length === 1)
        milHour = '0' + milHour;

    const milTime = milHour + minsec;

    return milTime;
}
#+end_src

*** Time Conversion Test
#+name:time-conversion-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node :results output :exports results
#+begin_src sh :tangle algorithms/node/time_conversion.test.sh
export OUTPUT_PATH=time_conversion_results
echo Input:
echo \
'12:00:00PM' | node time_conversion.js
echo
echo Results:
cat time_conversion_results
#+end_src

* Ten Days of JavaScript
** Ten Days of JavaScript---Day 0 Greeting
:PROPERTIES:
:level:    easy
:max-score: 10
:score:    10
:current-score: 10
:END:
*** Ten Days of JavaScript---Day 0 Overview
This series focuses on learning and practicing JavaScript.  Each challenge comes
with a tutorial article, and you can view these articles by clicking either the
Topics tab along the top or the article icon in the right-hand menu.

{{{heading(Objective)}}}

In this challenge, we review some basic concepts that will get you started with
this series.  Check out the tutorial to learn more about JavaScript's lexical
structure.

{{{heading(Task)}}}

A greeting function is provided for you in the editor below. It has one
parameter, ~parameterVariable~.  Perform the following tasks to complete this
challenge:

1. Use ~console.log()~ to print =Hello, World!= on a new line in the console,
   which is also known as ~stdout~ or standard output.  The code for this portion
   of the task is already provided in the editor.

2. Use ~console.log()~ to print the contents of ~parameterVariable~ (i.e., the
   argument passed to ~main~).


{{{heading(Input Format)}}}

| Data Type | Parameter           | Description                                                         |
|-----------+---------------------+---------------------------------------------------------------------|
| string    | ~parameterVariable~ | A single line of text containing one or more space-separated words. |
|-----------+---------------------+---------------------------------------------------------------------|

{{{subheading(Sample Input)}}}

: Welcome to 10 Days of JavaScript!

{{{heading(Output Format)}}}

Print the following two lines of output:

1. On the first line, print =Hello, World!= (this is provided for you in the
   editor).

2. On the second line, print the contents of ~parameterVariable~


{{{subheading(Sample Output)}}}

#+begin_example
Hello, World!
Welcome to 10 Days of JavaScript!
#+end_example

{{{heading(Explanation)}}}

We printed two lines of output:

1. We printed the literal string =Hello, World!= using the code provided in the
   editor.

2. The value of ~parameterVariable~ passed to our ~main~ function in this
   Sample Case was =Welcome to 10 Days of JavaScript!=.  We then passed our
   variable to ~console.log~, which printed the contents of
   ~parameterVariable~.

*** Ten Days of JavaScript---Day 0 Node CL Processing
#+name:ten-days-of-javascript-day-0-node-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle ten-days-of-javascript/day-0/hello_world.js
<<node-process-command-line-arguments>>
#+end_src

*** Ten Days of JavaScript---Day 0 Main Function
#+name:ten-days-of-javascript-day-0-main
#+begin_src js +n :tangle ten-days-of-javascript/day-0/hello_world.js
function main() {
    const parameterVariable = readLine();
    console.log(`parameterVariable: ${parameterVariable}`);

    console.log('\nOutput:');
    greeting(parameterVariable);
}
#+end_src

*** Ten Days of JavaScript---Day 0 Greeting Function
#+name:ten-days-of-javascript-day-0-greeting
#+begin_src js +n :tangle ten-days-of-javascript/day-0/hello_world.js
  /*
  ,*   A line of code that prints "Hello, World!" on a new line is provided in the editor.
  ,*   Write a second line of code that prints the contents of 'parameterVariable' on a new line.
  ,*
  ,*	Parameter:
  ,*   parameterVariable - A string of text.
  ,**/
  function greeting(parameterVariable) {
      // This line prints 'Hello, World!' to the console:
      console.log('Hello, World!');

      // Write a line of code that prints parameterVariable to stdout using console.log:
      console.log(parameterVariable);
  }
#+end_src

*** Ten Days of JavaScript---Day 0 Greeting Test
#+name:ten-days-of-javascript-day-0-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-0
#+header: :results output :exports results
#+begin_src sh :tangle ten-days-of-javascript/day-0/hello_world.test.sh
echo Input:
echo 'Welcome to 10 Days of JavaScript!' | node hello_world.js
#+end_src
** Ten Days of JavaScript---Day 0 DataTypes
:PROPERTIES:
:level:    easy
:max-score: 10
:score:    10
:current-score: 20
:END:

{{{heading(Objective)}}}

Today, we're discussing data types.  Check out the attached tutorial for more
details.

{{{heading(Task)}}}

Variables named ~firstInteger~, ~firstDecimal~, and ~firstString~ are declared
for you in the editor below.  You must use the =+= operator to perform the
following sequence of operations:

1. Convert ~secondInteger~ to an integer (=Number= type), then sum it with
   ~firstInteger~ and print the result on a new line using ~console.log~.

2. Convert ~secondDecimal~ to a floating-point number (=Number= type), then sum
   it with ~firstDecimal~ and print the result on a new line using
   ~console.log~.

3. Print the concatenation of ~firstString~ and ~secondString~ on a new line
   using ~console.log~.  Note that ~firstString~ must be printed first.


{{{heading(Input Format)}}}

| Data Type | Parameter       | Description                                                                            |
|-----------+-----------------+----------------------------------------------------------------------------------------|
| string    | ~secondInteger~ | The string representation of an integer you must sum with ~firstInteger~.              |
| string    | ~secondDecimal~ | The string representation of a floating-point number you must sum with ~firstDecimal~. |
| string    | ~secondString~  | A string of one or more space-separated words you must append to ~firstString~         |
|-----------+-----------------+----------------------------------------------------------------------------------------|

{{{subheading(Sample Input)}}}

#+begin_example
12
4.32
is the best place to learn and practice coding!
#+end_example

{{{heading(Output Format)}}}

Print the following three lines of output:

1. On the first line, print the sum of ~firstInteger~ and the integer
   representation of ~secondInteger~.

2. On the second line, print the sum of ~firstDecimal~ and the floating-point
   representation of ~secondDecimal~.

3. On the third line, print ~firstString~ concatenated with ~secondString~.
   You must print ~firstString~ before ~secondString~.


{{{subheading(Sample Output)}}}

#+begin_example
16
8.32
HackerRank is the best place to learn and practice coding!
#+end_example

{{{heading(Explanation)}}}

When we sum the integers 4 and 12, we get the integer 16.

When we sum the floating-point numbers 4.0 and 4.32, we get 8.32.

When we concatenate =HackerRank= with =is the best place to learn and practice
coding!=, we get =HackerRank is the best place to learn and practice coding!=.

*You will not pass this challenge if you attempt to assign the Sample Case
values to your variables instead of following the instructions above.*

*** Ten Days of JavaScript---Day 0 DataTypes Node CL Processing
#+name:ten-days-of-javascript-day-0-data-types-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle ten-days-of-javascript/day-0/data_types.js
<<node-process-command-line-arguments>>
#+end_src

*** Ten Days of JavaScript---Day 0 Data Types Main Function
#+name:ten-days-of-javascript-day-0-data-types-main
#+begin_src js +n :tangle ten-days-of-javascript/day-0/data_types.js
function main() {
    const secondInteger = readLine();
    console.log(`secondInteger: ${secondInteger}`);
    const secondDecimal = readLine();
    console.log(`secondDecimal: ${secondDecimal}`);
    const secondString = readLine();
    console.log(`secondString: ${secondString}`);

    console.log('\nOutput:');
    performOperation(secondInteger, secondDecimal, secondString);
}
#+end_src

*** Ten Days of JavaScript---Day 0 Data Types performOperation Function
#+name:ten-days-of-javascript-day-0-data-types-performOperation
#+begin_src js +n :tangle ten-days-of-javascript/day-0/data_types.js
  /*
  ,*   The variables 'firstInteger', 'firstDecimal', and 'firstString' are declared for you -- do not modify them.
  ,*   Print three lines:
  ,*   1. The sum of 'firstInteger' and the Number representation of 'secondInteger'.
  ,*   2. The sum of 'firstDecimal' and the Number representation of 'secondDecimal'.
  ,*   3. The concatenation of 'firstString' and 'secondString' ('firstString' must be first).
  ,*
  ,*	Parameter(s):
  ,*   secondInteger - The string representation of an integer.
  ,*   secondDecimal - The string representation of a floating-point number.
  ,*   secondString - A string consisting of one or more space-separated words.
  ,**/
  function performOperation(secondInteger, secondDecimal, secondString) {
      // Declare a variable named 'firstInteger' and initialize with integer value 4.
      const firstInteger = 4;

      // Declare a variable named 'firstDecimal' and initialize with floating-point value 4.0.
      const firstDecimal = 4.0;

      // Declare a variable named 'firstString' and initialize with the string "HackerRank".
      const firstString = 'HackerRank ';

      // Write code that uses console.log to print the sum of the
      // 'firstInteger' and 'secondInteger' (converted to a Number type)
      // on a new line.

      console.log(firstInteger + Number(secondInteger));

      // Write code that uses console.log to print the sum of
      // 'firstDecimal' and 'secondDecimal' (converted to a Number type)
      // on a new line.

      console.log(firstDecimal + Number(secondDecimal));

      // Write code that uses console.log to print the concatenation of
      // 'firstString' and 'secondString' on a new line. The variable
      // 'firstString' must be printed first.

      console.log(firstString + secondString);
  }
#+end_src

*** Ten Days of JavaScript---Day 0 Data Types Test
#+name:ten-days-of-javascript-day-0-data-types-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-0
#+header: :results output :output results
#+begin_src sh :tangle ten-days-of-javascript/day-0/data_types.test.sh
echo Input:
echo \
'12
4.32
is the best place to learn and practice coding!' | node data_types.js
#+end_src
** Ten Days of JavaScript---Day 1
*** Day 1---Arithmetic Operators
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 99.34%
:score:    10
:END:
**** Arithmetic Operators Problem Statement

{{{heading(Objective)}}}

In this challenge, we practice using arithmetic operators. Check out the
attached tutorial for resources.

{{{heading(Task)}}}

Complete the following functions in the editor below:

1. ~getArea(length, width)~: Calculate and return the area of a rectangle
   having sides ~length~ and ~width~

2. ~getPerimeter(length, width)~: Calculate and return the perimeter of a
   rectangle having sides ~length~ and ~width~.


he values returned by these functions are printed to stdout by locked stub code
in the editor.


{{{heading(Input Format)}}}

|-----------+-----------+---------------------------------------------|
|           |           | ~getArea~                                   |
|-----------+-----------+---------------------------------------------|
| Data Type | Parameter | Description                                 |
|-----------+-----------+---------------------------------------------|
| Number    | length    | A number denoting the length of a rectangle |
| Number    | height    | A number denoting the height of a rectangle |
|-----------+-----------+---------------------------------------------|

|-----------+-----------+---------------------------------------------|
|           |           | ~getPerimeter~                              |
|-----------+-----------+---------------------------------------------|
| Data Type | Parameter | Description                                 |
|-----------+-----------+---------------------------------------------|
| Number    | length    | A number denoting the length of a rectangle |
| Number    | height    | A number denoting the height of a rectangle |
|-----------+-----------+---------------------------------------------|

{{{heading(Constraints)}}}

- 1 \le ~length~, ~width~ \le 1000

- ~length~ and ~width~ are scaled to at most three decimal places


{{{subheading(Sample Input)}}}

#+begin_example
3
4.5
#+end_example

{{{heading(Output Format)}}}

| Function       | Return Type | Description                                                    |
|----------------+-------------+----------------------------------------------------------------|
| ~getArea~      | Number      | The area of a rectangle having sides ~length~ and ~width~      |
| ~getPerimeter~ | Number      | The perimeter of a rectangle having sides ~length~ and ~width~ |
|----------------+-------------+----------------------------------------------------------------|

{{{subheading(Sample Output)}}}

#+begin_example
13.5
15
#+end_example

{{{heading(Explanation)}}}

The area of the rectangle is ~length~ \times ~width~ = 13.5.

The perimeter of a rectangle is 2 \times (~length~ + ~width~) = 2 \times (3 +
4.5) = 15.

**** Ten Days of JavaScript Day 1 Operators Node CL Processing
#+name:ten-days-of-javascript-day-1-operators-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle ten-days-of-javascript/day-1/operators.js
<<node-process-command-line-arguments>>
#+end_src

**** Ten Days of JavaScript Day 1 Operators Main Function
#+name:ten-days-of-javascript-day-1-main-function
#+begin_src js +n :tangle ten-days-of-javascript/day-1/operators.js
function main() {
    const length = +(readLine());
    console.log(`length: ${length}`);
    const width = +(readLine());
    console.log(`width: ${width}`);

    console.log('Results:\n');

    console.log('area:');
    console.log(getArea(length, width));
    console.log('perimeter:');
    console.log(getPerimeter(length, width));
}
#+end_src

**** Ten Days of JavaScript Day 1 Operators getArea Function
#+name:ten-days-of-javascript-day-1-getArea-function
#+begin_src js +n :tangle ten-days-of-javascript/day-1/operators.js
/**
,*   Calculate the area of a rectangle.
,*
,*   length: The length of the rectangle.
,*   width: The width of the rectangle.
,*
,*	Return a number denoting the rectangle's area.
,**/
function getArea(length, width) {
    let area;
    // Write your code here

    area = length * width;

    return area;
}
#+end_src

**** Ten Days of JavaScript Day 1 Operators getPerimeter Function
#+name:ten-days-of-javascript-day-1-operators-getPerimeter-function
#+begin_src js +n :tangle ten-days-of-javascript/day-1/operators.js
/**
,*   Calculate the perimeter of a rectangle.
,*
,*	length: The length of the rectangle.
,*   width: The width of the rectangle.
,*
,*	Return a number denoting the perimeter of a rectangle.
,**/
function getPerimeter(length, width) {
    let perimeter;
    // Write your code here

    perimeter = 2 * (length + width);

    return perimeter;
}
#+end_src

**** Ten Days of JavaScript Day 1 Operators Test
#+name:ten-days-of-javascript-day-1-operators-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-1
#+header: :results output :exports results
#+begin_src sh :tangle ten-days-of-javascript/day-1/operators.test.sh
echo Inputs:
echo \
'3
4.5 ' | node operators.js
#+end_src
*** Day 1---Functions
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 99.34%
:score:    10
:END:
**** Day 1---Functions Problem Statement

{{{heading(Objective)}}}

Today, we're discussing JavaScript functions. Check out the attached tutorial
for more details.

{{{heading(Task)}}}

Implement a function named ~factorial~ that has one parameter: an integer, ~n~.
It must return the value of ~n!~ (i.e., ~n~ factorial).

{{{heading(Input Format)}}}

Locked stub code in the editor reads a single integer, ~n~, from stdin and
passes it to a function named ~factorial~.

{{{subheading(Sample Input)}}}

: 4

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 10


{{{heading(Output Format)}}}

The function must return the value of ~n!~.

{{{subheading(Sample Output)}}}

: 24

{{{heading(Explanation)}}}

We return the value of 4! = 4 \times 3 \times 2 \times 1 = 24.

**** Ten Days of JavaScript Day 1 Functions Node CL Processing
#+name:ten-days-of-javascript-day-1-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle ten-days-of-javascript/day-1/functions.js
<<node-process-command-line-arguments>>
#+end_src

**** Ten Days of JavaScript Day 1 Functions Main Function
#+name:ten-days-of-javascript-day-1-functions-main-function
#+begin_src js +n :tangle ten-days-of-javascript/day-1/functions.js
function main() {
    const n = +(readLine());
    console.log(`n: ${n}`);

    console.log('Result:')

    console.log(`${n}!:`);
    console.log(factorial(n));
}
#+end_src

**** Ten Days of JavaScript Day 1 Functions factorial Function
#+name:ten-days-of-javascript-day-1-factorial-function
#+begin_src js +n :tangle ten-days-of-javascript/day-1/functions.js
/*
 ,* Create the function factorial here
 ,*/
function factorial(n) {
    if (n === 1)
        return 1;
    else
        return n * factorial(n - 1);
}
#+end_src

**** Ten Days of JavaScript Day 1 Functions Test
#+name:ten-days-of-javascript-day-1-functions-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-1
#+header: :results output :exports results
#+begin_src sh :tangle ten-days-of-javascript/day-1/functions.test.sh
echo Inputs:
echo 4 | node functions.js
#+end_src

#+RESULTS: ten-days-of-javascript-day-1-functions-test
: Inputs:
: n: 4
: Result:
: 4!:
: 24
*** Day 1---Let and Const
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 98.69%
:score:    10
:END:
**** Ten Days of JavaScript Day 1 Let and Const Problem Statement

{{{heading(Objective)}}}

In this challenge, we practice declaring variables using the ~let~ and ~const~
keywords.  Check out the attached tutorial for more details.

{{{heading(Task)}}}

1. Declare a constant variable, =PI=, and assign it the value ~Math.PI~.  You
   will not pass this challenge unless the variable is declared as a constant
   and named =PI= (uppercase).

2. Read a number, ~r~, denoting the radius of a circle from stdin.

3. Use =PI= and ~r~ to calculate the ~area~ and ~perimeter~ of a circle having
   radius ~r~.

4. Print ~area~ as the first line of output and print ~perimeter~ as the second
   line of output.


{{{heading(Input Format)}}}

A single integer, ~r~, denoting the radius of a circle.

{{{subheading(Sample Input)}}}

: 2.6

{{{heading(Constraints)}}}

- 0 \le ~r~ \le 100

- ~r~  is a floating-point number scaled to at most 3 decimal places.


{{{heading(Output Format)}}}

Print the following two lines:

1. On the first line, print the ~area~ of the circle having radius ~r~.

2. On the second line, print the ~perimeter~ of the circle having radius ~r~.


{{{subheading(Sample Output)}}}

#+begin_example
21.237166338267002
16.336281798666924
#+end_example

{{{heading(Explanation)}}}

Given the radius ~r~ = 2.6, we calculate the following:

- ~area = \pi \times r^2 = 21.237166338267002~

- ~perimeter = 2 \times \pi \times r = 16.336281798666924~


We then print ~area~ as our first line of output and ~perimeter~ as our second
line of output.

**** Ten Days of JavaScript Day 1 Let and Const Node CL Processing
#+name:ten-days-of-javascript-day-1-let-and-const-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle ten-days-of-javascript/day-1/let_and_const.js
<<node-process-command-line-arguments>>
#+end_src

**** Ten Days of JavaScript Day 1 Let and Const Main Function
#+name:ten-days-of-javascript-day-1-let-and-const-main-function
#+begin_src js +n :tangle ten-days-of-javascript/day-1/let_and_const.js
function main() {
    // Write your code here. Read input using 'readLine()' and print output using 'console.log()'.

    const PI = Math.PI;

    const r = readLine();
    console.log(`radius: ${r}`);

    // Print the area of the circle:

    const area = PI * r ** 2;
    console.log(`area: ${area}`);

    // Print the perimeter of the circle:

    const perimeter = 2 * PI * r;
    console.log(`perimeter: ${perimeter}`);

    try {
        // Attempt to redefine the value of constant variable PI
        PI = 0;
        // Attempt to print the value of PI
        console.log(PI);
    } catch(error) {
        console.error("You correctly declared 'PI' as a constant.");
    }
}
#+end_src

**** Ten Days of JavaScript Day 1 Let and Const Test
#+name:ten-days-of-javascript-day-1-let-and-const-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-1
#+header: :results output :exports results
#+begin_src sh :tangle ten-days-of-javascript/day-1/let_and_const.test.sh
echo Input:
echo 2.6 | node let_and_const.js
#+end_src
** Ten Days of JavaScript---Day 2
*** Ten Days of JavaScript---Day 2---Conditional Statements--If-Else
:PROPERTIES:
:max-score: 10
:success-rate: 99.14%
:level:    easy
:score:    10
:END:
**** Conditional Statements--If-Else Problem Statement

{{{heading(Objective)}}}

In this challenge, we learn about if-else statements.  Check out the attached
tutorial for more details.

{{{heading(Task)}}}

Complete the ~getGrade(score)~ function in the editor.  It has one parameter:
an integer, ~score~, denoting the number of points Julia earned on an exam.  It
must return the letter corresponding to her ~grade~ according to the following
rules:

- if 25 \lt ~score~ \le 30, the ~grade = A~.

- if 20 \lt ~score~ \le 25, the ~grade = B~.

- if 15 \lt ~score~ \le 0, the ~grade = C~.

- if 10 \lt ~score~ \le 15, the ~grade = D~.

- if 5 \lt ~score~ \le 10, the ~grade = E~.

- if 0 \lt ~score~ \le 5, the ~grade = F~.


{{{heading(Input Format)}}}

Stub code in the editor reads a single integer denoting ~score~ from stdin and
passes it to the function.

{{{subheading(Sample Input)}}}

: 11

{{{heading(Constraints)}}}

- 0 \le ~score~ \le 30


{{{heading(Output Format)}}}

The function must return the value of ~grade~ (i.e., the letter grade) that
Julia earned on the exam.

{{{subheading(Sample Output)}}}

: D

{{{heading(Explanation)}}}

Because ~score = 11~, it satisfies the condition 10 \lt ~score~ \le 15 (which
corresponds to D).  Thus, we return =D= as our answer.

**** Conditional Statements--If-Else Node CL Processing
#+name:conditional-statements-if-else-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle ten-days-of-javascript/day-2/conditional_if_else.js
<<node-process-command-line-arguments>>
#+end_src

**** Conditional Statement--If-Else Main Function
#+name:conditional-statements-if-else-main-function
#+begin_src js +n :tangle ten-days-of-javascript/day-2/conditional_if_else.js
function main() {
    const score = +(readLine());
    console.log(`score: ${score}`);

    console.log('Score: ' + getGrade(score));
}
#+end_src

**** Conditional Statements---If-Else getScore Function
#+name:conditional-statements-if-else-getScore-function
#+begin_src js +n :tangle ten-days-of-javascript/day-2/conditional_if_else.js
function getGrade(score) {
    let grade;
    // Write your code here

    if (score <= 30 && score > 25) {
        grade = 'A';
    } else if (score <= 25 && score > 20) {
        grade = 'B';
    } else if (score <= 20 && score > 15) {
        grade = 'C';
    } else if (score <= 15 && score > 10) {
        grade = 'D';
    } else if (score <= 10 && score > 5) {
        grade = 'E';
    } else {
        grade = 'F';
    }

    return grade;
}
#+end_src

**** Conditional Statements---If-Else Test
#+name:conditional-statements-if-else-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-2
#+header: :results output :exports results
#+begin_src sh :tangle ten-days-of-javascript/day-2/conditional_if_else.test.sh
echo 11 | node conditional_if_else.js
#+end_src

#+RESULTS: conditional-statements-if-else-test
: score: 11
: Score: D

*** Ten Days of JavaScript---Day 2---Conditional Statements--Switch
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 98.68%
:score:    10
:END:

**** Ten Days of JavaScript---Day 2---Conditional Statements--Switch Problem Statement

{{{heading(Objective)}}}

In this challenge, we learn about switch statements.  Check out the attached
tutorial for more details.

{{{heading(Task)}}}

Complete the ~getLetter(s)~ function in the editor.  It has one parameter: a
string, ~s~, consisting of lowercase English alphabetic letters (i.e., a
through z). It must return A, B, C, or D depending on the following criteria:

- If the first character in string ~s~ is in the set ={a,e,i,o,u}=, then return
  =A=.

- If the first character in string ~s~ is in the set ={b,c,d,f,g}=, then return
  =B=.

- If the first character in string ~s~ is in the set ={h,j,k,l,m}=, then return
  =C=.

- If the first character in string ~s~ is in the set ={n,p,q,r,s,t,v,w,x,y,z}=,
  then return =D=.


*Hint*: You can get the letter at some index in using the syntax ~s[i]~ or
~s.charAt(i)~.

{{{heading(Input Format)}}}

Stub code in the editor reads a single string denoting ~s~ from stdin.

{{{subheading(Sample Input)}}}

: adfgt

{{{heading(Constraints)}}}

- 1 \le |s| \le 100, where |s| is the length of ~s~.

- String ~s~ contains lowercase English alphabetic letters (i.e., a through z)
  only.


{{{heading(Output Format)}}}

Return either A, B, C, or D according to the criteria given above.

{{{subheading(Sample Output)}}}

: A

{{{heading(Explanation)}}}

The first character of string ~s = adfgt~ is =a=.  Because the given criteria
stipulate that we print =A= any time the first character is in ={a,e,i,o,u}=,
we return =A= as our answer.

**** Conditional Statements--Switch Node CL Processing
#+name:ten-days-of-javascript-day-2-conditional-statements-switch-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle ten-days-of-javascript/day-2/conditional_statements_switch.js
<<node-process-command-line-arguments>>
#+end_src

**** Conditional Statements--Switch Main Function
#+name:ten-days-of-javascript-day-2-conditional-statements-switch-main-function
#+begin_src js +n :tangle ten-days-of-javascript/day-2/conditional_statements_switch.js
function main() {
    const s = readLine();
    console.log(`s: ${s}`);

    console.log('Letter: ' + getLetter(s));
}
#+end_src

**** Conditional Statements--Switch getLetter Function
#+name:ten-days-of-javascript-day-2-conditional-statements-switch-getLetter-function
#+begin_src js +n :tangle ten-days-of-javascript/day-2/conditional_statements_switch.js
function getLetter(s) {
    let letter;
    // Write your code here

    const letters = [
        ['a','e','i','o','u'],
        ['b','c','d','f','g'],
        ['h','j','k','l','m'],
        ['n','p','q','r','s','t','v','w','x','y','z']
    ];

    switch (letters.find(e => e.includes(s[0]))) {

        case letters[0]: letter = 'A'; break;
        case letters[1]: letter = 'B'; break;
        case letters[2]: letter = 'C'; break;
        case letters[3]: letter = 'D'; break;
        default: throw new Error(`${s[0]} is not an acceptable letter`);
    }

    return letter;
}
#+end_src

**** Conditional Statements--Switch Test
#+name:ten-days-of-javascript-day-2-conditional-statements-switch-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-2
#+header: :results output :exports results
#+begin_src sh +n :tangle ten-days-of-javascript/day-2/conditional_statements_switch.test.sh
echo 'adfgt' | node conditional_statements_switch.js
#+end_src

#+RESULTS: ten-days-of-javascript-day-2-conditional-statements-switch-test
: s: adfgt
: Letter: A

*** Ten Days of JavaScript---Day 2---Loops
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 98.43%
:score:    10
:END:
**** Ten Days of JavaScript---Day 2---Loops Problem Statement

{{{heading(Objective)}}}

In this challenge, we practice looping over the characters of string.  Check out
the attached tutorial for more details.


{{{heading(Task)}}}

Complete the ~vowelsAndConsonants~ function in the editor below.  It has one
parameter, a string, ~s~, consisting of lowercase English alphabetic letters
(i.e., a through z).  The function must do the following:

1. First, print each vowel in ~s~ on a new line.  The English vowels are =a, e,
   i, o, and u=, and each vowel must be printed in the same order as it
   appeared in ~s~.

2. Second, print each consonant (i.e., non-vowel) in ~s~ on a new line in the same
   order as it appeared in ~s~.


{{{heading(Input Format)}}}

Locked stub code in the editor reads string ~s~ from stdin and passes it to the
function.

{{{subheading(Sample Input)}}}

: javascriptloops

{{{heading(Output Format)}}}

First, print each vowel in ~s~ on a new line (in the same order as they
appeared in ~s~).  Second, print each consonant (i.e., non-vowel) in ~s~ on a
new line (in the same order as they appeared in ~s~).

{{{subheading(Sample Output)}}}

#+begin_example
a
a
i
o
o
j
v
s
c
r
p
t
l
p
s
#+end_example

{{{heading(Explanation)}}}

Observe the following:

- Each letter is printed on a new line.
- Then the vowels are printed in the same order as they appeared in ~s~.
- Then the consonants are printed in the same order as they appeared in ~s~

**** Ten Days of JavaScript---Day 2---Loops Node CL Arguments
#+name:ten-days-of-javascript-day-2-loops-node-cl-arguments
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle ten-days-of-javascript/day-2/loops.js
<<node-process-command-line-arguments>>
#+end_src

**** Ten Days of JavaScript---Day 2---Loops Main Function
#+name:ten-days-of-javascript-day-2-loops-main-function
#+begin_src js +n :tangle ten-days-of-javascript/day-2/loops.js
function main() {
    const s = readLine();
    console.log(`s: ${s}`);
    console.log('Results:');

    vowelsAndConsonants(s);
}
#+end_src

**** Ten Days of JavaScript---Day 2---Loops Vowels and Consonants
#+name:ten-days-of-javascript-day-2-loops-vowelsAndConsonsants
#+begin_src js +n :tangle ten-days-of-javascript/day-2/loops.js
/*
 ,* Complete the vowelsAndConsonants function.
 ,* Print your output using 'console.log()'.
 ,*/
function vowelsAndConsonants(s) {
    const vowels = ['a','e','i','o','u'];
    const a = s.split('');

    a.forEach(e => {
        if (vowels.includes(e))
            console.log(e);
    });

    a.forEach(e => {
        if (!vowels.includes(e))
            console.log(e);
    });
}
#+end_src

**** Ten Days of JavaScript---Day 2---Loops Test
#+name:ten-days-of-javascript-day-2-loops-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-2 :mkdirp yes
#+header: :results output :exports results
#+begin_src sh :tangle ten-days-of-javascript/day-2/loops.test.sh
echo 'Inputs:'
echo \
'javascriptloops' | node loops.js
#+end_src
** Ten Days of JavaScript---Day 3
*** Ten Days of JavaScript---Day 3---Arrays
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 95.52%
:score:    15
:END:
**** Ten Days of JavaScript---Day 3---Arrays Problem Statement

{{{heading(Objective)}}}

In this challenge, we learn about Arrays. Check out the attached tutorial for
more details.

{{{heading(Task)}}}

Complete the ~getSecondLargest~ function in the editor below.  It has one
parameter: an array, ~nums~, of ~n~ numbers.  The function must find and return
the second largest number in ~nums~.

{{{heading(Input Format)}}}

Locked stub code in the editor reads the following input from stdin and passes
it to the function:

The first line contains an integer, ~n~, denoting the size of the ~nums~ array.

The second line contains ~n~ space-separated numbers describing the elements in
~nums~.

{{{subheading(Sample Input)}}}

#+begin_example
5
2 3 6 6 5
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 10

- 0 \le ~nums~ \le 100, where ~nums~ is the number at index ~i~.

- The numbers in ~nums~ are not distinct.


{{{heading(Output Format)}}}

Return the value of the second largest number in the ~nums~ array.

{{{subheading(Sample Outout)}}}

: 5

{{{heading(Explanation)}}}

Given the array ~nums = [2,3,6,6,5]~, we see that the largest value in the
array is 6 and the second largest value is 5.  Thus, we return 5 as our answer.

**** Ten Days of JavaScript---Day 3---Arrays Node CL Arguments
#+name:ten-days-of-javascript-day-3-arrays-node-cl-arguments
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle ten-days-of-javascript/day-3/arrays.js
<<node-process-command-line-arguments>>
#+end_src

**** Ten Days of JavaScript---Day 3---Arrays Main Function
#+name:ten-days-of-javascript-day-3-arrays-main-function
#+begin_src js +n :tangle ten-days-of-javascript/day-3/arrays.js
function main() {
    const n = +(readLine());
    console.log(`n: ${n}`);
    const nums = readLine().split(' ').map(Number);
    console.log(`nums: ${nums}`);

    console.log('Result:');
    console.log(getSecondLargest(nums));
}
#+end_src

**** Ten Days of JavaScript---Day 3---Arrays getSecondLargest Function
#+name:ten-days-of-javascript-day-3-arrays-getSecondLargest-function
#+begin_src js +n :tangle ten-days-of-javascript/day-3/arrays.js
/**
,*   Return the second largest number in the array.
,*   @param {Number[]} nums - An array of numbers.
,*   @return {Number} The second largest number in the array.
,**/
function getSecondLargest(nums) {
    // Complete the function
    const s_nums = nums.sort((e1,e2) => Number.parseInt(e2) - Number.parseInt(e1))
    return s_nums.find(e => e < s_nums[0]) || s_nums[0];
}
#+end_src

**** Ten Days of JavaScript---Day 3---Arrays Test
#+name:ten-days-of-javascript-day-3-arrays-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-3
#+header: :results output :exports results
#+begin_src sh :tangle ten-days-of-javascript/day-3/arrays.test.sh
echo Inputs:
echo \
'5
5 1 4 2 3' | node arrays.js
#+end_src

#+RESULTS: ten-days-of-javascript-day-3-arrays-test
: Inputs:
: n: 5
: nums: 5,1,4,2,3
: Result:
: 4

*** Ten Days of JavaScript---Day 3---Try-Catch-Finally
:PROPERTIES:
:max-score: 15
:level:    easy
:success-rate: 98.86%
:score:    15
:END:
**** Ten Days of JavaScript---Day 3---Try-Catch-Finally Problem Statement

{{{heading(Objective)}}}

In this challenge, we learn about strings and exceptions.  Check out the
attached tutorials for more details.

{{{heading(Task)}}}

Complete the ~reverseString~ function; it has one parameter, ~s~.  You must
perform the following actions:

1. Try to reverse string ~s~ using the ~split~, ~reverse~, and ~join~ methods.

2. If an exception is thrown, catch it and print the contents of the
   exception's ~message~ on a new line.

3. Print ~s~ on a new line.  If no exception was thrown, then this should be
   the reversed string; if an exception was thrown, this should be the original
   string.


{{{heading(Input Format)}}}

Locked stub code in the editor reads variable ~s~ from stdin and passes it to
the function.

{{{subheading(Sample Inputs)}}}

: "1234"

: Number(1234)

{{{heading(Output Format)}}}

You must write two print statements using ~console.log()~:

1. Print the contents of a caught exception's ~message~ on a new line.  If no
   exception was thrown, this line should not be printed.

2. Print ~s~ on a new line.  If no exception was thrown, then this should be
   the reversed string; if an exception was thrown, this should be the original
   string.


{{{subheading(Sample Outputs)}}}

: 4321

#+begin_example
s.split is not a function
1234
#+end_example

{{{heading(Explanation)}}}

 ~s = "1234"~ is a string type, so it can be reversed without throwing an
 exception.  Thus, we print the reversed value, =4321=, as our answer.

~s = Number(1234)~ is not a string type, so it can't be reversed using string
functions.  When we try to reverse it anyway, it throws an exception.  We then
catch the exception and print its ~message~, which is =s.split is not a
function=.  Next, we finally print ~s~ which, because it wasn't able to be
reversed, is ~Number(1234)~.

**** Ten Days of JavaScript---Day 3---Try-Catch-Finally Node CL Processing
#+name:ten-days-of-javascript-day-3-try-catch-finally-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle ten-days-of-javascript/day-3/try_catch.js
<<node-process-command-line-arguments>>
#+end_src

**** Ten Days of JavaScript---Day 3---Try-Catch-Finally Main Function
#+name:ten-days-of-javascript-day-3-try-catch-finally-main-function
#+begin_src js +n :tangle ten-days-of-javascript/day-3/try_catch.js
function main() {
    const s = eval(readLine());
    console.log(`s: ${s}`);
    console.log('\nResult:');

    reverseString(s);
}
#+end_src

**** Ten Days of JavaScript---Day 3---Try-Catch-Finally reverseString Function
#+header:ten-days-of-javascript-day-3-try-catch-finally-reverseString-function
#+begin_src js +n :tangle ten-days-of-javascript/day-3/try_catch.js
/*
 ,* Complete the reverseString function
 ,* Use console.log() to print to stdout.
 ,*/
function reverseString(s) {
    try {
        s = s.split('').reverse().join('');
    } catch(err) {
        console.log(err.message);
    }
    console.log(s);
}
#+end_src

**** Ten Days of JavaScript---Day 3---Try-Catch-Finally Test
#+name:ten-days-of-javascript-day-3-try-catch-finally-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-3
#+header: :results output :exports results
#+begin_src sh :tangle ten-days-of-javascript/day-3/try_catch.test.sh
echo Input 1:
echo \
'"1234"' | node try_catch.js
echo
echo Input 2:
echo \
'Number(1234)' | node try_catch.js
#+end_src

*** Ten Days of JavaScript---Day 3---Throw
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 99.33%
:score:    15
:END:

**** Ten Days of JavaScript---Day 3---Throw Problem Statement

{{{heading(Objective)}}}

In this challenge, we practice using ~throw~ and ~catch~ statements to work
with custom error messages.

{{{heading(Task)}}}

Complete the ~isPositive~ function below.  It has one integer parameter, ~a~.
If the value of ~a~ is positive, it must return the string =YES=.  Otherwise,
it must throw an =Error= according to the following rules:

- If ~a~ is 0, throw an =Error= with ~message = Zero Error~.

- If ~a~ is negative, throw an =Error= with ~message = Negative Error~.


{{{heading(Input Format)}}}

Locked stub code in the editor reads the following input from stdin and passes
each value of ~a~ to the function as an argument:

The first line is an integer, ~n~, denoting the number of times the function
will be called with some ~a~.

Each line ~i~ of the ~n~ subsequent lines contains an integer denoting some
~a~.

{{{subheading(Sample Input 0)}}}

#+begin_example
3
1
2
3
#+end_example

{{{subheading(Sample Input 1)}}}

#+begin_example
3
2
0
6
#+end_example

{{{subheading(Sample Input 2)}}}

#+begin_example
2
-1
20
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 5

- -100 \le ~a~ \le 100


{{{heading(Output Format)}}}

If the value of ~a~ is positive, the function must return the string =YES=.
Otherwise, it must throw an =Error= according to the following rules:

- If ~a~ is 0, throw an =Error= with ~message = Zero Error~.

- If ~a~ is negative, throw an =Error= with ~message = Negative Error~.


{{{subheading(Sample Output 0)}}}

#+begin_example
YES
YES
YES
#+end_example

{{{subheading(Sample Output 1)}}}

#+begin_example
YES
Zero Error
YES
#+end_example

{{{subheading(Sample Output 2)}}}

#+begin_example
Negative Error
YES
#+end_example

{{{heading(Explanation 0)}}}

Each of the given values is positive, so we return =YES= each time.  The value
returned during each function call is printed on a new line by locked stub code
in the editor.

{{{heading(Explanation 1)}}}

Locked stub code in the editor makes the following three calls to the
~isPositive~ function:

1. ~isPositive(2)~: This returns =YES= because 2 is positive.

2. ~isPositive(0)~: Because ~a = 0~, we throw an =Error= with ~messasge = Zero
   Error~.  This is caught by the locked stub code and the value of its
   ~message~ is printed.

3. ~isPositive(6)~: This returns =YES= because 6 is positive.


{{{heading(Explanation 2)}}}

Locked stub code in the editor makes the following two calls to the ~isPositive~
function:

1. ~isPositive(-1)~: Because ~a = -1~, we throw an =Error= with ~message =
   Negative Error~.  This is caught by the locked stub code and the value of
   its ~message~ is printed.

2. ~isPositive(20): This returns =YES= because 20 is positive.

**** Ten Days of JavaScript---Day 3---Throw Node CL Processing
#+name:ten-days-of-javascript-day-3-throw-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle ten-days-of-javascript/day-3/throw.js
<<node-process-command-line-arguments>>
#+end_src

**** Ten Days of JavaScript---Day 3---Throw Main Function
#+name:ten-days-of-javascript-day-3-throw-main-function
#+begin_src js +n :tangle ten-days-of-javascript/day-3/throw.js
function main() {
    const n = +(readLine());
    console.log(`n: ${n}`);

    for (let i = 0; i < n; i++) {
        const a = +(readLine());
        console.log(`a: ${a}`);
        
        try {
            console.log(isPositive(a));
        } catch (e) {
            console.log(e.message);
        }
    }
}
#+end_src

**** Ten Days of JavaScript---Day 3---Throw isPositive Function
#+name:ten-days-of-javascript-day-3-throw-isPositive-function
#+begin_src js +n :tangle ten-days-of-javascript/day-3/throw.js
/*
 ,* Complete the isPositive function.
 ,* If 'a' is positive, return "YES".
 ,* If 'a' is 0, throw an Error with the message "Zero Error"
 ,* If 'a' is negative, throw an Error with the message "Negative Error"
 ,*/
function isPositive(a) {
    if (a > 0) return 'YES';
    if (a === 0) throw new Error("Zero Error");
    throw new Error("Negative Error");
}
#+end_src

**** Ten Days of JavaScript---Day 3---Throw Test
#+name:ten-days-of-javascript-day-3-throw-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-3
#+header: :results output :exports results
#+begin_src sh +n :tangle ten-days-of-javascript/day-3/throw.test.sh
echo Inputs:
echo \
'3
1
2
3' | node throw.js
echo
echo Inputs:

echo \
'3
2
0
6' | node throw.js
echo

echo Inputs
echo \
'2
-1
20' | node throw.js
#+end_src
x
* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Program Index
:PROPERTIES:
:unnumbered: t
:index:    pg
:END:

* List of Figures
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo: @listoffloats Figure

* Export Settings                                                  :noexport:
** Options
#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:t tex:t
#+options: H:4

** Texinfo Export Settings
#+texinfo_filename:hackerrank.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Coding
#+texinfo_dir_title:HackerRank Coding Problems
#+texinfo_dir_desc:HackerRank coding problems
#+texinfo_printed_title:HackerRank Coding Problems

** HTML Export Settings
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.2.4)
#+latex_header:

* Macro Definitions                                                :noexport:
#+macro:heading @@texinfo:@heading @@@@html:<h4>@@$1@@html:</h4>@@
#+macro:subheading @@texinfo:@subheading @@@@html:<h5>@@$1@@html:</h5>@@
#+macro:dfn @@texinfo:@dfn{@@@@html:<b>@@$1@@texinfo:}@@@@html:</b>@@
#+macro:var @@texinfo:@var{@@$1@@texinfo:}@@
#+macro:cite @@texinfo:@cite{@@$1@@texinfo:}@@
#+macro:math @@texinfo:@math{@@$1@@texinfo:}@@
* Local Variables                                                  :noexport:
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
