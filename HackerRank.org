# -*- mode:org; fill-column:79; -*-

#+title:HackerRank Coding Problems
#+subtitle:{{{date}}} {{{version}}}
#+date:2019-06-26 09:57
#+macro:version Version 0.4.2
* Introduction
- https://www.hackerrank.com/dashboard

** Tree of Installed Directories and Files
#+name:show-tree
#+begin_src sh :results output :exports results
tree -I '*.org|*.info|*.texi*|*.pdf|*.tex|figs'
#+end_src

#+name:tangle-all
#+begin_src emacs-lisp :results output :exports results
(org-babel-tangle-file "HackerRank.org")
#+end_src

* Node
Programs coded in JavaScript run in the Node.js environment.  The following
code entails the boilerplate for processing command-line arguments using Node's
built-in Streams and Process, in particular ~ReadStream~, ~WriteStream~,
~process.stdin~, and ~process.env~.
** Node Command-Line Processing
The first set of code processes command-line arguments.  The second code
fragment sets up a ~WriteStream~ for writing the result to a file.

#+begin_src js :noweb yes :exports none
<<node-process-command-line-arguments>>
#+end_src

*** Process
:PROPERTIES:
:header-args: :noweb-ref node-process-command-line-arguments
:END:

First are the Node dependencies:

- ~FileSystem~

- ~Process Stdin~ --- the default input encoding is to a buffer; setting the
  encoding to =utf-8= means that the input encoding will be a ~String~.

#+name:node-dependencies
#+begin_src js -n
const fs = require('fs');
process.stdin.setEncoding('utf-8');

#+end_src

- ~inputString~ will become an array holding each line of the input arguments
  as strings.

- ~currentLine~ is a simple counter will be used by the function ~readLine()~
  to produce one line of input after another upon request.

#+name:node-declarations
#+begin_src js +n
let inputString = '';
let currentLine = 0;

#+end_src

This code reads all of the command-line arguments into the variable
~inputString~; upon finishing reading all of the input, the command-line
arguments are broken into an array at newlines, but left in ~inputString~.
During the process, all trailing spaces are removed.

At the conclusion of breaking the arguments into an array, the program's
~main()~ function is called.

#+name:node-process-stdin
#+begin_src js +n
process.stdin.on('readable', () => {
    let chunk;

    while ((chunk = process.stdin.read()) != null)
        inputString += chunk;
});

process.stdin.on('end', () => {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(s => s.replace(/\s*$/, ''));

    main();
});

#+end_src

The function ~readLine()~ is called by the ~main()~ function when it wants
another line of input.

#+name:node-readLine
#+begin_src js +n
function readLine () {
    return inputString[currentLine++];
}

#+end_src

*** Write Stream
This little line of code sets up a ~WriteStream~ at a file established by the
~process.env.OUTPUT_PATH~ environment variable.  The ~main()~ function will
write the result into this file and then close the stream.  The environment
variable must be created prior to running the program or an exception will be
thrown when ~main()~ is entered.

#+name:node-main-write-stream-ws
#+begin_src js
const ws = fs.createWriteStream(process.env.OUTPUT_PATH);
#+end_src

* Data Structures
** Arrays
*** Arrays
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 94.01%
:score:    10
:END:
**** Arrays Problem Definition
An array is a type of data structure that stores elements of the same type in a
contiguous block of memory.  In an array, =A=, of size =N=, each memory
location has some unique index, {{{var(i)}}} (where 0 \le i \le N), that can be
referenced as =A[i]= (you may also see it written as A_i).

Given an array, =A= , of =N= integers, print each element in reverse order as a
single line of space-separated integers.

{{{heading(Input Format)}}}

- The first line contains an integer, =N= (the number of integers in =A=);
- The second line contains =N= space-separated integers describing =A=.


{{{subheading(Sample Input 1)}}}

#+begin_example
4
1 4 3 2
#+end_example


{{{heading(Constraints)}}}

- 1 \le N \le 10^3
- 1 \le A_i \le 10^4, where A_i is the {{{var(i)}}}^th integer in =A=.


{{{heading(Output Format)}}}

Print all =N= integers in =A= in reverse order as a single line of
space-separated integers.

{{{subheading(Sample Output 1)}}}

: 2 3 4 1

**** Arrays Node Process Code
#+name:arrays-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/arrays.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Arrays Main Function
#+name:arrays-main
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/arrays.js :mkdirp yes

function main () {
    <<node-main-write-stream-ws>>

    const arrCount = parseInt(readLine(), 10);

    const arr = readLine().split(' ')
          .map(e => parseInt(e, 10));

    const result = reverseArray(arr);

    ws.write(result.join(' ') + '\n');

    ws.end();
}
#+end_src

**** Arrays Solution Code
#+name:arrays-reverseArray
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/arrays.js
function reverseArray (a) {
    return a.reverse();
}
#+end_src

**** Arrays Test Code
#+name:arrays-test
#+header: :shebang "#! /usr/bin/env bash"
#+begin_src sh -n :tangle data-structures/arrays/node/arrays.test.sh
export OUTPUT_PATH=./result
echo '4
1 4 3 2' | node arrays.js
echo Result:
cat result;
#+end_src

**** Arrays Run Test
#+name:arrays-run-test
#+begin_src sh :dir data-structures/arrays/node :results output :exports results
./arrays.test.sh
#+end_src
*** 2D Array
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 91.19%
:score:    15
:END:
**** Array 2D Problem Definition
Given a 6 \times 6 =2D Array=, ~arr~

#+begin_src sh
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
#+end_src

#+cindex:hourglass, dfn
We define an {{{dfn(hourglass)}}} in =A= to be /a subset of values with indices
falling in this pattern in ~arr~'s graphical representation/:

#+begin_src sh
a b c
  d
e f g
#+end_src

#+cindex:hourglass sum, dfn
There are 16 hourglasses in ~arr~, and an {{{dfn(hourglass sum)}}} is /the sum
of an hourglass' values/.  Calculate the hourglass sum for every hourglass in
~arr~, then print the maximum hourglass sum.

For example, given the =2D array=:
#+begin_src sh
-9 -9 -9  1 1 1
 0 -9  0  4 3 2
-9 -9 -9  1 2 3
 0  0  8  6 6 0
 0  0  0 -2 0 0
 0  0  1  2 4 0
#+end_src
we calculate the following hourglass values:

#+begin_src sh
-63, -34, -9, 12, 
-10, 0, 28, 23, 
-27, -11, -2, 10, 
9, 17, 25, 18
#+end_src

Our highest hourglass value is 16 from the hourglass:

#+begin_src sh
0 4 3
  1
8 6 6
#+end_src

{{{heading(Function Description)}}}

Complete the function ~hourglassSum~ in the editor below.  It should return an
integer, the maximum hourglass sum in the array.

~hourglassSum~ has the following parameter(s):

#+attr_texinfo: :options hourglassSum arr
#+begin_defun
{{{var(arr)}}} is an array of integers 6 \times 6 in size (i.e., a =2D Array=).
This function calculates the largest hourglass sum in the =2D Array=, returning
its value.
#+end_defun

{{{heading(Input Format)}}}

Each of the 6 lines of inputs ~arr[i]~ contains 6 space-separated integers
~arr[i][j]~.

{{{subheading(Sample Input)}}}

#+begin_example
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
#+end_example

{{{heading(Constraints)}}}

- \minus9 \le arr[i][j] \le 9

- 0 \le i, j \le 5

{{{heading(Output Format)}}}

Print the largest (maximum) hourglass sum found in ~arr~.

{{{subheading(Sample Output)}}}

: 19

{{{heading(Explanation)}}}

~arr~ contains the following hourglasses:

#+caption:Description of hourglasses
#+name:hourglasses
[[file:figs/hourglassum.png]]

The hourglass with the maximum sum (19) is:

#+begin_example
2 4 4
  2
1 2 4
#+end_example

**** Array 2D Node Process Code
#+name:array2d-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/array2d/node/array2d.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Hourglass Sum Main Function
#+name:array2d-main
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/array2d/node/array2d.js :mkdirp yes
const ROWS = 6,
COLUMNS = 6;

function main () {
    <<node-main-write-stream-ws>>

    let arr = Array(ROWS);
    for (let i = 0; i < ROWS; i++) {
        arr[i] = readLine()
            .split(' ')
            .map(s => parseInt(s, 10));
    }

    let result = hourglassSum(arr);

    ws.write(result + '\n');

    ws.end();
}
#+end_src

**** Hourglass Sum Solution Code

This is the solution to the problem.  All of the other code simply supports
it.  The ~hourglassSum()~ function receives a reference to a 2D array of equal
rows and columns.  The problem defines its size as a 6 \times 6 2D array, set
by the two constants =ROWS= and =COLUMNS=.

The solution iterates over the center of each hourglass and counts up the sum
of the elements of the hourglass, calculating whether a new maximum value has
been achieved, then returns the maximum value at the conclusion of checking all
hourglasses.

#+name:array2d-hourglassSum-function
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/array2d/node/array2d.js :mkdirp yes
function hourglassSum (arr) {
    let max, sum;
    for (let row = 1; row  < ROWS - 1; row++) {
        for (let col = 1; col < COLUMNS - 1; col++) {
            console.log(`row=${row} col=${col}`);
            sum = (
                arr[row-1][col-1] +
                arr[row-1][col]   +
                arr[row-1][col+1] +
                arr[row][col]     +
                arr[row+1][col-1] +
                arr[row+1][col]   +
                arr[row+1][col+1]
            );
            if (typeof max === 'undefined' || sum > max) {
                max = sum;
            }
            console.log(`sum=${sum} max=${max}`);
        }
    }
    return max;
}
#+end_src

**** Hourglass Sum Test
#+name:array2d-test
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh -n :tangle data-structures/array2d/node/array2d.test.sh
export OUTPUT_PATH='./result'
echo \
'1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0' | node array2d.js

echo Result:
cat ./result
#+end_src

**** Hourglass Sum Run Test
#+name:array2d-run-test
#+begin_src sh :dir data-structures/array2d/node :results output :exports results
./array2d.test.sh
#+end_src
*** Dynamic Array
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 83.20%
:score:    15
:END:
**** Dynamic Array Problem Definition
- Create a list, $seqList$, of $N$ empty sequences, where each sequence is
  indexed from $0$ to $N - 1$.  The elements within each of the $N$ sequences
  also use $0$ --indexing.

- Create an integer, $lastAnswer$, and initialize it to $0$.

- The $2$ types of queries that can be performed on your list of sequences
  ($seqList$) are described below:

  1. Query: $1 \times y$

     1. Find the sequence, $seq$, at index \( ( (x \oplus lastAnswer) % N ) \)
        in $seqList$.

     2. Append integer $y$ to sequence $seq$.

  2. Query: $2 \times y$

     1. Find the sequence, $seq$, at index $( (x \oplus lastAnswer) % N)$ in
        $seqList$.

     2. Find the value of element $y % size$ in $seq$ (where $size$ is the size
        of $seq$) and assign it to $lastAnswer$.

     3. Print the new value of $lastAnswer$ on a new line.


{{{heading(Task)}}}

Given $N$, $Q$, and $Q$ queries, execute each query.

*Note*: $\oplus$ is the bitwise XOR operation, which corresponds to the =^=
operator in most languages.  Learn more about it on [[https://en.wikipedia.org/wiki/Exclusive_or][Wikipedia]].

{{{heading(Input Format)}}}

The first line contains two space-separated integers, $N$ (the number of
sequences) and $Q$ (the number of queries), respectively.  Each of the $Q$
subsequent lines contains a query in the format defined above.

{{{heading(Constraints)}}}

- $1 \le N, Q \le 10^5$

- $0 \le x \le 10^9$

- $0 \le y \le 10^9$

- It is guaranteed that query type $2$ will never query an empty sequence or
  index.


{{{heading(Output Format)}}}

For each type $2$ query, print the updated value of $lastAnswer$ on a new line.

{{{heading(Sample Input)}}}

#+begin_example
1 0 5
1 1 7
1 0 3
2 1 0
2 1 1
#+end_example

{{{heading(Sample Output)}}}

#+begin_example
7
3
#+end_example

{{{heading(Example)}}}

{{{subheading(Initial Values:)}}}

$N = 2$

$lastAnswer = 0$

$S_0 = []$

$S_1 = []$

Query 0: =Append 5 to sequence= $( ( 0 \oplus 0) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5]$

$S_1 = []$

Query 1: =Append 7 to sequence=  $( ( 1 \oplus 0 ) \% 2 ) = 1$

$S_0 = [5]$

$S_1 = [7]$

Query 2: =Append 3 to sequence= $( ( 0 \oplus 0 ) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5, 3]$

$S_1 = [7]$

Query 3: =Assign the value at index 0 of sequence$ $( ( 1 \oplus 0 ) \% 2 ) =
0$ to $lastAnswer$, and print $lastAnswer$.

$lastAnswer = 3$

$S_0 = [5,3]$

$S_1 = [7]$

$3$

**** Dynamic Array Node Process
#+name:dynamic-array-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/dynamic_array/node/dynamic.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Dynamic Array Main Function
#+name:dynamic-array-main-function
#+begin_src js +n :tangle data-structures/dynamic_array/node/dynamic.js
function main() {
    // const ws = fs.createWriteStream(process.env.OUTPUT_PATH);
    const ws = process.stdout;

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);

    const q = parseInt(firstMultipleInput[1], 10);

    let queries = Array(q);

    for (let i = 0; i < q; i++) {
        queries[i] = readLine().replace(/\s+$/g, '').split(' ').map(queriesTemp => parseInt(queriesTemp, 10));
    }

    const result = dynamicArray(n, queries);

    ws.write(result.join('\n') + '\n');

    ws.end();
}
#+end_src

**** Dynamic Array Solution Code
#+name:dynamic-array-solution
#+begin_src js +n :tangle data-structures/dynamic_array/node/dynamic.js
/*
 ,* Complete the 'dynamicArray' function below.
 ,*
 ,* The function is expected to return an INTEGER_ARRAY.
 ,* The function accepts following parameters:
 ,*  1. INTEGER n
 ,*  2. 2D_INTEGER_ARRAY queries
 ,*/

function dynamicArray(n, queries) {

    let seqList = Array(n);
    let lastAnswer = 0;
    let result = []; // INTEGER_ARRAY TO RETURN

    queries.forEach(query => {
        const queryType = query[0];
        const x = query[1], y = query[2];
        const seq = ((x ^ lastAnswer) % n);

        switch (queryType) {
            case 1:
              if (typeof seqList[seq] == 'undefined') seqList[seq] = Array();
              seqList[seq].push(y);
            break;

            case 2:
              const seq2 = y % seqList[seq].length;
              lastAnswer = seqList[seq][seq2];
              result.push(lastAnswer);
            break;
        }
    });
    return result;
}
#+end_src

**** Dynamic Array Test
#+name:dynamic-array-test
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh -n :tangle data-structures/dynamic_array/node/dynamic.test.js
echo '2 5
1 0 5
1 1 7
1 0 3
2 1 0
2 1 1' | node dynamic.js
#+end_src

#+name:dynamic-array-run-test
#+begin_src sh :dir data-structures/dynamic_array/node :results output :exports results
./dynamic.test.js
#+end_src

#+RESULTS: dynamic-array-run-test
: 7
: 3
*** Left Rotation
:PROPERTIES:
:level:    easy
:max-score: 20
:success-rate: 87.28%
:score:    20
:END:
Given an array and a number, ~d~, perform ~d~ left rotations on the array.
**** Left Rotation Problem Statement
A left rotation operation on an array of size ~n~ shifts each of the array's
elements ~1~ unit to the left.  For example, if ~2~ left rotations are
performed on array ~[1,2,3,4,5]~, then the array would become ~[3,4,5,1,2]~.

Given an array of ~n~ integers and a number, ~d~, perform ~d~ left rotations on
the array.  Then print the updated array as a single line of space-separated
integers.

{{{heading(Input Format)}}}

The first line contains two space-separated integers denoting the respective
values of ~n~ (the number of integers) and ~d~ (the number of left rotations
you must perform).

The second line contains ~n~ space-separated integers describing the respective
elements of the array's initial state.

{{{subheading(Sample Input)}}}

#+begin_example
5 4
1 2 3 4 5
#+end_example

{{{subheading(Constraints)}}}

- $1 \le n \le 10^5$
- $1 \le d \le n$
- $1 \le a_i \le 10^6$

{{{heading(Output Format)}}}

Print a single line of ~n~ space-separated integers denoting the final state of
the array after performing ~d~ left rotations.

{{{subheading(Sample Output)}}}

#+begin_example
5 1 2 3 4
#+end_example

{{{heading(Explanation)}}}

When we perform ~d = 4~ left rotations, the array undergoes the following
sequence of changes:

- ~[1, 2, 3, 4, 5]~
- ~[2, 3, 4, 5, 1]~
- ~[3, 4, 5, 1, 2]~
- ~[4, 5, 1, 2, 3]~
- ~[5, 1, 2, 3, 4]~

Thus, we print the array's final state as a single line of space-separated
values, which is ~5 1 2 3 4~.

**** Left Rotation Node Command-Line Processing
#+name:left-rotation-command-line-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/left_rotation/node/left_rotation.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Left Rotation Main Function
#+name:left-rotation-main-function
#+begin_src js +n :tangle data-structures/left_rotation/node/left_rotation.js
function main() {
    const nd = readLine().split(' ');

    const n = parseInt(nd[0], 10);

    const d = parseInt(nd[1], 10);

    const a = readLine().split(' ').map(aTemp => parseInt(aTemp, 10));

    const result = left_rotation(a, n, d);

    console.log(result.join(' '));
}
#+end_src

**** Left Rotation Solution
#+name:left-rotation-solution
#+begin_src js +n :tangle data-structures/left_rotation/node/left_rotation.js
function left_rotation (arr, n, d) {
    return arr.map( (e,i,a) => {
        return a[(i + d) % n];
    });
}
#+end_src

**** Left Rotation Test
#+name:left-rotation-test
#+header: :shebang "#!/usr/bin/env bash" :dir data-structures/left_rotation/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/left_rotation/node/left_rotation.test.sh
echo '5 4
1 2 3 4 5' | node left_rotation.js
#+end_src

#+RESULTS: left-rotation-test
: 5 1 2 3 4
*** Sparse Arrays
:PROPERTIES:
:max-score: 25
:level:    medium
:success-rate: 96.75%
:score:    25
:END:
Determine the number of times a string has previously appeared.
**** Sparse Arrays Problem Statement
There is a collection of input strings and a collection of query strings.  For
each query string, determine how many times it occurs in the list of input
strings.

For example, given input ~strings = ['ab', 'ab', 'abc']~ and ~queries = ['ab',
'abc', 'bc']~, we find 2 instances of ='ab'=, 1 of ='abc'= and 0 of ='bc'=.
For each query, we add an element to our return array, ~results = [2, 1, 0]~.

{{{heading(Functional Description)}}}

Complete the function ~matchingStrings~ in the editor below.  The function must
return an array of integers representing the frequency of occurrence of each
query string in strings.

#+attr_texinfo: :options matchingStrings strings queries
#+begin_defun
{{{var(strings)}}} is an array of strings to search.  {{{var(queries)}}} is an
array of query strings.
#+end_defun

{{{heading(Input Format)}}}

The first line contains an integer ~n~, the size of ~strings~.

Each of the next ~n~ lines contains a string ~strings[i]~.

The next line contains ~q~, the size of ~queries~.

Each of the next ~q~ lines contains a string ~queries[i]~.

{{{subheading(Sample Input)}}}

: strings = ['aba', 'baba', 'aba', 'xzxb']

: queries = ['aba', xzxb', 'ab']

#+begin_example
4
aba
baba
aba
xzxb
3
aba
xzxb
ab
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le q \le 1000

- 1 \le ~|strings[i]|~, ~|queries[i]|~ \le 20


{{{heading(Output Format)}}}

Return an integer array of the results of all queries in order.

{{{subheading(Sample Output)}}}

: results = [2, 1, 0]

#+begin_example
2
1
0
#+end_example

{{{heading(Explanation)}}}

Here, "aba" occurs twice, in the first and third string.  The string "xzxb"
occurs once in the fourth string, and "ab" does not occur at all.

{{{heading(Sample Input 2)}}}

: strings = ['def', 'de', 'fgh']

: queries = ['de', 'lmn', 'fgh']

#+begin_example
3
def
de
fgh
3
de
lmn
fgh
#+end_example

{{{heading(Sample Output)}}}

: results = [1, 0, 1]

#+begin_example
1
0
1
#+end_example

{{{heading(Sample Input 3)}}}

#+begin_example
13
abcde
sdaklfj
asdjf
na
basdn
sdaklfj
asdjf
na
asdjf
na
basdn
sdaklfj
asdjf
5
abcde
sdaklfj
asdjf
na
basdn
#+end_example

{{{heading(Sample Output)}}}

#+begin_example
1
3
4
3
2
#+end_example

**** Sparse Arrays Node CL Process
#+name:sparse-arrays-node-cl-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/sparse_arrays/node/sparse_arrays.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Sparse Arrays ~main~ Function
#+name:sparse-arrays-main
#+begin_src js +n :tangle data-structures/sparse_arrays/node/sparse_arrays.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const stringsCount = parseInt(readLine(), 10);
    console.log(`n = ${stringsCount}`);

    let strings = [];

    for (let i = 0; i < stringsCount; i++) {
        const stringsItem = readLine();
        strings.push(stringsItem);
    }
    console.log(`strings: ${strings}`);

    const queriesCount = parseInt(readLine(), 10);
    console.log(`q = ${queriesCount}`);

    let queries = [];

    for (let i = 0; i < queriesCount; i++) {
        const queriesItem = readLine();
        queries.push(queriesItem);
    }
    console.log(`queries: ${queries}`);

    let res = matchingStrings(strings, queries);

    ws.write(res.join("\n") + "\n");

    ws.end();
}
#+end_src

**** Sparse Arrays ~matchingStrings~ Function
#+name:sparse-arrays-matchingStrings-function
#+begin_src js +n :tangle data-structures/sparse_arrays/node/sparse_arrays.js
function matchingStrings(strings, queries) {
    strings.sort();
    let results = [];
    queries.forEach((e,i) => {
        let count = 0;
        let j;
        if ((j = strings.findIndex(e1 => e1 === e)) >= 0) {
            count++;
            while (strings[++j] === e) count++;
        }
        results[i] = count;
    });
    return results;
}
#+end_src

**** Sparse Arrays Test Code
#+name:sparse-arrays-test-code
#+header: :shebang "#!/usr/bin/env bash"
#+header: :results output :exports both :dir data-structures/sparse_arrays/node
#+begin_src sh -n :tangle data-structures/sparse_arrays/node/sparse_arrays.test.sh
export OUTPUT_PATH=results
echo Input 1
echo '4
aba
baba
aba
xzxb
3
aba
xzxb
ab' | node sparse_arrays.js
echo Results 1
cat results
echo

echo Input 2
echo '3
def
de
fgh
3
de
lmn
fgh' | node sparse_arrays.js
echo Results 2
cat results
echo

echo Input 3
echo '13
abcde
sdaklfj
asdjf
na
basdn
sdaklfj
asdjf
na
asdjf
na
basdn
sdaklfj
asdjf
5
abcde
sdaklfj
asdjf
na
basdn' | node sparse_arrays.js
echo Results 3
cat results
echo
#+end_src
*** Print the Elements of a Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:score:    5
:success-rate: 96.67%
:END:
#+cindex:linked list
#+cindex:head node
If you're new to linked lists, this is a great exercise for learning about
them.  Given a pointer to the head node of a linked list, print its elements in
order, one element per line.  If the head pointer is null (indicating the list
is empty), donâ€™t print anything.

{{{heading(Input Format)}}}

The first line of input contains ~n~, the number of elements in the linked
list.  The next ~n~ lines contain one element each, which are the elements of
the linked list.

*Note*: Do not read any input from stdin/console.  Complete the
~printLinkedList~ function in the editor below.

{{{subheading(Sample Input)}}}

#+begin_example
1
16
13
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the linked
  list.


{{{heading(Output Format)}}}

Print the integer data for each element of the linked list to stdout/console
(e.g.: using ~printf~, ~cout~, etc.).  There should be one element per line.

{{{subheading(Sample Output)}}}

#+begin_example
16
13
#+end_example

{{{heading(Explanation)}}}

There are two elements in the linked list.  They are represented as ~16 -> 13
-> NULL~.  So, the ~printLinkedList~ function should print 16 and 13 each in a
new line.

**** Print Linked List Node CL Processing
#+name:print-linked-list-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/print_linked_list/node/print_linked_list.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Print Linked List Main Function
#+name:print-linked-list-main
#+begin_src js +n :tangle data-structures/print_linked_list/node/print_linked_list.js
function main() {
    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data = ${llistItem}`);
        llist.insertNode(llistItem);
    }

    printLinkedList(llist.head);
}
#+end_src

**** Print Linked List Node Classes

***** Singly Linked List Node Class
#+name:singly-linked-list-node-class
#+begin_src js +n :tangle data-structures/print_linked_list/node/print_linked_list.js
const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};
#+end_src

***** Singly Linked List Class
#+name: singly-linked-list-class
#+begin_src js +n :tangle data-structures/print_linked_list/node/print_linked_list.js
const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};
#+end_src

**** Print Linked List Solution
#+name:print-linked-list-printLinkedList
#+begin_src js +n :tangle data-structures/print_linked_list/node/print_linked_list.js
// Complete the printLinkedList function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function printLinkedList(head) {
    if (!head) return;
    const data = head.data;
    const next = head.next;
    console.log(data);
    printLinkedList(next);
}
#+end_src

**** Print Linked List Test Data
#+name:print-linked-list-test
#+header: :dir data-structures/print_linked_list/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/print_linked_list/node/print_linked_list.test.sh
echo '2
16
13' | node print_linked_list.js
#+end_src
*** Insert a Node at the Tail of Linked List
:PROPERTIES:
:max-score: 5
:level:    easy
:success-rate: 95.28%
:END:
#+cindex:linked list
#+cindex:head node
#+cindex:tail node
You are given the pointer to the head node of a linked list and an integer to
add to the list.  Create a new node with the given integer.  Insert this node
at the tail of the linked list and return the head node of the linked list
formed after inserting this new node.  The given head pointer may be null,
meaning that the initial list is empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode~
~insertAtTail(SinglyLinkedListNode head, int data)~ method.  It takes two
arguments: the head of the linked list and the integer to insert at tail.  You
should not read any input from the stdin/console.

The input is handled by code editor and is as follows:

- The first line contains an integer ~n~, denoting the elements of the linked
  list.

- The next ~n~ lines contain an integer each, denoting the elements that need
  to be inserted at tail.


{{{subheading(Sample Input)}}}

#+begin_example
5
141
302
164
530
474
#+end_example

{{{Constraints}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000


{{{heading(Output Format)}}}

Insert the new node at the tail and just return the head of the updated linked
list.  Do not print anything to stdout/console.  The output is handled by code
in the editor and is as follows:

- Print the elements of the linked list from head to tail, each in a new line.


{{{subheading(Sample Output)}}}

#+begin_example
141
302
164
530
474
#+end_example

{{{heading(Explanation)}}}

- First the linked list is NULL. After inserting 141, the list is 141 -> NULL.

- After inserting 302, the list is 141 -> 302 -> NULL.

- After inserting 164, the list is 141 -> 302 -> 164 -> NULL.

- After inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL.

- After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL,
  which is the final list.

**** Insert Node at Tail Node CL Processing
#+name:insert-node-at-tail-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/insert_node_linked_list/node/insert_node_llist.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Insert Node at Tail Main
#+name:insert-node-at-tail-main
#+begin_src js +n :tangle data-structures/insert_node_linked_list/node/insert_node_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data: ${llistItem}`);
    	const llist_head = insertNodeAtTail(llist.head, llistItem);
      	llist.head = llist_head;
    }

    printSinglyLinkedList(llist.head, '\n', ws);
    ws.write('\n');

    ws.end();
}
#+end_src

**** Insert Node at Tail Node Classes
***** Singly Linked List Node
#+name:insert-node-singly-linked-list-node
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/insert_node_linked_list/node/insert_node_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Singly Linked List
#+name:insert-node-singly-linked-list
#+header: :noweb yes
#+begin_src +n :tangle data-structures/insert_node_linked_list/node/insert_node_llist.js
<<singly-linked-list-class>>
#+end_src

***** Print Singly Linked List
#+name:print-singly-linked-list
#+begin_src js +n :tangle data-structures/insert_node_linked_list/node/insert_node_llist.js
function printSinglyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}
#+end_src

**** Insert Node at Tail insertNodeAtTail
#+name:insert-node-at-tail-insertNodeAtTail
#+begin_src js +n :tangle data-structures/insert_node_linked_list/node/insert_node_llist.js
// Complete the insertNodeAtTail function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function insertNodeAtTail(head, data) {
    const newNode = new SinglyLinkedListNode(data);
    if (head === null) {
        head = newNode;
    } else {
        let oldHead = head;
        while (oldHead.next !== null) {
            oldHead = oldHead.next
        }
        oldHead.next = newNode;
    }
    return head;
}
#+end_src

**** Insert Node at Tail Test
#+name:insert-node-at-tail-test
#+header: :results output :exports results
#+header: :dir data-structures/insert_node_linked_list/node
#+begin_src sh -n :tangle data-structures/insert_node_linked_list/node/insert_node_llist.test.sh
export OUTPUT_PATH=results
echo '5
141
302
164
530
474' | node insert_node_llist.js
echo
echo Results
cat results
#+end_src

#+RESULTS: insert-node-at-tail-test
#+begin_example
n = 5
data: 141
data: 302
data: 164
data: 530
data: 474

Results
141
302
164
530
474
#+end_example

* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Export Settings                                                  :noexport:
** Options
#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:t tex:t
#+options: H:4

** Texinfo Export Settings
#+texinfo_filename:hackerrank.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Coding
#+texinfo_dir_title:HackerRank Coding Problems
#+texinfo_dir_desc:HackerRank coding problems
#+texinfo_printed_title:HackerRank Coding Problems

** HTML Export Settings
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.2.4)
#+latex_header:

* Macro Definitions                                                :noexport:
#+macro:heading @@texinfo:@heading @@@@html:<h4>@@$1@@html:</h4>@@
#+macro:subheading @@texinfo:@subheading @@@@html:<h5>@@$1@@html:</h5>@@
#+macro:dfn @@texinfo:@dfn{@@@@html:<b>@@$1@@texinfo:}@@@@html:</b>@@
#+macro:var @@texinfo:@var{@@$1@@texinfo:}@@
* Local Variables                                                  :noexport:
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
