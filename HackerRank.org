# -*- mode:org; fill-column:79; -*-

#+title:HackerRank Coding Problems
#+subtitle:{{{date}}} {{{version}}}
#+date:2019-07-11 09:35
#+macro:version Version 0.10.5

* Introduction
- https://www.hackerrank.com/dashboard

** Tree of Installed Directories and Files
#+name:show-tree
#+begin_src sh :results output :exports results
tree -I '*.org|*.info|*.texi*|*.pdf|*.tex|figs'
#+end_src

#+name:tangle-all
#+begin_src emacs-lisp :results output :exports results
(org-babel-tangle-file "HackerRank.org")
#+end_src

* Node
Programs coded in JavaScript run in the Node.js environment.  The following
code entails the boilerplate for processing command-line arguments using Node's
built-in Streams and Process, in particular ~ReadStream~, ~WriteStream~,
~process.stdin~, and ~process.env~.
** Node Command-Line Processing
The first set of code processes command-line arguments.  The second code
fragment sets up a ~WriteStream~ for writing the result to a file.

#+begin_src js :noweb yes :exports none
<<node-process-command-line-arguments>>
#+end_src

*** Process
:PROPERTIES:
:header-args: :noweb-ref node-process-command-line-arguments
:END:

First are the Node dependencies:

- ~FileSystem~

- ~Process Stdin~ --- the default input encoding is to a buffer; setting the
  encoding to =utf-8= means that the input encoding will be a ~String~.

#+name:node-dependencies
#+begin_src js -n
const fs = require('fs');
process.stdin.setEncoding('utf-8');

#+end_src

- ~inputString~ will become an array holding each line of the input arguments
  as strings.

- ~currentLine~ is a simple counter will be used by the function ~readLine()~
  to produce one line of input after another upon request.

#+name:node-declarations
#+begin_src js +n
let inputString = '';
let currentLine = 0;

#+end_src

This code reads all of the command-line arguments into the variable
~inputString~; upon finishing reading all of the input, the command-line
arguments are broken into an array at newlines, but left in ~inputString~.
During the process, all trailing spaces are removed.

At the conclusion of breaking the arguments into an array, the program's
~main()~ function is called.

#+name:node-process-stdin
#+begin_src js +n
process.stdin.on('readable', () => {
    let chunk;

    while ((chunk = process.stdin.read()) != null)
        inputString += chunk;
});

process.stdin.on('end', () => {
    inputString = inputString.replace(/\s*$/, '')
        .split('\n')
        .map(s => s.replace(/\s*$/, ''));

    main();
});

#+end_src

The function ~readLine()~ is called by the ~main()~ function when it wants
another line of input.

#+name:node-readLine
#+begin_src js +n
function readLine () {
    return inputString[currentLine++];
}

#+end_src

*** Write Stream
This little line of code sets up a ~WriteStream~ at a file established by the
~process.env.OUTPUT_PATH~ environment variable.  The ~main()~ function will
write the result into this file and then close the stream.  The environment
variable must be created prior to running the program or an exception will be
thrown when ~main()~ is entered.

#+name:node-main-write-stream-ws
#+begin_src js
const ws = fs.createWriteStream(process.env.OUTPUT_PATH);
#+end_src

* Data Structures
** Arrays
*** Arrays
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 94.01%
:score:    10
:END:
**** Arrays Problem Definition
An array is a type of data structure that stores elements of the same type in a
contiguous block of memory.  In an array, =A=, of size =N=, each memory
location has some unique index, {{{var(i)}}} (where 0 \le i \le N), that can be
referenced as =A[i]= (you may also see it written as A_i).

Given an array, =A= , of =N= integers, print each element in reverse order as a
single line of space-separated integers.

{{{heading(Input Format)}}}

- The first line contains an integer, =N= (the number of integers in =A=);
- The second line contains =N= space-separated integers describing =A=.


{{{subheading(Sample Input 1)}}}

#+begin_example
4
1 4 3 2
#+end_example


{{{heading(Constraints)}}}

- 1 \le N \le 10^3
- 1 \le A_i \le 10^4, where A_i is the {{{var(i)}}}^th integer in =A=.


{{{heading(Output Format)}}}

Print all =N= integers in =A= in reverse order as a single line of
space-separated integers.

{{{subheading(Sample Output 1)}}}

: 2 3 4 1

**** Arrays Node Process Code
#+name:arrays-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/arrays.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Arrays Main Function
#+name:arrays-main
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/arrays.js :mkdirp yes

function main () {
    <<node-main-write-stream-ws>>

    const arrCount = parseInt(readLine(), 10);
    console.log(`N = ${arrCount}`);

    const arr = readLine().split(' ')
          .map(e => parseInt(e, 10));
    console.log(`A = ${arr}`);

    const result = reverseArray(arr);

    ws.write(result.join(' ') + '\n');

    ws.end();
}
#+end_src

**** Arrays Solution Code
#+name:arrays-reverseArray
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/arrays.js
function reverseArray (a) {
    return a.reverse();
}
#+end_src

**** Arrays Test Code
#+name:arrays-test
#+header: :shebang "#! /usr/bin/env bash"
#+header: :dir data-structures/arrays/node :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/arrays.test.sh
export OUTPUT_PATH=results_arrays
echo Input:
echo \
'4
1 4 3 2' | node arrays.js

echo
echo Results:
cat results_arrays;
#+end_src

*** 2D Array
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 91.19%
:score:    15
:END:
**** Array 2D Problem Definition
Given a 6 \times 6 =2D Array=, ~arr~

#+begin_src sh
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
#+end_src

#+cindex:hourglass, dfn
We define an {{{dfn(hourglass)}}} in =A= to be /a subset of values with indices
falling in this pattern in ~arr~'s graphical representation/:

#+begin_src sh
a b c
  d
e f g
#+end_src

#+cindex:hourglass sum, dfn
There are 16 hourglasses in ~arr~, and an {{{dfn(hourglass sum)}}} is /the sum
of an hourglass' values/.  Calculate the hourglass sum for every hourglass in
~arr~, then print the maximum hourglass sum.

For example, given the =2D array=:
#+begin_src sh
-9 -9 -9  1 1 1
 0 -9  0  4 3 2
-9 -9 -9  1 2 3
 0  0  8  6 6 0
 0  0  0 -2 0 0
 0  0  1  2 4 0
#+end_src
we calculate the following hourglass values:

#+begin_src sh
-63, -34, -9, 12, 
-10, 0, 28, 23, 
-27, -11, -2, 10, 
9, 17, 25, 18
#+end_src

Our highest hourglass value is 16 from the hourglass:

#+begin_src sh
0 4 3
  1
8 6 6
#+end_src

{{{heading(Function Description)}}}

Complete the function ~hourglassSum~ in the editor below.  It should return an
integer, the maximum hourglass sum in the array.

~hourglassSum~ has the following parameter(s):

#+attr_texinfo: :options hourglassSum arr
#+begin_defun
{{{var(arr)}}} is an array of integers 6 \times 6 in size (i.e., a =2D Array=).
This function calculates the largest hourglass sum in the =2D Array=, returning
its value.
#+end_defun

{{{heading(Input Format)}}}

Each of the 6 lines of inputs ~arr[i]~ contains 6 space-separated integers
~arr[i][j]~.

{{{subheading(Sample Input)}}}

#+begin_example
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
#+end_example

{{{heading(Constraints)}}}

- \minus9 \le arr[i][j] \le 9

- 0 \le i, j \le 5

{{{heading(Output Format)}}}

Print the largest (maximum) hourglass sum found in ~arr~.

{{{subheading(Sample Output)}}}

: 19

{{{heading(Explanation)}}}

~arr~ contains the following hourglasses:

#+caption:Description of hourglasses
#+name:hourglasses
[[file:figs/hourglasssum.png]]

The hourglass with the maximum sum (19) is:

#+begin_example
2 4 4
  2
1 2 4
#+end_example

**** Array 2D Node CL Processing
#+name:array2d-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/array2d.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Array2D Hourglass Sum Main Function
#+name:array2d-main
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/array2d.js :mkdirp yes
const ROWS = 6,
COLUMNS = 6;

function main () {
    <<node-main-write-stream-ws>>

    let arr = Array(ROWS);
    for (let i = 0; i < ROWS; i++) {
        arr[i] = readLine()
            .split(' ')
            .map(s => parseInt(s, 10));
        console.log(`Row: ${arr[i]}`);
    }

    let result = hourglassSum(arr);

    ws.write(result + '\n');

    ws.end();
}
#+end_src

**** Array2D Hourglass Sum Solution Code
This is the solution to the problem.  All of the other code simply supports
it.  The ~hourglassSum()~ function receives a reference to a 2D array of equal
rows and columns.  The problem defines its size as a 6 \times 6 2D array, set
by the two constants =ROWS= and =COLUMNS=.

The solution iterates over the center of each hourglass and counts up the sum
of the elements of the hourglass, calculating whether a new maximum value has
been achieved, then returns the maximum value at the conclusion of checking all
hourglasses.

#+name:array2d-hourglassSum-function
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/arrays/node/array2d.js :mkdirp yes
function hourglassSum (arr) {
    let max, sum;
    for (let row = 1; row  < ROWS - 1; row++) {
        for (let col = 1; col < COLUMNS - 1; col++) {
            console.log(`row=${row} col=${col}`);
            sum = (
                arr[row-1][col-1] +
                arr[row-1][col]   +
                arr[row-1][col+1] +
                arr[row][col]     +
                arr[row+1][col-1] +
                arr[row+1][col]   +
                arr[row+1][col+1]
            );
            if (typeof max === 'undefined' || sum > max) {
                max = sum;
            }
            console.log(`sum=${sum} max=${max}`);
        }
    }
    return max;
}
#+end_src

**** Hourglass Sum Test
#+name:array2d-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/arrays/node :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/array2d.test.sh
export OUTPUT_PATH=result_array2d
echo Input:
echo \
'1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0' | node array2d.js

echo
echo Results:
cat result_array2d
#+end_src

*** Dynamic Array
:PROPERTIES:
:level:    easy
:max-score: 15
:success-rate: 83.20%
:score:    15
:END:
**** Dynamic Array Problem Definition
- Create a list, $seqList$, of $N$ empty sequences, where each sequence is
  indexed from $0$ to $N - 1$.  The elements within each of the $N$ sequences
  also use $0$ --indexing.

- Create an integer, $lastAnswer$, and initialize it to $0$.

- The $2$ types of queries that can be performed on your list of sequences
  ($seqList$) are described below:

  1. Query: $1 \times y$

     1. Find the sequence, $seq$, at index \( ( (x \oplus lastAnswer) % N ) \)
        in $seqList$.

     2. Append integer $y$ to sequence $seq$.

  2. Query: $2 \times y$

     1. Find the sequence, $seq$, at index $( (x \oplus lastAnswer) % N)$ in
        $seqList$.

     2. Find the value of element $y % size$ in $seq$ (where $size$ is the size
        of $seq$) and assign it to $lastAnswer$.

     3. Print the new value of $lastAnswer$ on a new line.


{{{heading(Task)}}}

Given $N$, $Q$, and $Q$ queries, execute each query.

*Note*: $\oplus$ is the bitwise XOR operation, which corresponds to the =^=
operator in most languages.  Learn more about it on [[https://en.wikipedia.org/wiki/Exclusive_or][Wikipedia]].

{{{heading(Input Format)}}}

The first line contains two space-separated integers, $N$ (the number of
sequences) and $Q$ (the number of queries), respectively.  Each of the $Q$
subsequent lines contains a query in the format defined above.

{{{heading(Constraints)}}}

- $1 \le N, Q \le 10^5$

- $0 \le x \le 10^9$

- $0 \le y \le 10^9$

- It is guaranteed that query type $2$ will never query an empty sequence or
  index.


{{{heading(Output Format)}}}

For each type $2$ query, print the updated value of $lastAnswer$ on a new line.

{{{heading(Sample Input)}}}

#+begin_example
1 0 5
1 1 7
1 0 3
2 1 0
2 1 1
#+end_example

{{{heading(Sample Output)}}}

#+begin_example
7
3
#+end_example

{{{heading(Example)}}}

{{{subheading(Initial Values:)}}}

$N = 2$

$lastAnswer = 0$

$S_0 = []$

$S_1 = []$

Query 0: =Append 5 to sequence= $( ( 0 \oplus 0) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5]$

$S_1 = []$

Query 1: =Append 7 to sequence=  $( ( 1 \oplus 0 ) \% 2 ) = 1$

$S_0 = [5]$

$S_1 = [7]$

Query 2: =Append 3 to sequence= $( ( 0 \oplus 0 ) \% 2 ) = 0$

$lastAnswer = 0$

$S_0 = [5, 3]$

$S_1 = [7]$

Query 3: =Assign the value at index 0 of sequence$ $( ( 1 \oplus 0 ) \% 2 ) =
0$ to $lastAnswer$, and print $lastAnswer$.

$lastAnswer = 3$

$S_0 = [5,3]$

$S_1 = [7]$

$3$

**** Dynamic Array Node Process
#+name:dynamic-array-node-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/dynamic.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Dynamic Array Main Function
#+name:dynamic-array-main-function
#+begin_src js +n :tangle data-structures/arrays/node/dynamic.js
function main() {
    // const ws = fs.createWriteStream(process.env.OUTPUT_PATH);
    const ws = process.stdout;

    const firstMultipleInput = readLine().replace(/\s+$/g, '').split(' ');

    const n = parseInt(firstMultipleInput[0], 10);
    console.log(`N = ${n}`);

    const q = parseInt(firstMultipleInput[1], 10);
    console.log(`Q = ${q}`);

    let queries = Array(q);

    for (let i = 0; i < q; i++) {
        queries[i] = readLine().replace(/\s+$/g, '').split(' ').map(queriesTemp => parseInt(queriesTemp, 10));
        console.log(`Query: ${queries[i]}`);
    }

    console.log('\nResults:');
    const result = dynamicArray(n, queries);

    ws.write(result.join('\n') + '\n');

    ws.end();
}
#+end_src

**** Dynamic Array Solution Code
#+name:dynamic-array-solution
#+begin_src js +n :tangle data-structures/arrays/node/dynamic.js
/*
 ,* Complete the 'dynamicArray' function below.
 ,*
 ,* The function is expected to return an INTEGER_ARRAY.
 ,* The function accepts following parameters:
 ,*  1. INTEGER n
 ,*  2. 2D_INTEGER_ARRAY queries
 ,*/

function dynamicArray(n, queries) {

    let seqList = Array(n);
    let lastAnswer = 0;
    let result = []; // INTEGER_ARRAY TO RETURN

    queries.forEach(query => {
        const queryType = query[0];
        const x = query[1], y = query[2];
        const seq = ((x ^ lastAnswer) % n);

        switch (queryType) {
            case 1:
              if (typeof seqList[seq] == 'undefined') seqList[seq] = Array();
              seqList[seq].push(y);
            break;

            case 2:
              const seq2 = y % seqList[seq].length;
              lastAnswer = seqList[seq][seq2];
              result.push(lastAnswer);
            break;
        }
    });
    return result;
}
#+end_src

**** Dynamic Array Test
#+name:dynamic-array-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/arrays/node :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/dynamic.test.js
echo Input:
echo \
'2 5
1 0 5
1 1 7
1 0 3
2 1 0
2 1 1' | node dynamic.js
#+end_src

#+RESULTS: dynamic-array-test
#+begin_example
Input:
N = 2
Q = 5
Query: 1,0,5
Query: 1,1,7
Query: 1,0,3
Query: 2,1,0
Query: 2,1,1

Results:
7
3
#+end_example

*** Left Rotation
:PROPERTIES:
:level:    easy
:max-score: 20
:success-rate: 87.28%
:score:    20
:END:
Given an array and a number, ~d~, perform ~d~ left rotations on the array.

**** Left Rotation Problem Statement
A left rotation operation on an array of size ~n~ shifts each of the array's
elements ~1~ unit to the left.  For example, if ~2~ left rotations are
performed on array ~[1,2,3,4,5]~, then the array would become ~[3,4,5,1,2]~.

Given an array of ~n~ integers and a number, ~d~, perform ~d~ left rotations on
the array.  Then print the updated array as a single line of space-separated
integers.

{{{heading(Input Format)}}}

The first line contains two space-separated integers denoting the respective
values of ~n~ (the number of integers) and ~d~ (the number of left rotations
you must perform).

The second line contains ~n~ space-separated integers describing the respective
elements of the array's initial state.

{{{subheading(Sample Input)}}}

#+begin_example
5 4
1 2 3 4 5
#+end_example

{{{subheading(Constraints)}}}

- $1 \le n \le 10^5$
- $1 \le d \le n$
- $1 \le a_i \le 10^6$

{{{heading(Output Format)}}}

Print a single line of ~n~ space-separated integers denoting the final state of
the array after performing ~d~ left rotations.

{{{subheading(Sample Output)}}}

#+begin_example
5 1 2 3 4
#+end_example

{{{heading(Explanation)}}}

When we perform ~d = 4~ left rotations, the array undergoes the following
sequence of changes:

- ~[1, 2, 3, 4, 5]~
- ~[2, 3, 4, 5, 1]~
- ~[3, 4, 5, 1, 2]~
- ~[4, 5, 1, 2, 3]~
- ~[5, 1, 2, 3, 4]~

Thus, we print the array's final state as a single line of space-separated
values, which is ~5 1 2 3 4~.

**** Left Rotation Node CL Processing
#+name:left-rotation-command-line-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/left_rotation.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Left Rotation Main Function
#+name:left-rotation-main-function
#+begin_src js +n :tangle data-structures/arrays/node/left_rotation.js
function main() {
    const nd = readLine().split(' ');

    const n = parseInt(nd[0], 10);
    console.log(`N = ${n}`);

    const d = parseInt(nd[1], 10);
    console.log(`D = ${d}`);

    const a = readLine().split(' ').map(aTemp => parseInt(aTemp, 10));
    console.log(`A = ${a}`);

    const result = left_rotation(a, n, d);

    console.log('\nResults:');
    console.log(result.join(' '));
}
#+end_src

**** Left Rotation Solution
#+name:left-rotation-solution
#+begin_src js +n :tangle data-structures/arrays/node/left_rotation.js
function left_rotation (arr, n, d) {
    return arr.map( (e,i,a) => {
        return a[(i + d) % n];
    });
}
#+end_src

**** Left Rotation Test
#+name:left-rotation-test
#+header: :shebang "#!/usr/bin/env bash" :dir data-structures/arrays/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/left_rotation.test.sh
echo Input:
echo \
'5 4
1 2 3 4 5' | node left_rotation.js
#+end_src

*** Sparse Arrays
:PROPERTIES:
:max-score: 25
:level:    medium
:success-rate: 96.75%
:score:    25
:END:
Determine the number of times a string has previously appeared.
**** Sparse Arrays Problem Statement
There is a collection of input strings and a collection of query strings.  For
each query string, determine how many times it occurs in the list of input
strings.

For example, given input ~strings = ['ab', 'ab', 'abc']~ and ~queries = ['ab',
'abc', 'bc']~, we find 2 instances of ='ab'=, 1 of ='abc'= and 0 of ='bc'=.
For each query, we add an element to our return array, ~results = [2, 1, 0]~.

{{{heading(Functional Description)}}}

Complete the function ~matchingStrings~ in the editor below.  The function must
return an array of integers representing the frequency of occurrence of each
query string in strings.

#+attr_texinfo: :options matchingStrings strings queries
#+begin_defun
{{{var(strings)}}} is an array of strings to search.  {{{var(queries)}}} is an
array of query strings.
#+end_defun

{{{heading(Input Format)}}}

The first line contains an integer ~n~, the size of ~strings~.

Each of the next ~n~ lines contains a string ~strings[i]~.

The next line contains ~q~, the size of ~queries~.

Each of the next ~q~ lines contains a string ~queries[i]~.

{{{subheading(Sample Input)}}}

: strings = ['aba', 'baba', 'aba', 'xzxb']

: queries = ['aba', xzxb', 'ab']

#+begin_example
4
aba
baba
aba
xzxb
3
aba
xzxb
ab
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le q \le 1000

- 1 \le ~|strings[i]|~, ~|queries[i]|~ \le 20


{{{heading(Output Format)}}}

Return an integer array of the results of all queries in order.

{{{subheading(Sample Output)}}}

: results = [2, 1, 0]

#+begin_example
2
1
0
#+end_example

{{{heading(Explanation)}}}

Here, "aba" occurs twice, in the first and third string.  The string "xzxb"
occurs once in the fourth string, and "ab" does not occur at all.

{{{heading(Sample Input 2)}}}

: strings = ['def', 'de', 'fgh']

: queries = ['de', 'lmn', 'fgh']

#+begin_example
3
def
de
fgh
3
de
lmn
fgh
#+end_example

{{{heading(Sample Output)}}}

: results = [1, 0, 1]

#+begin_example
1
0
1
#+end_example

{{{heading(Sample Input 3)}}}

#+begin_example
13
abcde
sdaklfj
asdjf
na
basdn
sdaklfj
asdjf
na
asdjf
na
basdn
sdaklfj
asdjf
5
abcde
sdaklfj
asdjf
na
basdn
#+end_example

{{{heading(Sample Output)}}}

#+begin_example
1
3
4
3
2
#+end_example

**** Sparse Arrays Node CL Processing
#+name:sparse-arrays-node-cl-process
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/sparse_arrays.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Sparse Arrays ~main~ Function
#+name:sparse-arrays-main
#+begin_src js +n :tangle data-structures/arrays/node/sparse_arrays.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const stringsCount = parseInt(readLine(), 10);
    console.log(`n = ${stringsCount}`);

    let strings = [];

    for (let i = 0; i < stringsCount; i++) {
        const stringsItem = readLine();
        strings.push(stringsItem);
    }
    console.log(`strings: ${strings}`);

    const queriesCount = parseInt(readLine(), 10);
    console.log(`q = ${queriesCount}`);

    let queries = [];

    for (let i = 0; i < queriesCount; i++) {
        const queriesItem = readLine();
        queries.push(queriesItem);
    }
    console.log(`queries: ${queries}`);

    let res = matchingStrings(strings, queries);

    ws.write(res.join("\n") + "\n");

    ws.end();
}
#+end_src

**** Sparse Arrays ~matchingStrings~ Function
#+name:sparse-arrays-matchingStrings-function
#+begin_src js +n :tangle data-structures/arrays/node/sparse_arrays.js
function matchingStrings(strings, queries) {
    strings.sort();
    let results = [];
    queries.forEach((e,i) => {
        let count = 0;
        let j;
        if ((j = strings.findIndex(e1 => e1 === e)) >= 0) {
            count++;
            while (strings[++j] === e) count++;
        }
        results[i] = count;
    });
    return results;
}
#+end_src

**** Sparse Arrays Test Code
#+name:sparse-arrays-test-code
#+header: :shebang "#!/usr/bin/env bash"
#+header: :results output :exports both :dir data-structures/arrays/node
#+begin_src sh -n :tangle data-structures/arrays/node/sparse_arrays.test.sh
export OUTPUT_PATH=results_sparse_arrays
echo Input 1
echo \
'4
aba
baba
aba
xzxb
3
aba
xzxb
ab' | node sparse_arrays.js
echo Results 1
cat results_sparse_arrays
echo

echo Input 2
echo '3
def
de
fgh
3
de
lmn
fgh' | node sparse_arrays.js
echo Results 2
cat results_sparse_arrays
echo

echo Input 3
echo '13
abcde
sdaklfj
asdjf
na
basdn
sdaklfj
asdjf
na
asdjf
na
basdn
sdaklfj
asdjf
5
abcde
sdaklfj
asdjf
na
basdn' | node sparse_arrays.js
echo Results 3
cat results_sparse_arrays
echo
#+end_src

*** Array Manipulation
:PROPERTIES:
:max-score: 60
:level:    hard
:success-rate: 51.96%
:score:    60
:END:
Perform ~m~ operations on an array and print the maximum of the values.
**** Array Manipulation Problem Statement
Starting with a 1-indexed array of zeros and a list of operations, for each
operation add a value to each of the array elements between two given indices,
inclusive.  Once all operations have been performed, return the maximum value
in your array.

For example, the length of your array of zeros ~n = 10~.  Your list of queries
is as follows:

#+begin_example
a b k
1 5 3
4 8 7
6 9 1
#+end_example

Add the values of ~k~ between the indices ~a~  and ~b~ inclusive:

#+begin_example
index->	 1 2 3  4  5 6 7 8 9 10
	[0,0,0, 0, 0,0,0,0,0, 0]
	[3,3,3, 3, 3,0,0,0,0, 0]
	[3,3,3,10,10,7,7,7,0, 0]
	[3,3,3,10,10,8,8,8,1, 0]
#+end_example

The largest value is ~10~ after all operations are performed.

{{{heading(Function Description)}}}

The first line contains two space-separated integers ~n~ and ~m~, the size of
the array and the number of operations.

Each of the next ~m~ lines contains three space-separated integers ~a~, ~b~ and
~k~, the left index, right index and summand.

{{{subheading(Sample Input)}}}

#+begin_example
5 3
1 2 100
2 5 100
3 4 100
#+end_example

{{{heading(Constraints)}}}

- 3 \le ~n~ \le 10^7

- 1 \le ~m~ \le 2 * 10^5

- 1 \le ~a~ \le ~b~ \le ~n~

- 0 \le ~k~ \le 10^9


{{{heading(Output Format)}}}

Return the integer maximum value in the finished array.

{{{subheading(Sample Output)}}}

: 200

{{{heading(Explanation)}}}

- After the first update list will be ~100 100 0 0 0~.

- After the second update list will be ~100 200 100 100 100~.

- After the third update list will be ~100 200 200 200 100~.

- The required answer will be ~200~.

**** Array Manipulation Node CL Processing
#+name:array-manipulation-node-process-cl
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/arrays/node/array_manipulation.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Array Manipulation Main Function
#+name:array-manipulation-main
#+begin_src js +n :tangle data-structures/arrays/node/array_manipulation.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const nm = readLine().split(' ');

    const n = parseInt(nm[0], 10);
    console.log(`n = ${n}`);

    const m = parseInt(nm[1], 10);
    console.log(`m = ${m}`);

    let queries = Array(m);

    for (let i = 0; i < m; i++) {
        queries[i] = readLine().split(' ').map(queriesTemp => parseInt(queriesTemp, 10));
        console.log(`query: ${queries[i]}`);
    }

    let result = arrayManipulation(n, queries);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

**** Array Manipulation Solution Code
#+name:array-manipulation-solution
#+begin_src js +n :tangle data-structures/arrays/node/array_manipulation.js
// Complete the arrayManipulation function below.
function arrayManipulation(n, queries) {
    const arr = Array(n);
    arr.fill(0);

    for (let [a, b, k] of queries) {
        arr[a-1] += k;
        if (b < n) arr[b] -= k;
    }

    let max = 0, x = 0;
    for (let i = 0; i < n; i++) {
        x += arr[i];
        if (x > max) max = x;
    }

    return max;
}
#+end_src

**** Array Manipulation Test Code
#+name:array-manipulation-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/arrays/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/arrays/node/array_manipulation.sh
export OUTPUT_PATH=results_array_manipulation
echo Input:
echo '5 3
1 2 100
2 5 100
3 4 100' | node array_manipulation.js
echo
echo Results:
cat results_array_manipulation
#+end_src

** Linked Lists
*** Print the Elements of a Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:score:    5
:success-rate: 96.67%
:END:
#+cindex:linked list
#+cindex:head node
If you're new to linked lists, this is a great exercise for learning about
them.  Given a pointer to the head node of a linked list, print its elements in
order, one element per line.  If the head pointer is null (indicating the list
is empty), don’t print anything.

{{{heading(Input Format)}}}

The first line of input contains ~n~, the number of elements in the linked
list.  The next ~n~ lines contain one element each, which are the elements of
the linked list.

*Note*: Do not read any input from stdin/console.  Complete the
~printLinkedList~ function in the editor below.

{{{subheading(Sample Input)}}}

#+begin_example
1
16
13
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the linked
  list.


{{{heading(Output Format)}}}

Print the integer data for each element of the linked list to stdout/console
(e.g.: using ~printf~, ~cout~, etc.).  There should be one element per line.

{{{subheading(Sample Output)}}}

#+begin_example
16
13
#+end_example

{{{heading(Explanation)}}}

There are two elements in the linked list.  They are represented as ~16 -> 13
-> NULL~.  So, the ~printLinkedList~ function should print 16 and 13 each in a
new line.

**** Print Linked List Node CL Processing
#+name:print-linked-list-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/print_linked_list.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Print Linked List Main Function
#+name:print-linked-list-main
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
function main() {
    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data = ${llistItem}`);
        llist.insertNode(llistItem);
    }

    printLinkedList(llist.head);
}
#+end_src

**** Print Linked List Node Classes
***** Singly Linked List Node Class
#+name:singly-linked-list-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};
#+end_src

***** Singly Linked List Class
#+name: singly-linked-list-class
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};
#+end_src

**** Print Linked List Solution
#+name:print-linked-list-printLinkedList
#+begin_src js +n :tangle data-structures/linked_lists/node/print_linked_list.js
// Complete the printLinkedList function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function printLinkedList(head) {
    if (!head) return;
    const data = head.data;
    const next = head.next;
    console.log(data);
    printLinkedList(next);
}
#+end_src

**** Print Linked List Test Data
#+name:print-linked-list-test
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/print_linked_list.test.sh
echo '2
16
13' | node print_linked_list.js
#+end_src

#+RESULTS: print-linked-list-test
: n = 2
: data = 16
: data = 13
: 16
: 13

*** Insert a Node at the Tail of Linked List
:PROPERTIES:
:max-score: 5
:level:    easy
:success-rate: 95.28%
:score:    5
:END:
#+cindex:linked list
#+cindex:head node
#+cindex:tail node
You are given the pointer to the head node of a linked list and an integer to
add to the list.  Create a new node with the given integer.  Insert this node
at the tail of the linked list and return the head node of the linked list
formed after inserting this new node.  The given head pointer may be null,
meaning that the initial list is empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode~
~insertAtTail(SinglyLinkedListNode head, int data)~ method.  It takes two
arguments: the head of the linked list and the integer to insert at tail.  You
should not read any input from the stdin/console.

The input is handled by code editor and is as follows:

- The first line contains an integer ~n~, denoting the elements of the linked
  list.

- The next ~n~ lines contain an integer each, denoting the elements that need
  to be inserted at tail.


{{{subheading(Sample Input)}}}

#+begin_example
5
141
302
164
530
474
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000


{{{heading(Output Format)}}}

Insert the new node at the tail and just return the head of the updated linked
list.  Do not print anything to stdout/console.  The output is handled by code
in the editor and is as follows:

- Print the elements of the linked list from head to tail, each in a new line.


{{{subheading(Sample Output)}}}

#+begin_example
141
302
164
530
474
#+end_example

{{{heading(Explanation)}}}

- First the linked list is NULL. After inserting 141, the list is 141 -> NULL.

- After inserting 302, the list is 141 -> 302 -> NULL.

- After inserting 164, the list is 141 -> 302 -> 164 -> NULL.

- After inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL.

- After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL,
  which is the final list.

**** Insert Node at Tail Node CL Processing
#+name:insert-node-at-tail-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_node_llist.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Insert Node at Tail Main
#+name:insert-node-at-tail-main
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data: ${llistItem}`);
    	const llist_head = insertNodeAtTail(llist.head, llistItem);
      	llist.head = llist_head;
    }

    printSinglyLinkedList(llist.head, '\n', ws);
    ws.write('\n');

    ws.end();
}
#+end_src

**** Insert Node at Tail Node Classes
***** Singly Linked List Node Class
#+name:insert-node-singly-linked-list-node
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Singly Linked List Class
#+name:insert-node-singly-linked-list
#+header: :noweb yes
#+begin_src +n :tangle data-structures/linked_lists/node/insert_node_llist.js
<<singly-linked-list-class>>
#+end_src

***** Print Singly Linked List
#+name:print-singly-linked-list
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
function printSinglyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}
#+end_src

**** Insert Node at Tail insertNodeAtTail
#+name:insert-node-at-tail-insertNodeAtTail
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_llist.js
// Complete the insertNodeAtTail function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function insertNodeAtTail(head, data) {
    const newNode = new SinglyLinkedListNode(data);
    if (head === null) {
        head = newNode;
    } else {
        let oldHead = head;
        while (oldHead.next !== null) {
            oldHead = oldHead.next
        }
        oldHead.next = newNode;
    }
    return head;
}
#+end_src

**** Insert Node at Tail Test
#+name:insert-node-at-tail-test
#+header: :results output :exports results
#+header: :dir data-structures/linked_lists/node
#+begin_src sh -n :tangle data-structures/linked_lists/node/insert_node_llist.test.sh
export OUTPUT_PATH=results_insert_node_llist
echo '5
141
302
164
530
474' | node insert_node_llist.js
echo
echo Results
cat results_insert_node_llist
#+end_src

*** Insert a Node at the Head of Linked List
:PROPERTIES:
:max-score: 5
:level:    easy
:success-rate: 98.50%
:END:
You’re given the pointer to the head node of a linked list and an integer to
add to the list.  Create a new node with the given integer, insert this node at
the head of the linked list and return the new head node.  The head pointer
given may be null meaning that the initial list is empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode Insert(SinglyLinkedListNode
head, int data)~ method which takes two arguments --- the head of the linked
list and the integer to insert.  You should NOT read any input from
stdin/console.

The input is handled by code in the editor and is as follows:

- The first line contains an integer ~n~, denoting the number of elements to be
  inserted at the head of the list.

- The next ~n~ lines contain an integer each, denoting the elements to be
  inserted.


{{{subheading(Sample Input)}}}

#+begin_example
5
383
484
392
975
321
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000


{{{heading(Output Format)}}}

Insert the new node at the head and return the head of the updated linked list.
Do NOT print anything to stdout/console.  The output is handled by the code in
the editor and it is as follows:

- Print the elements of linked list from head to tail, each in a new line.


{{{subheading(Sample Output)}}}

#+begin_example
321
975
392
484
383
#+end_example

{{{heading(Explanation)}}}

- Intially the list in NULL. After inserting 383, the list is 383 -> NULL.
- After inserting 484, the list is 484 -> 383 -> NULL.
- After inserting 392, the list is 392 -> 484 -> 383 -> NULL.
- After inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.
- After inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.

**** Insert Node at Head of Linked List Node CL Processing
#+name:insert-node-head-linked-list-node-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<node-process-command-line-arguments>>
#+end_src

**** Insert Node at Head of Linked List Classes
***** Insert Node at Head of Singly Linked List Node Class
#+name:insert-node-head-llist-node-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Insert Node at Head of Singly Linked List Class
#+name:insert-node-head-llist-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<singly-linked-list-class>>
#+end_src

***** Insert Node at Head of Singly Linked List Print Function
#+name:insert-node-head-llist-print
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
<<print-singly-linked-list>>
#+end_src

**** Insert Node at Head of Linked List Main Function
#+name:insert-node-head-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data: ${llistItem}`);
    	const llist_head = insertNodeAtHead(llist.head, llistItem);
      	llist.head = llist_head;
    }

    printSinglyLinkedList(llist.head, '\n', ws);
    ws.write('\n');

    ws.end();
}
#+end_src

**** insertNodeAtHead Function
#+name:insert-node-head-llist-insertNodeAtHead
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_head_llist.js
// Complete the insertNodeAtHead function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function insertNodeAtHead(head, data) {
    const newNode = new SinglyLinkedListNode(data);
    newNode.next = head;
    head = newNode;

    return head;
}
#+end_src

**** Insert Node at Head of Linked List Test
#+name:insert-node-head-llist-insert_head_llist.test.sj
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/insert_head_llist.test.sh
export OUTPUT_PATH=results_insert_head_llist
echo Input:
echo '5
383
484
392
975
321' | node insert_head_llist.js
echo
echo Results:
cat results_insert_head_llist
#+end_src
*** Delete a Node
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 97.22%
:END:
You’re given the pointer to the head node of a linked list and the position of
a node to delete.  Delete the node at the given position and return the head
node.  A position of 0 indicates head, a position of 1 indicates one node away
from the head and so on.  The list may become empty after you delete the node.

{{{heading(Input Format)}}}

You have to complete the ~deleteNode(SinglyLinkedListNode* llist, int
position)~ method which takes two arguments --- the head of the linked list and
the position of the node to delete.  You should NOT read any input from
stdin/console.  ~position~ will always be at least 0 and less than the number
of the elements in the list.

- The first line of input contains an integer ~n~, denoting the number of
  elements in the linked list.

- The next ~n~ lines contain an integer each in a new line, denoting the
  elements of the linked list in the order.

- The last line contains an integer ~position~ denoting the position of the
  node that has to be deleted form the linked list.


{{{subheading(Sample Input)}}}

#+begin_example
8
20
6
2
19
7
4
15
9
3
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 1000

- 1 \le ~list_i~ \le 1000, where ~list_i~ is the ~i^th~ element of the linked
  list


{{{heading(Output Format)}}}

Delete the node at the given position and return the head of the updated linked
list.  Do NOT print anything to stdout/console.  The code in the editor will
print the updated linked list in a single line separated by spaces.

{{{subheading(Sample Output)}}}

: 20 6 2 7 4 15 9

{{{heading(Explanation)}}}

The given linked list is =20->6->2->19->7->4->15->9=.  We have to delete the
node at ~position~ 3, which is 19.  After deleting that node, the updated
linked list is: =20->6->2->7->4->15->9=.

**** Delete a Node from a Linked List Node CL Processing
#+name:delete-node-llist-node-cl
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<node-process-command-line-arguments>>
#+end_src

**** Delete a Node from a Linked List Classes
***** Delete a Node Node Class
#+name:delete-node-llist-node-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<singly-linked-list-node-class>>
#+end_src

***** Delete a Node Class
#+name:delete-node-llist-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<singly-linked-list-class>>
#+end_src

***** Delete a Node Print a Linked List Function
#+name:delete-node-llist-print
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
<<print-singly-linked-list>>
#+end_src

**** Delete a Node from a Linked List Main Function
#+name:delete-node-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n = ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        llist.insertNode(llistItem);
        console.log(`data: ${llistItem}`);
    }

    const position = parseInt(readLine(), 10);
    console.log(`position = ${position}`);

    let llist1 = deleteNode(llist.head, position);

    printSinglyLinkedList(llist1, " ", ws)
    ws.write("\n");

    ws.end();
}
#+end_src

**** Delete a Node from a Linked List deleteNode Function
#+name:delete-node-llist-deleteNode
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_node_llist.js
// Complete the deleteNode function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function deleteNode(head, position) {
    let prior = null;
    let current = head;
    while (position--) {
        prior = current;
        current = current.next;
    }
    if (prior === null) head = current.next;
    else prior.next = current.next;
    return head;
}
#+end_src

**** Delete a Node from a Linked List Test
#+name:delete-node_llist_test
#+header: :shebang "#!/usr/bin/env bash" :results output :exports results
#+header: :dir data-structures/linked_lists/node
#+begin_src sh -n :tangle data-structures/linked_lists/node/delete_node_llist.test.sh
export OUTPUT_PATH=results_delete_llist
echo Input:
echo \
'8
20
6
2
19
7
4
15
9
3' | node delete_node_llist.js

echo
echo Results:
cat results_delete_llist
#+end_src

*** Print in Reverse
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 97.89%
  :score:    5
  :END:
You are given the pointer to the head node of a linked list and you need to
print all its elements in reverse order from tail to head, one element per
line.  The head pointer may be null meaning that the list is empty---in that
case, do not print anything!

{{{heading(Input Format)}}}

You have to complete the ~void reversePrint(SinglyLinkedListNode* head)~ method
which takes one argument---the head of the linked list.  You should NOT read any
input from stdin/console.

The first line of input contains ~t~, the number of test cases.

The input of each test case is as follows:

- The first line contains an integer ~n~, denoting the number of elements in
  the list.

- The next ~n~ lines contain one element each, denoting the elements of the
  linked list in the order.


{{{subheading(Sample Input)}}}

#+begin_example
3
5
16
12
4
2
5
3
7
3
9
5
5
1
18
3
13
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element in the list.


{{{heading(Output Format)}}}

Complete the ~reversePrint~ function in the editor below and print the elements
of the linked list in the reverse order, each in a new line.

{{{subheading(Sample Output)}}}

#+begin_example
5
2
4
12
16
9
3
7
13
3
18
1
5
#+end_example

{{{heading(Explanation)}}}

There are three test cases.

The first linked list has 5 elements: =16 -> 12 -> 4 -> 2 -> 5=.  Printing this
in reverse order will produce: =5 -> 2 -> 4 -> 12 -> 16=.

The second linked list has 3 elements: =7 -> 3 -> 9=.  Printing this in reverse
order will produce: =9 -> 3 -> 7=.

The third linked list has 5 elements: =5 -> 1 -> 18 -> 3 -> 13=.  Printing this
in reverse order will produce: =13 -> 3 -> 18 -> 1 -> 5=.

**** Print in Reverse Node CL Processing
#+name:print-in-reverse-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Print in Reverse Node Classes
***** Print in Reverse Linked List Node Class
#+name:print-in-reverse-linked-list-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};
#+end_src

***** Print in Reverse Linked List Class
#+name:print-in-reverse-linked-list-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};
#+end_src

***** Print in Reverse Linked List Print
#+name:print-in-reverse-linked-list-print
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
function printSinglyLinkedList(node, sep) {
    while (node != null) {
        process.stdout.write(String(node.data));

        node = node.next;

        if (node != null) {
            process.stdout.write(sep);
        }
    }
}
#+end_src

**** Print in Reverse Linked List Main Function
#+name:print-in-reverse-linked-list-main
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
function main() {
    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}\n`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`test: ${testsItr}`);
        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();
        console.log(`new list:`);

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data: ${llistItem}`);
            llist.insertNode(llistItem);
        }

        reversePrint(llist.head);
        console.log('');
    }
}
#+end_src

**** Print in Reverse Linked List reversePrint Function
#+name:print-in-reverse-linked-list-reversePrint
#+begin_src js +n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.js
// Complete the reversePrint function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function reversePrint(head) {
    if (head === null) return;
    reversePrint(head.next);
    console.log(head.data);
}
#+end_src

**** Print in Reverse Linked List Test
#+name:print-in-reverse-linked-list-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/reverseSinglyLinkedList.test.sh
echo \
'3
5
16
12
4
2
5
3
7
3
9
5
5
1
18
3
13' | node reverseSinglyLinkedList.js
#+end_src

*** Reverse a Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 98.04%
:END:
You’re given the pointer to the head node of a linked list.  Change the next
pointers of the nodes so that their order is reversed.  The head pointer given
may be null meaning that the initial list is empty.

**** Reverse a Linked List Problem Statement
{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode reverse(SinglyLinkedListNode
head)~ method which takes one argument---the head of the linked list.  You
should NOT read any input from stdin/console.

The input is handled by the code in the editor and the format is as follows:

- The first line contains an integer ~t~, denoting the number of test cases.

- Each test case is of the following format:

  - The first line contains an integer ~n~, denoting the number of elements in
    the linked list.

  - The next ~n~ lines contain an integer each, denoting the elements of the
    linked list.


{{{subheading(Sample Input)}}}

#+begin_example
1
5
1
2
3
4
5
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~t~ \le 10

- 1 \le ~n~ \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element in the list


{{{heading(Output Format)}}}

Change the next pointers of the nodes so that their order is reversed; return
the head of the reversed linked list.  Do NOT print anything to stdout/console.

The output is handled by the code in the editor.  The output format is as
follows:

- For each test case, print in a new line the elements of the linked list after
  reversing it, separated by spaces.


{{{subheading(Sample Output)}}}

: 5 4 3 2 1 

{{{heading(Explanation)}}}

The initial linked list is: =1 -> 2 -> 3 -> 4 -> 5 -> NULL=

The reversed linked list is: =5 -> 4 -> 3 -> 2 -> 1 -> NULL=

**** Reverse a Linked List Node CL Processing
#+name:reverse-llist-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/reverse_llist.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Reverse a Linked List Classes
***** Reverse a Linked List Node Class
#+name:reverse-llist-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
const SinglyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
    }
};
#+end_src

***** Reverse a Linked List Class
#+name:reverse-llist-class
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
const SinglyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        const node = new SinglyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
        }

        this.tail = node;
    }
};
#+end_src

***** Reverse a Linked List Print
#+name:reverse-llist-print
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
function printSinglyLinkedList(node, sep, ws) {
    while (node != null) {
        console.log(`write node: ${node.data}`);
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}
#+end_src

**** Reverse a Linked List Main Function
#+name:reverse-lliist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}\n`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`test: ${testsItr}`);
        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data: ${llistItem}`);
            llist.insertNode(llistItem);
        }

        let llist1 = reverse(llist.head);

        printSinglyLinkedList(llist1, " ", ws)
        ws.write("\n");
    }

    ws.end();
}
#+end_src

#+RESULTS: reverse-lliist-main

**** Reverse a Linked List reverse Function
#+name:reverse-llisi-reverse
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_llist.js
// Complete the reverse function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function reverse(head) {

    function rev(node) {
        if (node === null)
            return;
        rev(node.next);

        if (node.next === null)
            head = node;
        else {
            node.next.next = node;
            node.next = null;
        }
    }

    rev(head);
    return head;
}
#+end_src

**** Reverse a Linked List Test Function
#+name:reverse-llist-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node :results output :exports results
#+begin_src sh -n :tangle data-structures/linked_lists/node/reverse_llist.test.sh
export OUTPUT_PATH=reverse_llist_results
echo \
'1
5
1
2
3
4
5' | node reverse_llist.js
echo
echo 'Results:'
cat reverse_llist_results
#+end_src

#+RESULTS: reverse-llist-test
#+begin_example
tests: 1

test: 0
n: 5
data: 1
data: 2
data: 3
data: 4
data: 5
write node: 5
write node: 4
write node: 3
write node: 2
write node: 1

Results:
5 4 3 2 1
#+end_example

*** Compare Two Linked Lists
:PROPERTIES:
:level:    easy
:max-score: 5
:rate:     98.86%
:score:    5
:END:
**** Problem Statement
You’re given the pointer to the head nodes of two linked lists.  Compare the
data in the nodes of the linked lists to check if they are equal.  The lists
are equal only if they have the same number of nodes and corresponding nodes
contain the same data.  Either head pointer given may be null meaning that the
corresponding list is empty.

{{{heading(Input Format)}}}

You have to complete the ~int CompareLists(Node* headA, Node* headB)~ method
which takes two arguments---the heads of the two linked lists to compare.  You
should NOT read any input from stdin/console.

The input is handled by the code in the editor and the format is as follows:

- The first line contains ~t~, the number of test cases.  The format for each
  test case is as follows:

- The first line contains an integer ~n~, denoting the number of elements in
  the first linked list.

- The next ~n~ lines contain an integer each, denoting the elements of the
  first linked list.

- The next line contains an integer ~m~, denoting the number of elements in the
  second linked list.

- The next ~m~ lines contain an integer each, denoting the elements of the
  second linked list.


{{{subheading(Sample Input)}}}

#+begin_example
2
2
1
2
1
1
2
1
2
2
1
2
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element in the list


{{{heading(Output Format)}}}

Compare the two linked lists and return 1 if the lists are equal.  Otherwise,
return 0.  Do NOT print anything to stdout/console.  The output is handled by
the code in the editor and it is as follows:

- For each test case, in a new line, print 1 if the two lists are equal, else
  print 0.


{{{heading(Sample Output)}}}

#+begin_example
0
1
#+end_example

{{{heading(Explanation)}}}

In the first case, linked lists are: =1 -> 2 -> NULL= and =1 -> NULL=

In the second case, linked lists are: =1 -> 2 -> NULL= and =1 -> 2 -> NULL=

**** Compare Linked Lists Node CL Processing
#+name:compare-llists-node-cl-processing
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/compareLLists.js :mkdirp yes
<<node-process-command-line-arguments>>
#+end_src

**** Compare Linked Lists Classes
***** Compare Linked Lists Node Class
#+name:compare-llist-node-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
<<singly-linked-list-node-class>>
#+end_src

***** Compare Linked Lists Class
#+name:compare-llist-class
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
<<singly-linked-list-class>>
#+end_src

***** Compare Linked Lists Print Function
#+name:compare-llist-print-function
#+header: :noweb yes
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
<<print-singly-linked-list>>
#+end_src

**** Compare Linked Lists Main Function
#+name:compare-llist-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
  function main() {
      const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

      const tests = parseInt(readLine(), 10);
      console.log(`number of tests t = ${tests}`);

      for (let testsItr = 0; testsItr < tests; testsItr++) {
          console.log(`\ntest: ${testsItr}`);

          const llist1Count = parseInt(readLine(), 10);
          console.log(`n: ${llist1Count}`);

          let llist1 = new SinglyLinkedList();

          for (let i = 0; i < llist1Count; i++) {
              const llist1Item = parseInt(readLine(), 10);
              console.log(`data: ${llist1Item}`);
              llist1.insertNode(llist1Item);
          }

          const llist2Count = parseInt(readLine(), 10);
          console.log(`m: ${llist2Count}`);

          let llist2 = new SinglyLinkedList();

          for (let i = 0; i < llist2Count; i++) {
              const llist2Item = parseInt(readLine(), 10);
              console.log(`data: ${llist2Item}`);
              llist2.insertNode(llist2Item);
          }

          let result = CompareLists(llist1.head, llist2.head);
          console.log(`result: ${result}`);

          ws.write((result ? 1 : 0) + "\n");
      }

      ws.end();
  }
#+end_src

**** Compare Linked Lists compareLists Function
#+name:compare-llists-compareLists-function
#+begin_src js +n :tangle data-structures/linked_lists/node/compareLLists.js
  // Complete the CompareLists function below.

  /*
   ,* For your reference:
   ,*
   ,* SinglyLinkedListNode {
   ,*     int data;
   ,*     SinglyLinkedListNode next;
   ,* }
   ,*
   ,*/
  function CompareLists(llist1, llist2) {
      if (llist1 === null && llist2 === null)
          return 1;
      if (llist1 == null || llist2 == null)
          return 0;
      if (llist1.data !== llist2.data)
          return 0;
      return CompareLists(llist1.next, llist2.next);
  }
#+end_src

**** Compare Linked Lists Tests
#+name:compare-llists-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/compareLLists.tests.sh
export OUTPUT_PATH=compare-llists-results
echo Inputs
echo \
'2
2
1
2
1
1
2
1
2
2
1
2' | node compareLLists.js
echo
echo Results
cat compare-llists-results
#+end_src

#+RESULTS: compare-llists-tests
#+begin_example
Inputs
number of tests t = 2

test: 0
n: 2
data: 1
data: 2
m: 1
data: 1
result: 0

test: 1
n: 2
data: 1
data: 2
m: 2
data: 1
data: 2
result: 1

Results
0
1
#+end_example
*** Insert a Node at a Specific Position in a Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 96.38%
:score:    5
:cummulative-points: 185
:current-rank: 412511
:END:
**** Insert Node at a Set Position in a LList Problem Statement
You’re given the pointer to the head node of a linked list, an integer to add
to the list and the position at which the integer must be inserted.  Create a
new node with the given integer, insert this node at the desired position and
return the head node.

A position of 0 indicates head; a position of 1 indicates one node away from
the head, and so on.  The head pointer given may be null, meaning that the
initial list is empty.

As an example, if your list starts as =1->2->3= and you want to insert a node
at position 2 with data = 4, your new list should be =1->2-4->3=.

{{{heading(Function Description)}}}

Complete the function ~insertNodeAtPosition~ in the editor below.  It must
return a reference to the head node of your finished list.

~insertNodeAtPosition~ has the following parameters:

- =head=: a ~SinglyLinkedListNode~ pointer to the head of the list

- =data=: an integer value to insert as data in your new node

- =position=: an integer position to insert the new node, zero based indexing


{{{heading(Input Format)}}}

The first line contains an integer ~n~, the number of elements in the linked
list.

Each of the next ~n~ lines contains an integer ~SinglyLinkedListNode[i].data~.

The last line contains an integer ~posittion~.

{{{subheading(Sample Input)}}}

#+begin_example
3
16
13
7
1
2
#+end_example

{{{heading(Constraints)}}}

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the linked list

- 0 \le position \le n


{{{heading(Output Format)}}}

Return a reference to the list head.  Locked code prints the list for you.

{{{subheading(Sample Output)}}}

: 16 13 1 7

{{{heading(Explanation)}}}

The initial linked list is =16 13 7=.  We have to insert 1 at the position 2
which currently has 7 in it.  The updated linked list will be =16 13 1 7=.

**** Insert Node at a Set Position in a LList Node CL Processing and Classes
#+name:insert-node-set-pos-llist-node-cl-classes
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_node_pos_llist.js :mkdirp yes
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Insert Node at a Set Position in a LList Main Function
#+name:insert-node-set-pos-llist-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_pos_llist.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const llistCount = parseInt(readLine(), 10);
    console.log(`n: ${llistCount}`);

    let llist = new SinglyLinkedList();

    for (let i = 0; i < llistCount; i++) {
        const llistItem = parseInt(readLine(), 10);
        console.log(`data: ${llistItem}`);
        llist.insertNode(llistItem);
    }

    const data = parseInt(readLine(), 10);
    console.log(`data to insert: ${data}`);

    const position = parseInt(readLine(), 10);
    console.log(`at position: ${position}`);

    let llist_head = insertNodeAtPosition(llist.head, data, position);

    printSinglyLinkedList(llist_head, " ", ws)
    ws.write("\n");

    ws.end();
}
#+end_src

**** Insert Node at a Set Position in a LList insertNodeAtPosition Function
#+name:insert-node-set-pos-llist-insertNodeAtPosition-function
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_node_pos_llist.js
// Complete the insertNodeAtPosition function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function insertNodeAtPosition(head, data, position) {
    const node = new SinglyLinkedListNode(data);
    if (head === null) {
        head = node;
        return head;
    }

    let prior = null;
    let current = head;
    let pos = 0;
    while (current !== null && pos++ < position) {
        prior = current
        current = current.next;
    }
    node.next = current;
    prior.next = node;
    return head;
}
#+end_src

**** Insert Node at a Set Position in a LList Test
#+name:insert-node-set-pos-llist-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/insert_node_pos_llist.test.sh
export OUTPUT_PATH=insert-node-pos-results
echo Inputs:
echo \
'3
16
13
7
1
2' | node insert_node_pos_llist.js
echo
echo Results
cat insert-node-pos-results
#+end_src

#+RESULTS: insert-node-set-pos-llist-test
#+begin_example
Inputs:
n: 3
data: 16
data: 13
data: 7
data to insert: 1
at position: 2

Results
16 13 1 7
#+end_example

*** Merge Two Sorted Linked Lists
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 95.40%
:score:    5
:current-rank: 404494
:END:
Given the heads of two sorted linked lists, change their links to get a single
sorted linked list.

**** Merge Two Sorted Linked Lists Problem Statement
You’re given the pointer to the head nodes of two sorted linked lists.  The
data in both lists will be sorted in ascending order.  Change the next pointers
to obtain a single, merged linked list which also has data in ascending order.
Either head pointer given may be null meaning that the corresponding list is
empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode MergeLists(SinglyLinkedListNode
headA, SinglyLinkedListNode headB)~ method which takes two arguments---the
heads of the two sorted linked lists to merge.  You should NOT read any input
from stdin/console.

The input is handled by the code in the editor and the format is as follows:

- The first line contains an integer ~t~, denoting the number of test cases.


The format for each test case is as follows:

- The first line contains an integer ~n~, denoting the length of the first
  linked list.

- The next ~n~ lines contain an integer each, denoting the elements of the
  linked list.

- The next line contains an integer ~m~, denoting the length of the second
  linked list.

- The next ~m~ lines contain an integer each, denoting the elements of the
  second linked list.


{{{subheading(Sample Input)}}}

#+begin_example
1
3
1
2
3
2
3
4
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the list.


{{{heading(Output Format)}}}

Change the next pointer of individual nodes so that nodes from both lists are
merged into a single list.  Then return the head of this merged list.  Do NOT
print anything to stdout/console.

The output is handled by the editor and the format is as follows:

- For each test case, print in a new line, the linked list after merging them
  separated by spaces.


{{{subheading(Sample Output)}}}

: 1 2 3 3 4

{{{heading(Explanation)}}}

The first linked list is: =1 -> 2 -> 3 -> NULL=

The second linked list is: =3 -> 4 -> NULL=

Hence, the merged linked list is: =1 -> 2 -> 3 -> 3 -> 4 -> NULL=

**** Merge Two Sorted Linked Lists Node CL Processing and Classes
#+name:merge-two-sorted-llists-node-cl-processing-and-classes
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/merge_2_sorted_llists.js :mkdirp yes
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Merge Two Sorted Linked Lists Main Function
#+name:merge-two-sorted-llists-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/merge_2_sorted_llists.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`t: ${tests}`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        const llist1Count = parseInt(readLine(), 10);
        console.log(`n: ${llist1Count}`);

        let llist1 = new SinglyLinkedList();

        for (let i = 0; i < llist1Count; i++) {
            const llist1Item = parseInt(readLine(), 10);
            console.log(`data: ${llist1Item}`);
            llist1.insertNode(llist1Item);
        }

      	const llist2Count = parseInt(readLine(), 10);
        console.log(`m: ${llist2Count}`);

        let llist2 = new SinglyLinkedList();

        for (let i = 0; i < llist2Count; i++) {
            const llist2Item = parseInt(readLine(), 10);
            console.log(`data: ${llist2Item}`);
            llist2.insertNode(llist2Item);
        }

        let llist3 = mergeLists(llist1.head, llist2.head);

        printSinglyLinkedList(llist3, " ", ws)
        ws.write("\n");
    }

    ws.end();
}
#+end_src

**** Merge Two Sorted Linked Lists mergeLists Function
#+name:merge-two-sorted-llists-mergeLists-function
#+begin_src js +n :tangle data-structures/linked_lists/node/merge_2_sorted_llists.js
// Complete the mergeLists function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function mergeLists(head1, head2) {
    if (head1 === null || head2 === null) {
        return (head1 === null) ? head2 : head1;
    }

    let current1 = head1,
        current2 = head2,
        head,
        prior;

    if (head1.data <= head2.data)
        head = head1,
        current1 = current1.next;
    else
        head = head2,
        current2 = current2.next;
    prior = head;

    while (current1 !== null && current2 !== null) {
        if (current1.data <= current2.data)
            prior.next = current1,
            current1 = current1.next;
        else
            prior.next = current2,
            current2 = current2.next;

        prior = prior.next;
    }

    prior.next = (current1 === null) ? current2 : current1;

    return head;
}
#+end_src

**** Merge Two Sorted Linked Lists Test
#+name:merge-two-sorted-llists-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/merge_2_sorted_llists.test.sh
export OUTPUT_PATH=merge-2-sorted-llists-results
echo Inputs:
echo \
'1
3
1
2
3
2
3
4' | node merge_2_sorted_llists.js
echo
echo Results
cat merge-2-sorted-llists-results
#+end_src

#+RESULTS: merge-two-sorted-llists-test
#+begin_example
Inputs:
t: 1
n: 3
data: 1
data: 2
data: 3
m: 2
data: 3
data: 4

Results
1 2 3 3 4
#+end_example

*** Get Node Value
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 98.81%
:score:    5
:current-rank: 397294
:current-score: 195
:END:
Given the head of a linked list, get the value of the node at a given position
when counting backwards from the tail.

**** Get Node Value Problem Statement
You’re given the pointer to the head node of a linked list and a specific
position.  Counting backwards from the tail node of the linked list, get the
value of the node at the given position.  A position of 0 corresponds to the
tail, 1 corresponds to the node before the tail and so on.

{{{heading(Input Format)}}}

You have to complete the ~int getNode(SinglyLinkedListNode* head, int
positionFromTail)~ method which takes two arguments---the head of the linked
list and the position of the node from the tail.  ~positionFromTail~ will be at
least 0 and less than the number of nodes in the list.  You should NOT read any
input from stdin/console.

The first line will contain an integer ~t~, the number of test cases.

Each test case has the following format:

- The first line contains an integer ~n~, the number of elements in the linked
  list.

- The next ~n~ lines contains, an element each denoting the element of the
  linked list.

- The last line contains an integer ~positionFromTail~ denoting the position
  from the tail, whose value needs to be found out and returned.


{{{subheading(Sample Input)}}}

#+begin_example
2
1
1
0
3
3
2
1
2
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le list_i \le 1000, where list_i is the i^th element of the linked list

- 0 \le positionFromTail \lt n


{{{heading(Output Format)}}}

Find the node at the given position counting backwards from the tail.  Then
return the data contained in this node.  Do NOT print anything to
stdout/console.  The code in the editor handles output.

For each test case, print the value of the node, each in a new line.

{{{subheading(Sample Output)}}}

#+begin_example
1
3
#+end_example

{{{heading(Explanation)}}}

In first case, there is one element in linked list with value 1.  Hence, last
element is 1.

In second case, there are 3 elements with values 3, 2 and 1 (=3 -> 2 -> 1=).
Hence, element with position of 2 from tail is 3.

**** Get Node Value Node CL Processing and Classes
#+name:get-node-value-node-cl-processing-and-classes
#+header: :noweb yes
#+begin_src js -n :tangle data-structures/linked_lists/node/get_node_value.js :mkdirp yes
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Get Node Value Main Function
#+name:get-node-value-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/get_node_value.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`\ntest: ${testsItr}`);
        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data: ${llistItem}`);
            llist.insertNode(llistItem);
        }

        const position = parseInt(readLine(), 10);
        console.log(`find data at position: ${position}`);

        let result = getNode(llist.head, position);

        ws.write(result + "\n");
    }

    ws.end();
}
#+end_src

**** Get Node Value getNode Function
#+name:get-node-value-getNode-function
#+begin_src js +n :tangle data-structures/linked_lists/node/get_node_value.js
  // Complete the getNode function below.

  /*
   ,* For your reference:
   ,*
   ,* SinglyLinkedListNode {
   ,*     int data;
   ,*     SinglyLinkedListNode next;
   ,* }
   ,*
   ,*/
  function getNode(head, positionFromTail) {
      let n = 0,
          pos = 0,
          current = head,
          node = head;

      while (current.next !== null) {
          if (n - pos === positionFromTail)
              node = node.next, pos++;
          current = current.next, n++;
      }
      return node.data;
  }
#+end_src

**** Get node Value Tests
#+name:get-node-value-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/get_node_value.test.sh
export OUTPUT_PATH=get-node-value-results
echo Inputs:
echo \
'2
1
1
0
3
3
2
1
2' | node get_node_value.js
echo
echo Results:
cat get-node-value-results
#+end_src

#+RESULTS: get-node-value-tests
: Inputs:
: tests: 2
: 
: test: 0
: n: 1
: data: 1
: find data at position: 0
: 
: Results:

*** Delete Duplicate Value Nodes from a Sorted Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 98.36%
:score:    5
:current-rank: 390303
:END:
Given a linked list whose nodes have data in ascending order, delete some nodes
so that no value occurs more than once.

**** Delete Duplicate Value Nodes Problem Statement
You're given the pointer to the head node of a sorted linked list, where the
data in the nodes is in ascending order.  Delete as few nodes as possible so
that the list does not contain any value more than once.  The given head
pointer may be null indicating that the list is empty.

{{{heading(Input Format)}}}

You have to complete the ~SinglyLinkedListNode*
removeDuplicates(SinglyLinkedListNode* head)~ method which takes one
argument---the head of the sorted linked list.  You should NOT read any input
from stdin/console.

The input is handled by the code in the editor and the format is as follows:

- The first line contains an integer ~t~, denoting the number of test
  cases.  The format for each test case is as follows:

- The first line contains an integer ~n~, denoting the number of elements in
  the linked list.

- The next ~n~ lines contain an integer each, denoting the elements of the
  linked list.


{{{subheading(Sample Input)}}}

#+begin_example
1
5
1
2
2
3
4
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le list_i \le 1000


{{{heading(Output Format)}}}

Delete as few nodes as possible to ensure that no two nodes have the same data.
Adjust the next pointers to ensure that the remaining nodes form a single
sorted linked list.  Then return the head of the sorted updated linked list.
Do NOT print anything to stdout/console.  The output is handled by the code in
the editor and the format is as follows:

- For each test case, print in a new line, the data of the linked list after
  removing the duplicates separated by space.


{{{subheading(Sample Output)}}}

: 1 2 3 4

{{{heading(Explanation)}}}

The initial linked list is: =1 -> 2 -> 2 -> 3 -> 4 -> NULL=

The final linked list is: =1 -> 2 -> 3 -> 4 -> NULL=

**** Delete Duplicate Value Nodes Node CL Processing and Classes
#+name:delete-duplicate-value-nodes-node-cl-processing-and-classes
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/delete_duplicate_value_nodes.js
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Delete Duplicate Value Nodes Main Funtion
#+name:delete-duplicate-value-nodes-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_duplicate_value_nodes.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const t = parseInt(readLine(), 10);
    console.log(`tests: ${t}`);

    for (let tItr = 0; tItr < t; tItr++) {
        console.log(`\ntest: ${tItr}`);
        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data: ${llistItem}`);
            llist.insertNode(llistItem);
        }

        let llist1 = removeDuplicates(llist.head);

        printSinglyLinkedList(llist1, " ", ws)
        ws.write("\n");
    }

    ws.end();
}
#+end_src

**** Delete Duplicate Value Nodes removeDuplicates Function
#+name:delete-duplicate-value-nodes-removeDuplicates-function
#+begin_src js +n :tangle data-structures/linked_lists/node/delete_duplicate_value_nodes.js
// Complete the removeDuplicates function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function removeDuplicates(head) {
    if (head === null)
        return null;

    let current = head.next,
        prior = head,
        data = head.data;

    while (current !== null) {
        if (current.data === data)
            prior.next = current.next;
        else
            data = current.data,
            prior = current;

        current = current.next;
    }
    return head;
}

#+end_src

**** Delete Duplicate Value Nodes Tests
#+name:delete-duplicate-value-nodes-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/delete_duplicate_value_nodes.test.sh
export OUTPUT_PATH=delete-duplicate-results
echo Inputs:
echo \
'2
5
1
2
2
3
4
3
1
1
1' | node delete_duplicate_value_nodes.js
echo
echo Results:
cat delete-duplicate-results
#+end_src

*** Cycle Detection
:PROPERTIES:
:level:    medium
:max-score: 5
:success-rate: 98.80%
:END:
Given a pointer to the head of a linked list, determine whether the linked list
loops back on itself.
**** Cycle Detection Problem Statement
A linked list is said to contain a cycle if any node is visited more than once
while traversing the list.

Complete the function provided for you in your editor.  It has one parameter: a
pointer to a Node object named =head= that points to the head of a linked list.
Your function must return a boolean denoting whether or not there is a cycle in
the list.  If there is a cycle, return =true=; otherwise, return =false=.

*Note*: If the list is empty, =head= will be =null=.

{{{heading(Input Format)}}}

Our hidden code checker passes the appropriate argument to your function. You
are not responsible for reading any input from stdin.

{{{subheading(Sample Input)}}}

: 1 -> Null

: 1 => 2 -> 3 |
:      ^<-----v

{{{heading(Constraints)}}}

- 0 \le list size \le 1000

{{{heading(Output Format)}}}

If the list contains a cycle, your function must return =true=.  If the list
does not contain a cycle, it must return =false=.  The binary integer
corresponding to the boolean value returned by your function is printed to
stdout by our hidden code checker.

{{{subheading(Sample Output)}}}

: 0
: 1

{{{heading(Explanation)}}}

1. The first list has no cycle, so we return =false= and the hidden code
   checker prints 0 to stdout.

2. The second list has a cycle, so we return =true= and the hidden code checker
   prints 1 to stdout.

**** Cycle Detection Node CL Process and Classes
#+name:cycle-detection-node-cl-processing-and-classes
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/cycleDetection.js
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Cycle Detection Main Function
#+name:cycle-detection-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/cycleDetection.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`\ntest: ${testsItr}`);

        const index = parseInt(readLine(), 10);
        console.log(`index: ${index}`);

        const llistCount = parseInt(readLine(), 10);
        console.log(`n: ${llistCount}`);

        let llist = new SinglyLinkedList();

        for (let i = 0; i < llistCount; i++) {
            const llistItem = parseInt(readLine(), 10);
            console.log(`data ${i}: ${llistItem}`);
            llist.insertNode(llistItem);
        }

      	let extra = new SinglyLinkedListNode(-1);
        let temp = llist.head;

        console.log(`starting indexing loop; index is ${index}; temp is ${temp.data}`);
        for (let i = 0; i < llistCount; i++) {
            console.log(`i: ${i}`);
            if (i == index) {
            	extra = temp;
                console.log(`extra is now temp: ${extra.data}`);
            }

            if (i != llistCount-1) {
            	temp = temp.next;
                console.log(`temp is now ${temp.data}`);
            }
        }

        temp.next = extra;
        console.log(`temp.next.data is ${temp.next.data}`);

        let result = hasCycle(llist.head);

        ws.write((result ? 1 : 0) + "\n");
    }

    ws.end();
}
#+end_src

**** Cycle Detection hasCycle Function
#+name:cycle-detection-hasCycle-Function
#+begin_src js +n :tangle data-structures/linked_lists/node/cycleDetection.js
// Complete the hasCycle function below.

/*
 ,* For your reference:
 ,*
 ,* SinglyLinkedListNode {
 ,*     int data;
 ,*     SinglyLinkedListNode next;
 ,* }
 ,*
 ,*/
function hasCycle(head) {
    if (head === null)
        return false;

    let fast = head,
        slow = head;

    while (fast.next !== null && fast.next.next !== null) {
        fast = fast.next.next,
        slow = slow.next;

        if (slow == fast)
            return true;
    }
    return false;
}
#+end_src

**** Cycle Detection Test
#+name:cycle-detection-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/cycleDetection.test.sh
export OUTPUT_PATH=cycle-detection-results
echo Inputs
echo \
'2
3
3
0
1
2
1
3
3
4
5' | node cycleDetection.js
echo
echo Results
cat cycle-detection-results
#+end_src
*** Find Merge Point of Two Lists
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 94.82%
:score:    5
:current-rank: 381747
:current-score: 205
:END:
**** Find Merge Point Problem Statement
Given pointers to the head nodes of linked lists that merge together at some
point, find the Node where the two lists merge.  It is guaranteed that the two
head Nodes will be different, and neither will be =NULL=.

In the diagram below, the two lists converge at Node ~x~:

#+begin_example
[List #1] a--->b--->c
                     \
                      x--->y--->z--->NULL
                     /
     [List #2] p--->q
#+end_example

Complete the ~int findMergeNode(SinglyLinkedListNode* head1,
SinglyLinkedListNode* head2)~ method so that it finds and returns the data
value of the Node where the two lists merge.

{{{heading(Input Format)}}}

Do not read any input from stdin/console.

The ~findMergeNode(SinglyLinkedListNode,SinglyLinkedListNode)~ method has two
parameters, ~head1~ and ~head2~, which are the non-null head Nodes of two
separate linked lists that are guaranteed to converge.

{{{subheading(Sample Input)}}}

The diagrams below are graphical representations of the lists that input Nodes
~headA~ and ~headB~ are connected to.  Recall that this is a method-only
challenge; the method only has initial visibility to those Nodes and must
explore the rest of the Nodes using some algorithm of your own design.

Test Case 0:

#+begin_example
 1
  \
   2--->3--->NULL
  /
 1
#+end_example

Test Case 1:

#+begin_example
1--->2
      \
       3--->Null
      /
     1
#+end_example

{{{heading(Constraints)}}}

- The lists will merge.

- ~head1~, ~head2! \ne =null=

- ~head1~ \ne ~head2~


{{{heading(Output Format)}}}

Do not write any output to stdout/console.

Each Node has a data field containing an integer.  Return the integer data for
the Node where the two lists merge.

{{{subheading(Sample Output)}}}

#+begin_example
2
3
#+end_example

{{{heading(Explanation)}}}

- Test Case 0: As demonstrated in the diagram above, the merge Node's data
  field contains the integer 2.

- Test Case 1: As demonstrated in the diagram above, the merge Node's data
  field contains the integer 3.

**** Find Merge Point Node CL Processing and Classes
#+name:find-merge-point-node-cl-processing-and-classes
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/find_merge_point.js
<<node-process-command-line-arguments>>
<<singly-linked-list-node-class>>
<<singly-linked-list-class>>
<<print-singly-linked-list>>
#+end_src

**** Find Merge Point Main Function
#+name:find-merge-point-node-main-function
#+begin_src js +n :tangle data-structures/linked_lists/node/find_merge_point.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const tests = parseInt(readLine(), 10);
    console.log(`tests: ${tests}`);

    for (let testsItr = 0; testsItr < tests; testsItr++) {
        console.log(`\ntest # ${testsItr}`);
        const index = parseInt(readLine(), 10);
        console.log(`index: ${index}`);

        const llist1Count = parseInt(readLine(), 10);
        console.log(`n: ${llist1Count}`);

        let llist1 = new SinglyLinkedList();

        for (let i = 0; i < llist1Count; i++) {
            const llist1Item = parseInt(readLine(), 10);
            console.log(`data[${i}]: ${llist1Item}`);
            llist1.insertNode(llist1Item);
        }

      	const llist2Count = parseInt(readLine(), 10);
        console.log(`m: ${llist2Count}`);

        let llist2 = new SinglyLinkedList();

        for (let i = 0; i < llist2Count; i++) {
            const llist2Item = parseInt(readLine(), 10);
            console.log(`data[${i}]: ${llist2Item}`);
            llist2.insertNode(llist2Item);
        }

      	let ptr1 = llist1.head;
        let ptr2 = llist2.head;

        for (let i = 0; i < llist1Count; i++) {
          if (i < index) {
            ptr1 = ptr1.next;
          }
        }

        for (let i = 0; i < llist2Count; i++) {
          if (i != llist2Count-1) {
            ptr2 = ptr2.next;
          }
        }

        ptr2.next = ptr1;

        let result = findMergeNode(llist1.head, llist2.head);

        ws.write(result + "\n");
    }

    ws.end();
}
#+end_src

**** Find Merge Point findMergeNode Function
Treat this similarly to detecting a cycle: repeatedly cycle through the two
nodes until their =next= pointers point to the same node.

#+name:find-merge-point-findMergeNode-function
#+begin_src js +n :tangle data-structures/linked_lists/node/find_merge_point.js
/*
    Find merge point of two linked lists
    Note that the head may be 'null' for the empty list.
    Node is defined as
    var Node = function(data) {
        this.data = data;
        this.next = null;
    }
*/

// This is a "method-only" submission.
// You only need to complete this method.

function findMergeNode(headA, headB) {

    let nodeA = headA,
        nodeB = headB,
        nextA, nextB;

    while (true) {
        nextA = nodeA.next === null ? headA : nodeA.next;
        nextB = nodeB.next === null ? headB : nodeB.next;

        if (nextA == nextB)
            return nextA.data;

        nodeA = nextA,
        nodeB = nextB;
    }

}
#+end_src

**** Find Merge Point Tests
#+name:find-merge-point-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/find_merge_point.test.sh
export OUTPUT_PATH=find-merge-point-results
echo Inputs:
echo \
'3
1
3
1
2
3
1
1
2
3
1
2
3
1
1
6
9
1
2
3
4
5
6
7
8
9
6
11
12
13
14
15
16' | node find_merge_point.js
echo
echo Results:
cat find-merge-point-results
#+end_src
*** Inserting a Node Into a Sorted Doubly Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 93.17%
:score:    5
:current-rank: 374277
:current-score: 210
:END:
**** Insert Node Sorted Doubly LList Problem Statement
Given a reference to the head of a doubly-linked list and an integer, ~data~,
create a new ~DoublyLinkedListNode~ object having data value ~data~ and insert
it into a sorted linked list while maintaining the sort.

{{{heading(Function Description)}}}

Complete the ~sortedInsert~ function in the editor below.  It must return a
reference to the head of your modified ~DoublyLinkedList~.

~sortedInsert~ has two parameters:

1. ~head~: A reference to the head of a doubly-linked list of
   ~DoublyLinkedListNode~ objects.

2. ~data~: An integer denoting the value of the ~data~ field for the
   ~DoublyLinkedListNode~ you must insert into the list.


*Note*: Recall that an empty list (i.e., where ~head~ \eq =null=) and a list
with one element are sorted lists.

{{{heading(Input Format)}}}

The first line contains an integer ~t~, the number of test cases.

Each of the test case is in the following format:

- The first line contains an integer ~n~, the number of elements in the linked
  list.

- Each of the next ~n~ lines contains an integer, the data for each node of the
  linked list.

- The last line contains an integer ~data~ which needs to be inserted into the
  sorted doubly-linked list.


{{{subheading(Sample Input)}}}

#+begin_example
1
4
1
3
4
10
5
#+end_example


{{{heading(Constraints)}}}

- 1 \le t \le 10

- 1 \le n \le 1000

- 1 \le data \le 1000


{{{heading(Output Format)}}}

*Do not print anything to stdout*.  Your method must return a reference to the
~head~ of the same list that was passed to it as a parameter.  The ouput is
handled by the code in the editor and is as follows:

For each test case, print the elements of the sorted doubly-linked list
separated by spaces on a new line.

{{{subheading(Sample Output)}}}

: 1 3 4 5 10

{{{heading(Explanation)}}}

The initial doubly linked list is: 1 \leftrightarrow 3 \leftrightarrow 4 \leftrightarrow 10 \rightarrow null.

The doubly linked list after insertion is: 1 \leftrightarrow 3 \leftrightarrow 4 \leftrightarrow 5 \leftrightarrow 10 \rightarrow null.

**** Insert Node Sorted Doubly LList Node CL Processing
#+name:insert-node-sorted-doubly-llist-node-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
<<node-process-command-line-arguments>>
#+end_src

**** Insert Node Sorted Doubly LList Classes
***** Sorted Doubly Linked List Node Class
#+name:doubly-llist-node-class
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
const DoublyLinkedListNode = class {
    constructor(nodeData) {
        this.data = nodeData;
        this.next = null;
        this.prev = null;
    }
};
#+end_src

***** Sorted Doubly Linked List Class
#+name:doubly-llist-class
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
const DoublyLinkedList = class {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    insertNode(nodeData) {
        let node = new DoublyLinkedListNode(nodeData);

        if (this.head == null) {
            this.head = node;
        } else {
            this.tail.next = node;
            node.prev = this.tail;
        }

        this.tail = node;
    }
};
#+end_src

***** Sorted Doubly Linked List Print Function
#+name:doubly-llist-print-function
#+begin_src +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
function printDoublyLinkedList(node, sep, ws) {
    while (node != null) {
        ws.write(String(node.data));

        node = node.next;

        if (node != null) {
            ws.write(sep);
        }
    }
}
#+end_src

**** Insert Node Sorted Doubly LList Main Function
#+name:insert-node-sorted-doubly-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
  function main() {
      const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

      const t = parseInt(readLine(), 10);
      console.log(`tests: ${t}`);

      for (let tItr = 0; tItr < t; tItr++) {
          const llistCount = parseInt(readLine(), 10);
          console.log(`n: ${llistCount}`);

          let llist = new DoublyLinkedList();

          for (let i = 0; i < llistCount; i++) {
              const llistItem = parseInt(readLine(), 10);
              console.log(`data[${i}]: ${llistItem}`);
              llist.insertNode(llistItem);
          }

          const data = parseInt(readLine(), 10);
          console.log(`data to insert: ${data}`);

          let llist1 = sortedInsert(llist.head, data);

          printDoublyLinkedList(llist1, " ", ws);
          ws.write("\n");
      }

      ws.end();
  }
#+end_src

**** Insert Node Sorted Doubly LList sortedInsert Function
#+name:insert-node-sorted-doubly-llist-sortedInsert
#+begin_src js +n :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.js
  // Complete the sortedInsert function below.

  /*
   ,* For your reference:
   ,*
   ,* DoublyLinkedListNode {
   ,*     int data;
   ,*     DoublyLinkedListNode next;
   ,*     DoublyLinkedListNode prev;
   ,* }
   ,*
   ,*/
  function sortedInsert(head, data) {
      const node = new DoublyLinkedListNode(data);

      if (head === null)
          return node;

      let current = head;

      while (current.data < data && current.next !== null) {
          current = current.next;
      }

      if (current.data < data) {
          current.next = node;
          node.prev = current;
          return head;
      }

      if (current.prev === null) {
          head = node;
          node.next = current;
          return head;
      }

      node.prev = current.prev;
      node.next = current;
      current.prev.next = node,
      current.prev = node;

      return head;;
  }
#+end_src

**** Insert Node Sorted Doubly LList Tests
#+name:insert-node-sorted-doubly-llist-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir data-structures/linked_lists/node
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/insert_sorted_doubly_llist.tests.sh
  export OUTPUT_PATH=insert-sorted-doubly-llist-results
  echo Inputs:
  echo \
  '3
  4
  1
  3
  4
  10
  5
  4
  1
  3
  4
  10
  0
  4
  1
  3
  4
  10
  11' | node insert_sorted_doubly_llist.js
  echo
  echo Results:
  cat insert-sorted-doubly-llist-results
#+end_src
*** Reverse a Doubly Linked List
:PROPERTIES:
:level:    easy
:max-score: 5
:success-rate: 97.52%
:score:    5
:current-score: 215
:current-rank: 366882
:END:
**** Reverse a Double Linked List Problem Statement
You’re given the pointer to the head node of a doubly linked list.  Reverse the
order of the nodes in the list.  The head node might be NULL to indicate that
the list is empty.  Change the next and prev pointers of all the nodes so that
the direction of the list is reversed.  Return a reference to the head node of
the reversed list.

{{{heading(Function Description)}}}

Complete the reverse function in the editor below. It should return a reference
to the head of your reversed list.  ~reverse~ has the following parameter(s):

- ~head~: a reference to the head of a ~DoublyLinkedList~


{{{heading(Input Format)}}}

The first line contains an integer ~t~, the number of test cases.

Each test case is of the following format:

- The first line contains an integer ~n~, the number of elements in the linked
  list.

- The next ~n~ lines contain an integer each denoting an element of the linked
  list.


{{{subheading(Sample Input)}}}

#+begin_example
1
4
1
2
3
4
#+end_example

{{{heading(Constraints)}}}

- 1 \le t \le  10

- 0 \le n \le  1000

- 0 \le data \le 1000


{{{heading(Output Format)}}}

Return a reference to the head of your reversed list.  The provided code will
print the reverse array as a one line of space-separated integers for each test
case.

{{{subheading(Sample Output)}}}

: 4 3 2 1 

{{{heading(Explanation)}}}

The initial doubly linked list is: 1 \leftrightarrow 2 \leftrightarrow 3 \leftrightarrow 4 \rightarrow null

The reversed doubly linked list is: 4 \leftrightarrow 3 \leftrightarrow 2 \leftrightarrow 1 \rightarrow null

**** Reverse a Double Linked List Node CL Processing and Classes
#+name:reverse-double-llist-node-cl-processing_and_classes
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle data-structures/linked_lists/node/reverse_double_llist.js
<<node-process-command-line-arguments>>
<<doubly-llist-node-class>>
<<doubly-llist-class>>
<<doubly-llist-print-function>>
#+end_src

**** Reverse a Double Linked List Main Function
#+name:reverse-double-llist-main
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_double_llist.js
  function main() {
      const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

      const t = parseInt(readLine(), 10);
      console.log(`tests: ${t}`);

      for (let tItr = 0; tItr < t; tItr++) {
          console.log(`\ntest: ${tItr + 1}`);
          const llistCount = parseInt(readLine(), 10);
          console.log(`n: ${llistCount}`);

          let llist = new DoublyLinkedList();

          for (let i = 0; i < llistCount; i++) {
              const llistItem = parseInt(readLine(), 10);
              console.log(`data[${i}]: ${llistItem}`);
              llist.insertNode(llistItem);
          }

          let llist1 = reverse(llist.head);

          printDoublyLinkedList(llist1, " ", ws);
          ws.write("\n");
      }

      ws.end();
  }
#+end_src

**** Reverse a Double Linked List reverse Function
#+name:reverse-double-llist-reverse
#+begin_src js +n :tangle data-structures/linked_lists/node/reverse_double_llist.js
  // Complete the reverse function below.

  /*
   ,* For your reference:
   ,*
   ,* DoublyLinkedListNode {
   ,*     int data;
   ,*     DoublyLinkedListNode next;
   ,*     DoublyLinkedListNode prev;
   ,* }
   ,*
   ,*/
  function reverse(head) {
      let current = head,
          next = null,
          prev = null;

      while (current !== null) {
          next = current.next;
          prev = current;

          current.next = current.prev;
          current.prev = next;
          current = next;
      }
      return prev;
  }
#+end_src

**** Reverse a Double Linked List Tests
#+name:reverse-double-llist-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir
#+header: :results output :exports results
#+begin_src sh :tangle data-structures/linked_lists/node/reverse_double_llist.test.sh
  export OUTPUT_PATH=reverse-double-llist-results
  echo Inputs:
  echo \
  '4
  4
  1
  2
  3
  4
  1
  1
  2
  1
  2
  0' | node reverse_double_llist.js
  echo
  echo Results:
  cat reverse-double-llist-results
#+end_src

* Algorithms
** Solve First
:PROPERTIES:
:level:    easy
:max-score: 1
:success-rate: 98.27%
:END:
Complete the function ~solveMeFirst~ to compute the sum of two integers.

{{{heading(Function prototype:)}}}

~int solveMeFirst(int a, int b);~

where

- ~a~ is the first integer input.
- ~b~ is the second integer input


{{{heading(Return values)}}}

- sum of the above two integers

{{{heading(Sample input)}}}

#+begin_example
a = 2
b = 3
#+end_example

{{{heading(Sample output)}}}

: 5

{{{heading(Explanation)}}}

The sum of the two integers ~a~ and ~b~ is computed as: =2 + 3 = 5=.

#+name:solveMeFirst
#+begin_src js -n :tangle algorithms/node/solveMeFirst.js :mkdirp yes
<<node-process-command-line-arguments>>
function main() {
    var a = parseInt(readLine());
    var b = parseInt(readLine());;

    var res = solveMeFirst(a, b);
    console.log(res);
}

function solveMeFirst(a, b) {
  // Hint: Type return a+b below
  return a+b;
}
#+end_src
** Simple Array Sum
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 94.32%
:score:    10
:current-rank: 351026
:current-score: 226
:END:
Calculate the sum of integers in an array.

*** Problem Statement
Given an array of integers, find the sum of its elements.

For example, if the array ~ar~ = ~[1,2,3]~, 1 \plus 2 \plus 3 = 6,
so return 6.

{{{heading(Functional Description)}}}

Complete the ~simpleArraySum~ function in the editor below.  It must return the
sum of the array elements as an integer.

~simpleArraySum~ has the following parameter(s):

- ~ar~ :: an array of integers


{{{heading(Input Format)}}}

The first line contains an integer, ~n~, denoting the size of the array.

The second line contains ~n~ space-separated integers representing the array's
elements.

{{{subheading(Sample Input)}}}

#+begin_example
6
1 2 3 4 10 11
#+end_example

{{{heading(Constraints)}}}

- 0 \le n, ar[i] \le 1000


{{{heading(Output Format)}}}

Print the sum of the array's elements as a single integer.

{{{subheading(Sample Output)}}}

: 31

{{{heading(Explanation)}}}

We print the sum of the array's elements: 1 \plus 2 \plus 3 \plus 4 \plus 10
\plus 11 = 31.

*** Simple Array Sum Node CL Processing
#+name:simple-array-sum-node-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle algorithms/node/simple_array_sum.js
<<node-process-command-line-arguments>>
#+end_src

*** Simple Array Sum Main Function
#+name:simple-array-sum-main
#+begin_src js +n :tangle algorithms/node/simple_array_sum.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const arCount = parseInt(readLine(), 10);
    console.log(`n: ${arCount}`);

    const ar = readLine().split(' ').map(arTemp => parseInt(arTemp, 10));
    console.log(`ar: ${ar}`);

    let result = simpleArraySum(ar);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

*** Simple Array Sum simpleArraySum Function
#+name:simple-array-sum-simpleArraySum
#+begin_src js +n :tangle algorithms/node/simple_array_sum.js
/*
 ,* Complete the simpleArraySum function below.
 ,*/
function simpleArraySum(ar) {
    /*
     ,* Write your code here.
     ,*/
     return ar.reduce((a,e) => a + e,0);
}
#+end_src

*** Simple Array Sum Tests
#+name:simple-array-sum-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :exports results
#+begin_src sh :tangle algorithms/node/simple_array_sum.tests.sh
export OUTPUT_PATH=simple-array-sum-results
echo Inputs:
echo \
'6
1 2 3 4 10 11' | node simple_array_sum.js
echo
echo Result:
cat simple-array-sum-results
#+end_src
** Compare the Triplets
:PROPERTIES:
:level:    easy
:max-score: 10n
:success-rate: 94.18%
:score:    10
:current-rank: 339505
:current-score: 236
:END:
Compre the elements in two triplets.
*** Compare the Triplets Problem Statement
Alice and Bob each created one problem for HackerRank.  A reviewer rates the
two challenges, awarding points on a scale from 1 to 100 for three categories:
problem clarity, originality, and difficulty.

We define the rating for Alice's challenge to be the triplet ~a = ( a[0], a[1],
a[2] )~, and the rating for Bob's challenge to be the triplet ~b = ( b[0],
b[1], b[2] )~.

Your task is to find their comparison points by comparing ~a[0]~ with ~b[0]~,
~a[1]~ with ~b[1]~, and ~a[2]~ with ~b[2]~.

- if ~a[i]~ \gt ~b[i]~, then Alice is awarded 1 point

- if ~a[i]~ \lt ~b[i]~, then Bob is awarded 1 point

- if ~a[i]~ = ~b[i]~, then neither person is awarded any points


Comparison points is the total points a person earned.

Given ~a~ and ~b~, determine their respective comparison points.

For example, ~a = [1, 2, 3]~ and ~b = [3, 2, 1]~.  For elements 0, Bob is
awarded a point because ~a[0] \lt b[0]~.  For the equal elements ~a[1]~ and
~b[1]~, no points are earned.  Finally, for elements 2, ~a[2] \gt b[2]~ so
Alice receives a point.  Your return array would be ~[1, 1]~ with Alice's score
first and Bob's second.


{{{heading(Function Description)}}}

Complete the function ~compareTriplets~ in the editor below.  It must return an
array of two integers, the first being Alice's score and the second being
Bob's.

~compareTriplets~ has the following parameter(s):

- ~a~ :: an array of integers representing Alice's challenge rating

- ~b~ :: an array of integers representing Bob's challenge rating


{{{heading(Input Format)}}}

The first line contains 3 space-separated integers, ~a[0]~, ~a[1]~, and ~a[2]~,
describing the respective values in triplet ~a~.  The second line contains 3
space-separated integers, ~b[0]~, ~b[1]~, and ~b[2]~, describing the respective
values in triplet ~b~.

{{{subheading(Sample Input 0)}}}

#+begin_example
5 6 7
3 6 10
#+end_example

{{{subheading(Sample Input 1)}}}

#+begin_example
17 28 30
99 16 8
#+end_example

{{{heading(Constraints)}}}

- 1 \le ~a[i]~ \le 100

- 1 \le ~b[i]~ \le 100


{{{heading(Output Format)}}}

Return an array of two integers denoting the respective comparison points
earned by Alice and Bob.

{{{subheading(Sample Output 0)}}}

: 1 1

{{{subheading(Sample Output 1)}}}

: 2 1

*** Compare the Triplets Node CL Processing
#+name:compare-the-triplets-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/compare_the_triplets.js
<<node-process-command-line-arguments>>
#+end_src

*** Compare the Triplets Main Function
#+name:compare-the-triplets-main
#+begin_src js +n :tangle algorithms/node/compare_the_triplets.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH, {flags: 'a+'});

    const a = readLine().replace(/\s+$/g, '').split(' ').map(aTemp => parseInt(aTemp, 10));
    console.log(`a: ${a}`);

    const b = readLine().replace(/\s+$/g, '').split(' ').map(bTemp => parseInt(bTemp, 10));
    console.log(`b: ${b}`);

    const result = compareTriplets(a, b);

    ws.write(result.join(' ') + '\n');

    ws.end();
}
#+end_src

*** Compare the Triplets compareTriplets Function
#+name:compare-the-triplets-compareTriplets
#+begin_src js +n :tangle algorithms/node/compare_the_triplets.js
// Complete the compareTriplets function below.
function compareTriplets(a, b) {
    return a.reduce((acc,e,i) => {
        if (e > b[i]) { acc[0]++; return acc; }
        if (e < b[i]) { acc[1]++; return acc; }
        return acc;
    },[0,0]);
}
#+end_src

*** Compare the Triplets Tests
#+name:compare-the-triplets-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :export results
#+begin_src sh :tangle algorithms/node/compare_the_triplets.tests.sh
export OUTPUT_PATH=compare_the_triplets_results
echo
echo Inputs:
echo \
'5 6 7
3 6 10' | node compare_the_triplets.js
echo
echo Inputs
echo \
'17 28 30
99 16 8' | node compare_the_triplets.js
echo
echo Results:
cat compare_the_triplets_results
echo
#+end_src
** A Very Big Sum
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 98.61%
:score:    10
:current-score: 246
:current-rank: 327624
:END:
Calculate the sum of the values in an array that might exceed the range of int
values.
*** A Very Big Sum Problem Statement
Calculate and print the sum of the elements in an array, keeping in mind that
some of those integers may be quite large.

{{{heading(Function Description)}}}

Complete the ~aVeryBigSum~ function in the editor below. It must return the sum
of all array elements.

~aVeryBigSum~ has the following parameter(s):

- ~ar~ :: an array of integers.


{{{heading(Input Format)}}}

The first line of the input consists of an integer ~n~.

The next line contains ~n~ space-separated integers contained in the array.

{{{subheading(Sample Input)}}}

#+begin_example
5
1000000001 1000000002 1000000003 1000000004 1000000005
#+end_example

{{{heading(Output Format)}}}

Print the integer sum of the elements in the array.

{{{subheading(Sample Output)}}}

: 5000000015

{{{heading(Constraints)}}}

- 1 \le ~n~ \le 10

- 0 \le ~ar[i]~ \le 10^10

{{{heading(Note)}}}

The range of the 32-bit integer is ~(\minus 2^31)~ to ~(2^31 \minus 1)~, or
[\minus 2147483648, 2147483647].

When we add several integer values, the resulting sum might exceed the above
range. You might need to use =long long int= in C/C++ or =long= data type in
Java to store such sums.

*** A Very Big Sum Node CL Processing
#+name:a-very-big-sum-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/very_big_sum.js
<<node-process-command-line-arguments>>
#+end_src

*** A Very Big Sum Main Function
#+name:a-very-big-sum-main
#+begin_src js +n :tangle algorithms/node/very_big_sum.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const arCount = parseInt(readLine(), 10);
    console.log(`n: ${arCount}`);

    const ar = readLine().split(' ').map(arTemp => parseInt(arTemp, 10));
    console.log(`ar: ${ar}`);

    let result = aVeryBigSum(ar);

    ws.write(result + "\n");

    ws.end();
}
#+end_src

*** A Very Big Sum aVeryBigSum Function
#+cindex:@code{BigInt}
The built-in type =BigInt= is JavaScript's large integer Number type.
=BigInt=s are created by explicit conversion of a =Number=: ~BigInt(n)~, or by
adding the letter =n= to the end of a literal integer.  Both conversions are
demonstrated in this code.

#+name:a-very-big-sum-aVeryBigSum-function
#+begin_src js +n :tangle algorithms/node/very_big_sum.js
function readLine() {
    return inputString[currentLine++];
}

// Complete the aVeryBigSum function below.
function aVeryBigSum(ar) {
    return ar.reduce((a,e) => { return a + BigInt(e) },0n);
}
#+end_src

*** A Very Big Sum Tests
#+name:a-very-big-sum-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :exports results
#+begin_src sh :tangle algorithms/node/very_big_sum_tests.sh
export OUTPUT_PATH=very_big_sum_results
echo Inputs:
echo \
'5
1000000001 1000000002 1000000003 1000000004 1000000005' | node very_big_sum.js
echo
echo Results:
cat very_big_sum_results
#+end_src
** Diagonal Difference
:PROPERTIES:
:level:    easy
:max-score: 10
:success-rate: 95.82%
:END:
Calculate the absolute difference of sums across the two diagonals of a square
matrix.
*** Diagonal Difference Problem Statement
Given a square matrix, calculate the absolute difference between the sums of
its diagonals.  For example, the square matrix ~arr~ is shown below:

#+begin_example
1 2 3
4 5 6
9 8 9
#+end_example

The left-to-right diagonal = ~1 + 5 + 9 = 15~.  The right to left diagonal =
~3 + 5 + 9 = 17~.  Their absolute difference is ~|15 - 17| = 2~.

{{{heading(Function Description)}}}

Complete the ~diagonalDifference~ function in the editor below.  It must return
an integer representing the absolute diagonal difference.

~diagonalDifference~ takes the following parameter:

- ~arr~ :: an array of integers.


{{{heading(Input Format)}}}

The first line contains a single integer, ~n~, the number of rows and columns
in the matrix ~arr~.

Each of the next ~n~ lines describes a row, ~arr[i]~, and consists of ~n~
space-separated integers ~arr[i][j]~.


{{{subhading(Sample Input)}}}

#+begin_example
3
11 2 4
4 5 6
10 8 -12
#+end_example

{{{heading(Constraints)}}}

- ~\neg100~ \le ~arr[i][j]~ \le 100


{{{heading(Output Format)}}}

Print the absolute difference between the sums of the matrix's two diagonals as
a single integer.

{{{subheading(Sample Output)}}}

: 15

{{{heading(Explanation)}}}

The primary diagonal is:

#+begin_example
11
   5
     -12
#+end_example

Sum across the primary diagonal: ~11 + 5 - 12 = 4~

The secondary diagonal is:

#+begin_example
     4
   5
10
#+end_example

Sum across the secondary diagonal: ~4 + 5 + 10 = 19~

Difference: ~|4 - 19| = 15~

*** Diagonal Difference Node CL Processing
#+name:diagonal-difference-node-cl-processing
#+header: :mkdirp yes :noweb yes
#+begin_src js -n :tangle algorithms/node/diagonal_difference.js
<<node-process-command-line-arguments>>
#+end_src

*** Diagonal Difference Main Function
#+name:diagonal-difference-main-function
#+begin_src js +n :tangle algorithms/node/diagonal_difference.js
function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const n = parseInt(readLine().trim(), 10);
    console.log(`n: ${n}`);

    let arr = Array(n);

    for (let i = 0; i < n; i++) {
        arr[i] = readLine().replace(/\s+$/g, '').split(' ').map(arrTemp => parseInt(arrTemp, 10));
        console.log(`row[${i}]: ${arr[i]}`);
    }

    const result = diagonalDifference(arr);

    ws.write(result + '\n');

    ws.end();
}
#+end_src

*** Diagonal Difference diagonalDifference Function
#+name:diagonal-difference-function
#+begin_src js +n :tangle algorithms/node/diagonal_difference.js
/*
 * Complete the 'diagonalDifference' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts 2D_INTEGER_ARRAY arr as parameter.
 */

function diagonalDifference(arr) {
    // Write your code here
    return 0;
}
#+end_src

*** Diagonal Difference Tests
#+name:diagonal-dfference-tests
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir algorithms/node
#+header: :results output :exports results
#+begin_src sh +n :tangle algorithms/node/diagonal_difference.test.sh
export OUTPUT_PATH=diagonal_difference_results
echo Inputs:
echo \
'3
11 2 4
4 5 6
10 8 -12' | node diagonal_difference.js
echo
echo Result:
cat diagonal_difference_results
#+end_src

* Ten Days of JavaScript
** Ten Days of JavaScript---Day 0 Greeting
:PROPERTIES:
:level:    easy
:max-score: 10
:score:    10
:current-score: 10
:END:
*** Ten Days of JavaScript---Day 0 Overview
This series focuses on learning and practicing JavaScript.  Each challenge comes
with a tutorial article, and you can view these articles by clicking either the
Topics tab along the top or the article icon in the right-hand menu.

{{{heading(Objective)}}}

In this challenge, we review some basic concepts that will get you started with
this series.  Check out the tutorial to learn more about JavaScript's lexical
structure.

{{{heading(Task)}}}

A greeting function is provided for you in the editor below. It has one
parameter, ~parameterVariable~.  Perform the following tasks to complete this
challenge:

1. Use ~console.log()~ to print =Hello, World!= on a new line in the console,
   which is also known as ~stdout~ or standard output.  The code for this portion
   of the task is already provided in the editor.

2. Use ~console.log()~ to print the contents of ~parameterVariable~ (i.e., the
   argument passed to ~main~).


{{{heading(Input Format)}}}

| Data Type | Parameter           | Description                                                         |
|-----------+---------------------+---------------------------------------------------------------------|
| string    | ~parameterVariable~ | A single line of text containing one or more space-separated words. |
|-----------+---------------------+---------------------------------------------------------------------|

{{{subheading(Sample Input)}}}

: Welcome to 10 Days of JavaScript!

{{{heading(Output Format)}}}

Print the following two lines of output:

1. On the first line, print =Hello, World!= (this is provided for you in the
   editor).

2. On the second line, print the contents of ~parameterVariable~


{{{subheading(Sample Output)}}}

#+begin_example
Hello, World!
Welcome to 10 Days of JavaScript!
#+end_example

{{{heading(Explanation)}}}

We printed two lines of output:

1. We printed the literal string =Hello, World!= using the code provided in the
   editor.

2. The value of ~parameterVariable~ passed to our ~main~ function in this
   Sample Case was =Welcome to 10 Days of JavaScript!=.  We then passed our
   variable to ~console.log~, which printed the contents of
   ~parameterVariable~.

*** Ten Days of JavaScript---Day 0 Node CL Processing
#+name:ten-days-of-javascript-day-0-node-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle ten-days-of-javascript/day-0/hello_world.js
<<node-process-command-line-arguments>>
#+end_src

*** Ten Days of JavaScript---Day 0 Main Function
#+name:ten-days-of-javascript-day-0-main
#+begin_src js +n :tangle ten-days-of-javascript/day-0/hello_world.js
function main() {
    const parameterVariable = readLine();
    console.log(`parameterVariable: ${parameterVariable}`);

    console.log('\nOutput:');
    greeting(parameterVariable);
}
#+end_src

*** Ten Days of JavaScript---Day 0 Greeting Function
#+name:ten-days-of-javascript-day-0-greeting
#+begin_src js +n :tangle ten-days-of-javascript/day-0/hello_world.js
  /*
  ,*   A line of code that prints "Hello, World!" on a new line is provided in the editor.
  ,*   Write a second line of code that prints the contents of 'parameterVariable' on a new line.
  ,*
  ,*	Parameter:
  ,*   parameterVariable - A string of text.
  ,**/
  function greeting(parameterVariable) {
      // This line prints 'Hello, World!' to the console:
      console.log('Hello, World!');

      // Write a line of code that prints parameterVariable to stdout using console.log:
      console.log(parameterVariable);
  }
#+end_src

*** Ten Days of JavaScript---Day 0 Greeting Test
#+name:ten-days-of-javascript-day-0-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-0
#+header: :results output :exports results
#+begin_src sh :tangle ten-days-of-javascript/day-0/hello_world.test.sh
echo Input:
echo 'Welcome to 10 Days of JavaScript!' | node hello_world.js
#+end_src
** Ten Days of JavaScript---Day 0 DataTypes
:PROPERTIES:
:level:    easy
:max-score: 10
:score:    10
:current-score: 20
:END:

{{{heading(Objective)}}}

Today, we're discussing data types.  Check out the attached tutorial for more
details.

{{{heading(Task)}}}

Variables named ~firstInteger~, ~firstDecimal~, and ~firstString~ are declared
for you in the editor below.  You must use the =+= operator to perform the
following sequence of operations:

1. Convert ~secondInteger~ to an integer (=Number= type), then sum it with
   ~firstInteger~ and print the result on a new line using ~console.log~.

2. Convert ~secondDecimal~ to a floating-point number (=Number= type), then sum
   it with ~firstDecimal~ and print the result on a new line using
   ~console.log~.

3. Print the concatenation of ~firstString~ and ~secondString~ on a new line
   using ~console.log~.  Note that ~firstString~ must be printed first.


{{{heading(Input Format)}}}

| Data Type | Parameter       | Description                                                                            |
|-----------+-----------------+----------------------------------------------------------------------------------------|
| string    | ~secondInteger~ | The string representation of an integer you must sum with ~firstInteger~.              |
| string    | ~secondDecimal~ | The string representation of a floating-point number you must sum with ~firstDecimal~. |
| string    | ~secondString~  | A string of one or more space-separated words you must append to ~firstString~         |
|-----------+-----------------+----------------------------------------------------------------------------------------|

{{{subheading(Sample Input)}}}

#+begin_example
12
4.32
is the best place to learn and practice coding!
#+end_example

{{{heading(Output Format)}}}

Print the following three lines of output:

1. On the first line, print the sum of ~firstInteger~ and the integer
   representation of ~secondInteger~.

2. On the second line, print the sum of ~firstDecimal~ and the floating-point
   representation of ~secondDecimal~.

3. On the third line, print ~firstString~ concatenated with ~secondString~.
   You must print ~firstString~ before ~secondString~.


{{{subheading(Sample Output)}}}

#+begin_example
16
8.32
HackerRank is the best place to learn and practice coding!
#+end_example

{{{heading(Explanation)}}}

When we sum the integers 4 and 12, we get the integer 16.

When we sum the floating-point numbers 4.0 and 4.32, we get 8.32.

When we concatenate =HackerRank= with =is the best place to learn and practice
coding!=, we get =HackerRank is the best place to learn and practice coding!=.

*You will not pass this challenge if you attempt to assign the Sample Case
values to your variables instead of following the instructions above.*

*** Ten Days of JavaScript---Day 0 DataTypes Node CL Processing
#+name:ten-days-of-javascript-day-0-data-types-cl-processing
#+header: :noweb yes :mkdirp yes
#+begin_src js -n :tangle ten-days-of-javascript/day-0/data_types.js
<<node-process-command-line-arguments>>
#+end_src

*** Ten Days of JavaScript---Day 0 Data Types Main Function
#+name:ten-days-of-javascript-day-0-data-types-main
#+begin_src js +n :tangle ten-days-of-javascript/day-0/data_types.js
function main() {
    const secondInteger = readLine();
    console.log(`secondInteger: ${secondInteger}`);
    const secondDecimal = readLine();
    console.log(`secondDecimal: ${secondDecimal}`);
    const secondString = readLine();
    console.log(`secondString: ${secondString}`);

    console.log('\nOutput:');
    performOperation(secondInteger, secondDecimal, secondString);
}
#+end_src

*** Ten Days of JavaScript---Day 0 Data Types performOperation Function
#+name:ten-days-of-javascript-day-0-data-types-performOperation
#+begin_src js +n :tangle ten-days-of-javascript/day-0/data_types.js
  /*
  ,*   The variables 'firstInteger', 'firstDecimal', and 'firstString' are declared for you -- do not modify them.
  ,*   Print three lines:
  ,*   1. The sum of 'firstInteger' and the Number representation of 'secondInteger'.
  ,*   2. The sum of 'firstDecimal' and the Number representation of 'secondDecimal'.
  ,*   3. The concatenation of 'firstString' and 'secondString' ('firstString' must be first).
  ,*
  ,*	Parameter(s):
  ,*   secondInteger - The string representation of an integer.
  ,*   secondDecimal - The string representation of a floating-point number.
  ,*   secondString - A string consisting of one or more space-separated words.
  ,**/
  function performOperation(secondInteger, secondDecimal, secondString) {
      // Declare a variable named 'firstInteger' and initialize with integer value 4.
      const firstInteger = 4;

      // Declare a variable named 'firstDecimal' and initialize with floating-point value 4.0.
      const firstDecimal = 4.0;

      // Declare a variable named 'firstString' and initialize with the string "HackerRank".
      const firstString = 'HackerRank ';

      // Write code that uses console.log to print the sum of the
      // 'firstInteger' and 'secondInteger' (converted to a Number type)
      // on a new line.

      console.log(firstInteger + Number(secondInteger));

      // Write code that uses console.log to print the sum of
      // 'firstDecimal' and 'secondDecimal' (converted to a Number type)
      // on a new line.

      console.log(firstDecimal + Number(secondDecimal));

      // Write code that uses console.log to print the concatenation of
      // 'firstString' and 'secondString' on a new line. The variable
      // 'firstString' must be printed first.

      console.log(firstString + secondString);
  }
#+end_src

*** Ten Days of JavaScript---Day 0 Data Types Test
#+name:ten-days-of-javascript-day-0-data-types-test
#+header: :shebang "#!/usr/bin/env bash"
#+header: :dir ten-days-of-javascript/day-0
#+header: :results output :output results
#+begin_src sh :tangle ten-days-of-javascript/day-0/data_types.test.sh
echo Input:
echo \
'12
4.32
is the best place to learn and practice coding!' | node data_types.js
#+end_src

* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Export Settings                                                  :noexport:
** Options
#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:t tex:t
#+options: H:4

** Texinfo Export Settings
#+texinfo_filename:hackerrank.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Coding
#+texinfo_dir_title:HackerRank Coding Problems
#+texinfo_dir_desc:HackerRank coding problems
#+texinfo_printed_title:HackerRank Coding Problems

** HTML Export Settings
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.2.4)
#+latex_header:

* Macro Definitions                                                :noexport:
#+macro:heading @@texinfo:@heading @@@@html:<h4>@@$1@@html:</h4>@@
#+macro:subheading @@texinfo:@subheading @@@@html:<h5>@@$1@@html:</h5>@@
#+macro:dfn @@texinfo:@dfn{@@@@html:<b>@@$1@@texinfo:}@@@@html:</b>@@
#+macro:var @@texinfo:@var{@@$1@@texinfo:}@@
* Local Variables                                                  :noexport:
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
